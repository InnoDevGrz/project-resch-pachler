/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@splidejs/splide/dist/js/splide.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/@splidejs/splide/dist/js/splide.esm.js ***!
  \*************************************************************/
/***/ (function(module) {

eval("/*!\n * Splide.js\n * Version  : 2.4.20\n * License  : MIT\n * Copyright: 2020 Naotoshi Fujita\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(self, function() {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 311:\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_627__) => {\n\n// ESM COMPAT FLAG\n__nested_webpack_require_627__.r(__nested_webpack_exports__);\n\n// EXPORTS\n__nested_webpack_require_627__.d(__nested_webpack_exports__, {\n  \"default\": () => /* binding */ module_Splide\n});\n\n// NAMESPACE OBJECT: ./src/js/constants/states.js\nvar states_namespaceObject = {};\n__nested_webpack_require_627__.r(states_namespaceObject);\n__nested_webpack_require_627__.d(states_namespaceObject, {\n  \"CREATED\": () => CREATED,\n  \"DESTROYED\": () => DESTROYED,\n  \"IDLE\": () => IDLE,\n  \"MOUNTED\": () => MOUNTED,\n  \"MOVING\": () => MOVING\n});\n\n;// CONCATENATED MODULE: ./src/js/core/event.js\n/**\r\n * The function for providing an Event object simply managing events.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The function for providing an Event object simply managing events.\r\n */\n/* harmony default export */ const core_event = (function () {\n  /**\r\n   * Store all event data.\r\n   *\r\n   * @type {Array}\r\n   */\n  var data = [];\n  var Event = {\n    /**\r\n     * Subscribe the given event(s).\r\n     *\r\n     * @param {string}   events  - An event name. Use space to separate multiple events.\r\n     *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.\r\n     * @param {function} handler - A callback function.\r\n     * @param {Element}  elm     - Optional. Native event will be listened to when this arg is provided.\r\n     * @param {Object}   options - Optional. Options for addEventListener.\r\n     */\n    on: function on(events, handler, elm, options) {\n      if (elm === void 0) {\n        elm = null;\n      }\n\n      if (options === void 0) {\n        options = {};\n      }\n\n      events.split(' ').forEach(function (event) {\n        if (elm) {\n          elm.addEventListener(event, handler, options);\n        }\n\n        data.push({\n          event: event,\n          handler: handler,\n          elm: elm,\n          options: options\n        });\n      });\n    },\n\n    /**\r\n     * Unsubscribe the given event(s).\r\n     *\r\n     * @param {string}  events - A event name or names split by space.\r\n     * @param {Element} elm    - Optional. removeEventListener() will be called when this arg is provided.\r\n     */\n    off: function off(events, elm) {\n      if (elm === void 0) {\n        elm = null;\n      }\n\n      events.split(' ').forEach(function (event) {\n        data = data.filter(function (item) {\n          if (item && item.event === event && item.elm === elm) {\n            unsubscribe(item);\n            return false;\n          }\n\n          return true;\n        });\n      });\n    },\n\n    /**\r\n     * Emit an event.\r\n     * This method is only for custom events.\r\n     *\r\n     * @param {string}  event - An event name.\r\n     * @param {*}       args  - Any number of arguments passed to handlers.\r\n     */\n    emit: function emit(event) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      data.forEach(function (item) {\n        if (!item.elm && item.event.split('.')[0] === event) {\n          item.handler.apply(item, args);\n        }\n      });\n    },\n\n    /**\r\n     * Clear event data.\r\n     */\n    destroy: function destroy() {\n      data.forEach(unsubscribe);\n      data = [];\n    }\n  };\n  /**\r\n   * Remove the registered event listener.\r\n   *\r\n   * @param {Object} item - An object containing event data.\r\n   */\n\n  function unsubscribe(item) {\n    if (item.elm) {\n      item.elm.removeEventListener(item.event, item.handler, item.options);\n    }\n  }\n\n  return Event;\n});\n;// CONCATENATED MODULE: ./src/js/core/state.js\n/**\r\n * The function providing a super simple state system.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The function providing a super simple state system.\r\n *\r\n * @param {string|number} initialState - Provide the initial state value.\r\n */\n/* harmony default export */ const state = (function (initialState) {\n  /**\r\n   * Store the current state.\r\n   *\r\n   * @type {string|number}\r\n   */\n  var curr = initialState;\n  return {\n    /**\r\n     * Change state.\r\n     *\r\n     * @param {string|number} state - A new state.\r\n     */\n    set: function set(state) {\n      curr = state;\n    },\n\n    /**\r\n     * Verify if the current state is given one or not.\r\n     *\r\n     * @param {string|number} state - A state name to be verified.\r\n     *\r\n     * @return {boolean} - True if the current state is the given one.\r\n     */\n    is: function is(state) {\n      return state === curr;\n    }\n  };\n});\n;// CONCATENATED MODULE: ./src/js/utils/object.js\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n/**\r\n * Some utility functions related with Object, supporting IE.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\nvar keys = Object.keys;\n/**\r\n * Iterate an object like Array.forEach.\r\n * IE doesn't support forEach of HTMLCollection.\r\n *\r\n * @param {Object}    obj       - An object.\r\n * @param {function}  callback  - A function handling each value. Arguments are value, property and index.\r\n */\n\nfunction each(obj, callback) {\n  keys(obj).some(function (key, index) {\n    return callback(obj[key], key, index);\n  });\n}\n/**\r\n * Return values of the given object as an array.\r\n * IE doesn't support Object.values.\r\n *\r\n * @param {Object} obj - An object.\r\n *\r\n * @return {Array} - An array containing all values of the given object.\r\n */\n\nfunction values(obj) {\n  return keys(obj).map(function (key) {\n    return obj[key];\n  });\n}\n/**\r\n * Check if the given subject is object or not.\r\n *\r\n * @param {*} subject - A subject to be verified.\r\n *\r\n * @return {boolean} - True if object, false otherwise.\r\n */\n\nfunction isObject(subject) {\n  return typeof subject === 'object';\n}\n/**\r\n * Merge two objects deeply.\r\n *\r\n * @param {Object} to   - An object where \"from\" is merged.\r\n * @param {Object} from - An object merged to \"to\".\r\n *\r\n * @return {Object} - A merged object.\r\n */\n\nfunction merge(_ref, from) {\n  var to = _extends({}, _ref);\n\n  each(from, function (value, key) {\n    if (isObject(value)) {\n      if (!isObject(to[key])) {\n        to[key] = {};\n      }\n\n      to[key] = merge(to[key], value);\n    } else {\n      to[key] = value;\n    }\n  });\n  return to;\n}\n/**\r\n * Assign all properties \"from\" to \"to\" object.\r\n *\r\n * @param {Object} to   - An object where properties are assigned.\r\n * @param {Object} from - An object whose properties are assigned to \"to\".\r\n *\r\n * @return {Object} - An assigned object.\r\n */\n\nfunction object_assign(to, from) {\n  keys(from).forEach(function (key) {\n    if (!to[key]) {\n      Object.defineProperty(to, key, Object.getOwnPropertyDescriptor(from, key));\n    }\n  });\n  return to;\n}\n;// CONCATENATED MODULE: ./src/js/utils/utils.js\n/**\r\n * A package of some miscellaneous utility functions.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Convert the given value to array.\r\n *\r\n * @param {*} value - Any value.\r\n *\r\n * @return {*[]} - Array containing the given value.\r\n */\n\nfunction toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n/**\r\n * Check if the given value is between min and max.\r\n * Min will be returned when the value is less than min or max will do when greater than max.\r\n *\r\n * @param {number} value - A number to be checked.\r\n * @param {number} m1    - Minimum or maximum number.\r\n * @param {number} m2    - Maximum or minimum number.\r\n *\r\n * @return {number} - A value itself, min or max.\r\n */\n\nfunction between(value, m1, m2) {\n  return Math.min(Math.max(value, m1 > m2 ? m2 : m1), m1 > m2 ? m1 : m2);\n}\n/**\r\n * The sprintf method with minimum functionality.\r\n *\r\n * @param {string}       format       - The string format.\r\n * @param {string|Array} replacements - Replacements accepting multiple arguments.\r\n *\r\n * @returns {string} - Converted string.\r\n */\n\nfunction sprintf(format, replacements) {\n  var i = 0;\n  return format.replace(/%s/g, function () {\n    return toArray(replacements)[i++];\n  });\n}\n/**\r\n * Append px unit to the given subject if necessary.\r\n *\r\n * @param {number|string} value - A value that may not include an unit.\r\n *\r\n * @return {string} - If the value is string, return itself.\r\n *                    If number, do value + \"px\". An empty string, otherwise.\r\n */\n\nfunction unit(value) {\n  var type = typeof value;\n\n  if (type === 'number' && value > 0) {\n    return parseFloat(value) + 'px';\n  }\n\n  return type === 'string' ? value : '';\n}\n/**\r\n * Pad start with 0.\r\n *\r\n * @param {number} number - A number to be filled with 0.\r\n *\r\n * @return {string|number} - Padded number.\r\n */\n\nfunction pad(number) {\n  return number < 10 ? '0' + number : number;\n}\n/**\r\n * Convert the given value to pixel.\r\n *\r\n * @param {Element}       root  - Root element where a dummy div is appended.\r\n * @param {string|number} value - CSS value to be converted, such as 10rem.\r\n *\r\n * @return {number} - Pixel.\r\n */\n\nfunction toPixel(root, value) {\n  if (typeof value === 'string') {\n    var div = create('div', {});\n    applyStyle(div, {\n      position: 'absolute',\n      width: value\n    });\n    append(root, div);\n    value = div.clientWidth;\n    dom_remove(div);\n  }\n\n  return +value || 0;\n}\n;// CONCATENATED MODULE: ./src/js/utils/dom.js\n/**\r\n * Some utility functions related with DOM.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Find the first element matching the given selector.\r\n * Be aware that all selectors after a space are ignored.\r\n *\r\n * @param {Element|Node}  elm       - An ancestor element.\r\n * @param {string}        selector  - DOMString.\r\n *\r\n * @return {Element|null} - A found element or null.\r\n */\n\nfunction find(elm, selector) {\n  return elm ? elm.querySelector(selector.split(' ')[0]) : null;\n}\n/**\r\n * Find a first child having the given tag or class name.\r\n *\r\n * @param {Element} parent         - A parent element.\r\n * @param {string}  tagOrClassName - A tag or class name.\r\n *\r\n * @return {Element|undefined} - A found element on success or undefined on failure.\r\n */\n\nfunction child(parent, tagOrClassName) {\n  return children(parent, tagOrClassName)[0];\n}\n/**\r\n * Return chile elements that matches the provided tag or class name.\r\n *\r\n * @param {Element} parent         - A parent element.\r\n * @param {string}  tagOrClassName - A tag or class name.\r\n *\r\n * @return {Element[]} - Found elements.\r\n */\n\nfunction children(parent, tagOrClassName) {\n  if (parent) {\n    return values(parent.children).filter(function (child) {\n      return hasClass(child, tagOrClassName.split(' ')[0]) || child.tagName === tagOrClassName;\n    });\n  }\n\n  return [];\n}\n/**\r\n * Create an element with some optional attributes.\r\n *\r\n * @param {string} tag   - A tag name.\r\n * @param {Object} attrs - An object any attribute pairs of name and value.\r\n *\r\n * @return {Element} - A created element.\r\n */\n\nfunction create(tag, attrs) {\n  var elm = document.createElement(tag);\n  each(attrs, function (value, key) {\n    return setAttribute(elm, key, value);\n  });\n  return elm;\n}\n/**\r\n * Convert HTML string to DOM node.\r\n *\r\n * @param {string} html - HTML string.\r\n *\r\n * @return {Node} - A created node.\r\n */\n\nfunction domify(html) {\n  var div = create('div', {});\n  div.innerHTML = html;\n  return div.firstChild;\n}\n/**\r\n * Remove a given element from a DOM tree.\r\n *\r\n * @param {Element|Element[]} elms - Element(s) to be removed.\r\n */\n\nfunction dom_remove(elms) {\n  toArray(elms).forEach(function (elm) {\n    if (elm) {\n      var parent = elm.parentElement;\n      parent && parent.removeChild(elm);\n    }\n  });\n}\n/**\r\n * Append a child to a given element.\r\n *\r\n * @param {Element} parent - A parent element.\r\n * @param {Element} child  - An element to be appended.\r\n */\n\nfunction append(parent, child) {\n  if (parent) {\n    parent.appendChild(child);\n  }\n}\n/**\r\n * Insert an element before the reference element.\r\n *\r\n * @param {Element|Node} ref - A reference element.\r\n * @param {Element}      elm - An element to be inserted.\r\n */\n\nfunction before(elm, ref) {\n  if (elm && ref) {\n    var parent = ref.parentElement;\n    parent && parent.insertBefore(elm, ref);\n  }\n}\n/**\r\n * Apply styles to the given element.\r\n *\r\n * @param {Element} elm     - An element where styles are applied.\r\n * @param {Object}  styles  - Object containing styles.\r\n */\n\nfunction applyStyle(elm, styles) {\n  if (elm) {\n    each(styles, function (value, prop) {\n      if (value !== null) {\n        elm.style[prop] = value;\n      }\n    });\n  }\n}\n/**\r\n * Add or remove classes to/from the element.\r\n * This function is for internal usage.\r\n *\r\n * @param {Element}         elm     - An element where classes are added.\r\n * @param {string|string[]} classes - Class names being added.\r\n * @param {boolean}         remove  - Whether to remove or add classes.\r\n */\n\nfunction addOrRemoveClasses(elm, classes, remove) {\n  if (elm) {\n    toArray(classes).forEach(function (name) {\n      if (name) {\n        elm.classList[remove ? 'remove' : 'add'](name);\n      }\n    });\n  }\n}\n/**\r\n * Add classes to the element.\r\n *\r\n * @param {Element}          elm     - An element where classes are added.\r\n * @param {string|string[]}  classes - Class names being added.\r\n */\n\n\nfunction addClass(elm, classes) {\n  addOrRemoveClasses(elm, classes, false);\n}\n/**\r\n * Remove a class from the element.\r\n *\r\n * @param {Element}         elm     - An element where classes are removed.\r\n * @param {string|string[]} classes - A class name being removed.\r\n */\n\nfunction removeClass(elm, classes) {\n  addOrRemoveClasses(elm, classes, true);\n}\n/**\r\n * Verify if the provided element has the class or not.\r\n *\r\n * @param {Element} elm       - An element.\r\n * @param {string}  className - A class name.\r\n *\r\n * @return {boolean} - True if the element has the class or false if not.\r\n */\n\nfunction hasClass(elm, className) {\n  return !!elm && elm.classList.contains(className);\n}\n/**\r\n * Set attribute to the given element.\r\n *\r\n * @param {Element}                 elm   - An element where an attribute is assigned.\r\n * @param {string}                  name  - Attribute name.\r\n * @param {string|number|boolean}   value - Attribute value.\r\n */\n\nfunction setAttribute(elm, name, value) {\n  if (elm) {\n    elm.setAttribute(name, value);\n  }\n}\n/**\r\n * Get attribute from the given element.\r\n *\r\n * @param {Element} elm  - An element where an attribute is assigned.\r\n * @param {string}  name - Attribute name.\r\n *\r\n * @return {string} - The value of the given attribute if available. An empty string if not.\r\n */\n\nfunction getAttribute(elm, name) {\n  return elm ? elm.getAttribute(name) : '';\n}\n/**\r\n * Remove attribute from the given element.\r\n *\r\n * @param {Element|Element[]} elms  - An element where an attribute is removed.\r\n * @param {string|string[]}      names - Attribute name.\r\n */\n\nfunction removeAttribute(elms, names) {\n  toArray(names).forEach(function (name) {\n    toArray(elms).forEach(function (elm) {\n      return elm && elm.removeAttribute(name);\n    });\n  });\n}\n/**\r\n * Return the Rect object of the provided object.\r\n *\r\n * @param {Element} elm - An element.\r\n *\r\n * @return {ClientRect|DOMRect} - A rect object.\r\n */\n\nfunction getRect(elm) {\n  return elm.getBoundingClientRect();\n}\n/**\r\n * Trigger the given callback after all images contained by the element are loaded.\r\n *\r\n * @param {Element}  elm      - Element that may contain images.\r\n * @param {Function} callback - Callback function fired right after all images are loaded.\r\n */\n\nfunction loaded(elm, callback) {\n  var images = elm.querySelectorAll('img');\n  var length = images.length;\n\n  if (length) {\n    var count = 0;\n    each(images, function (img) {\n      img.onload = img.onerror = function () {\n        if (++count === length) {\n          callback();\n        }\n      };\n    });\n  } else {\n    // Trigger the callback immediately if there is no image.\n    callback();\n  }\n}\n;// CONCATENATED MODULE: ./src/js/constants/types.js\n/**\r\n * Export slider types.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Normal slider.\r\n *\r\n * @type {string}\r\n */\nvar SLIDE = 'slide';\n/**\r\n * Loop after the last slide and before the first one.\r\n *\r\n * @type {string}\r\n */\n\nvar LOOP = 'loop';\n/**\r\n * The track doesn't move.\r\n *\r\n * @type {string}\r\n */\n\nvar FADE = 'fade';\n;// CONCATENATED MODULE: ./src/js/transitions/slide/index.js\n/**\r\n * The component for general slide effect transition.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The component for general slide effect transition.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const slide = (function (Splide, Components) {\n  /**\r\n   * Hold the list element.\r\n   *\r\n   * @type {Element}\r\n   */\n  var list;\n  /**\r\n   * Hold the onEnd callback function.\r\n   *\r\n   * @type {function}\r\n   */\n\n  var endCallback;\n  return {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      list = Components.Elements.list;\n      Splide.on('transitionend', function (e) {\n        if (e.target === list && endCallback) {\n          endCallback();\n        }\n      }, list);\n    },\n\n    /**\r\n     * Start transition.\r\n     *\r\n     * @param {number}   destIndex - Destination slide index that might be clone's.\r\n     * @param {number}   newIndex  - New index.\r\n     * @param {number}   prevIndex - Previous index.\r\n     * @param {Object}   coord     - Destination coordinates.\r\n     * @param {function} done      - Callback function must be invoked when transition is completed.\r\n     */\n    start: function start(destIndex, newIndex, prevIndex, coord, done) {\n      var options = Splide.options;\n      var edgeIndex = Components.Controller.edgeIndex;\n      var speed = options.speed;\n      endCallback = done;\n\n      if (Splide.is(SLIDE)) {\n        if (prevIndex === 0 && newIndex >= edgeIndex || prevIndex >= edgeIndex && newIndex === 0) {\n          speed = options.rewindSpeed || speed;\n        }\n      }\n\n      applyStyle(list, {\n        transition: \"transform \" + speed + \"ms \" + options.easing,\n        transform: \"translate(\" + coord.x + \"px,\" + coord.y + \"px)\"\n      });\n    }\n  };\n});\n;// CONCATENATED MODULE: ./src/js/transitions/fade/index.js\n/**\r\n * The component for fade transition.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The component for fade transition.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const fade = (function (Splide, Components) {\n  var Fade = {\n    /**\r\n     * Called when the component is mounted.\r\n     * Apply transition style to the first slide.\r\n     */\n    mount: function mount() {\n      apply(Splide.index);\n    },\n\n    /**\r\n     * Start transition.\r\n     *\r\n     * @param {number}    destIndex - Destination slide index that might be clone's.\r\n     * @param {number}    newIndex  - New index.\r\n     * @param {number}    prevIndex - Previous index.\r\n     * @param {Object}    coord     - Destination coordinates.\r\n     * @param {function}  done      - Callback function must be invoked when transition is completed.\r\n     */\n    start: function start(destIndex, newIndex, prevIndex, coord, done) {\n      var track = Components.Elements.track;\n      applyStyle(track, {\n        height: unit(track.clientHeight)\n      });\n      apply(newIndex);\n      setTimeout(function () {\n        done();\n        applyStyle(track, {\n          height: ''\n        });\n      });\n    }\n  };\n  /**\r\n   * Apply transition style to the slide specified by the given index.\r\n   *\r\n   * @param {number} index - A slide index.\r\n   */\n\n  function apply(index) {\n    var options = Splide.options;\n    applyStyle(Components.Elements.slides[index], {\n      transition: \"opacity \" + options.speed + \"ms \" + options.easing\n    });\n  }\n\n  return Fade;\n});\n;// CONCATENATED MODULE: ./src/js/transitions/index.js\n/**\r\n * Export transition components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n;// CONCATENATED MODULE: ./src/js/core/composer.js\n/**\r\n * Provide a function for composing components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * Compose components.\r\n *\r\n * @param {Splide}   Splide     - Splide instance.\r\n * @param {Object}   Components - Additional components.\r\n * @param {function} Transition - Change component for transition.\r\n *\r\n * @return {Object} - An object containing all components.\r\n */\n\nfunction compose(Splide, Components, Transition) {\n  var components = {};\n  each(Components, function (Component, name) {\n    components[name] = Component(Splide, components, name.toLowerCase());\n  });\n\n  if (!Transition) {\n    Transition = Splide.is(FADE) ? fade : slide;\n  }\n\n  components.Transition = Transition(Splide, components);\n  return components;\n}\n;// CONCATENATED MODULE: ./src/js/utils/error.js\n/**\r\n * Utility functions for outputting logs.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Prefix of an error massage.\r\n *\r\n * @type {string}\r\n */\nvar MESSAGE_PREFIX = '[SPLIDE]';\n/**\r\n * Display an error message on the browser console.\r\n *\r\n * @param {string} message - An error message.\r\n */\n\nfunction error(message) {\n  console.error(MESSAGE_PREFIX + \" \" + message);\n}\n/**\r\n * Check existence of the given object and throw an error if it doesn't.\r\n *\r\n * @throws {Error}\r\n *\r\n * @param {*}      subject - A subject to be confirmed.\r\n * @param {string} message - An error message.\r\n */\n\nfunction exist(subject, message) {\n  if (!subject) {\n    throw new Error(message);\n  }\n}\n;// CONCATENATED MODULE: ./src/js/constants/classes.js\n/**\r\n * Export class names.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * A root class name.\r\n *\r\n * @type {string}\r\n */\nvar ROOT = 'splide';\n/**\r\n * The definition table of all classes for elements.\r\n * They might be modified by options.\r\n *\r\n * @type {Object}\r\n */\n\nvar ELEMENT_CLASSES = {\n  root: ROOT,\n  slider: ROOT + \"__slider\",\n  track: ROOT + \"__track\",\n  list: ROOT + \"__list\",\n  slide: ROOT + \"__slide\",\n  container: ROOT + \"__slide__container\",\n  arrows: ROOT + \"__arrows\",\n  arrow: ROOT + \"__arrow\",\n  prev: ROOT + \"__arrow--prev\",\n  next: ROOT + \"__arrow--next\",\n  pagination: ROOT + \"__pagination\",\n  page: ROOT + \"__pagination__page\",\n  clone: ROOT + \"__slide--clone\",\n  progress: ROOT + \"__progress\",\n  bar: ROOT + \"__progress__bar\",\n  autoplay: ROOT + \"__autoplay\",\n  play: ROOT + \"__play\",\n  pause: ROOT + \"__pause\",\n  spinner: ROOT + \"__spinner\",\n  sr: ROOT + \"__sr\"\n};\n/**\r\n * Definitions of status classes.\r\n *\r\n * @type {Object}\r\n */\n\nvar STATUS_CLASSES = {\n  active: 'is-active',\n  visible: 'is-visible',\n  loading: 'is-loading'\n};\n;// CONCATENATED MODULE: ./src/js/constants/i18n.js\n/**\r\n * Export i18n texts as object.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Texts for i18n.\r\n *\r\n * @type {Object}\r\n */\nvar I18N = {\n  prev: 'Previous slide',\n  next: 'Next slide',\n  first: 'Go to first slide',\n  last: 'Go to last slide',\n  slideX: 'Go to slide %s',\n  pageX: 'Go to page %s',\n  play: 'Start autoplay',\n  pause: 'Pause autoplay'\n};\n;// CONCATENATED MODULE: ./src/js/constants/defaults.js\n/**\r\n * Export default options.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\nvar DEFAULTS = {\n  /**\r\n   * Determine a slider type.\r\n   * - 'slide': Regular slider.\r\n   * - 'loop' : Carousel slider.\r\n   * - 'fade' : Change slides with fade transition. perPage, drag options are ignored.\r\n   *\r\n   * @type {string}\r\n   */\n  type: 'slide',\n\n  /**\r\n   * Whether to rewind a slider before the first slide or after the last one.\r\n   * In \"loop\" mode, this option is ignored.\r\n   *\r\n   * @type {boolean}\r\n   */\n  rewind: false,\n\n  /**\r\n   * Transition speed in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\n  speed: 400,\n\n  /**\r\n   * Transition speed on rewind in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\n  rewindSpeed: 0,\n\n  /**\r\n   * Whether to prevent any actions while a slider is transitioning.\r\n   * If false, navigation, drag and swipe work while the slider is running.\r\n   * Even so, it will be forced to wait for transition in some cases in the loop mode to shift a slider.\r\n   *\r\n   * @type {boolean}\r\n   */\n  waitForTransition: true,\n\n  /**\r\n   * Define slider max width.\r\n   *\r\n   * @type {number}\r\n   */\n  width: 0,\n\n  /**\r\n   * Define slider height.\r\n   *\r\n   * @type {number}\r\n   */\n  height: 0,\n\n  /**\r\n   * Fix width of slides. CSS format is allowed such as 10em, 80% or 80vw.\r\n   * perPage number will be ignored when this option is falsy.\r\n   *\r\n   * @type {number|string}\r\n   */\n  fixedWidth: 0,\n\n  /**\r\n   * Fix height of slides. CSS format is allowed such as 10em, 80vh but % unit is not accepted.\r\n   * heightRatio option will be ignored when this option is falsy.\r\n   *\r\n   * @type {number|string}\r\n   */\n  fixedHeight: 0,\n\n  /**\r\n   * Determine height of slides by ratio to a slider width.\r\n   * This will be ignored when the fixedHeight is provided.\r\n   *\r\n   * @type {number}\r\n   */\n  heightRatio: 0,\n\n  /**\r\n   * If true, slide width will be determined by the element width itself.\r\n   * - perPage/perMove should be 1.\r\n   *\r\n   * @type {boolean}\r\n   */\n  autoWidth: false,\n\n  /**\r\n   * If true, slide height will be determined by the element width itself.\r\n   * - perPage/perMove should be 1.\r\n   *\r\n   * @type {boolean}\r\n   */\n  autoHeight: false,\n\n  /**\r\n   * Determine how many slides should be displayed per page.\r\n   *\r\n   * @type {number}\r\n   */\n  perPage: 1,\n\n  /**\r\n   * Determine how many slides should be moved when a slider goes to next or perv.\r\n   *\r\n   * @type {number}\r\n   */\n  perMove: 0,\n\n  /**\r\n   * Determine manually how many clones should be generated on the left and right side.\r\n   * The total number of clones will be twice of this number.\r\n   *\r\n   * @type {number}\r\n   */\n  clones: 0,\n\n  /**\r\n   * Start index.\r\n   *\r\n   * @type {number}\r\n   */\n  start: 0,\n\n  /**\r\n   * Determine which slide should be focused if there are multiple slides in a page.\r\n   * A string \"center\" is acceptable for centering slides.\r\n   *\r\n   * @type {boolean|number|string}\r\n   */\n  focus: false,\n\n  /**\r\n   * Gap between slides. CSS format is allowed such as 1em.\r\n   *\r\n   * @type {number|string}\r\n   */\n  gap: 0,\n\n  /**\r\n   * Set padding-left/right in horizontal mode or padding-top/bottom in vertical one.\r\n   * Give a single value to set a same size for both sides or\r\n   * do an object for different sizes.\r\n   * Also, CSS format is allowed such as 1em.\r\n   *\r\n   * @example\r\n   * - 10: Number\r\n   * - '1em': CSS format.\r\n   * - { left: 0, right: 20 }: Object for different sizes in horizontal mode.\r\n   * - { top: 0, bottom: 20 }: Object for different sizes in vertical mode.\r\n   *\r\n   * @type {number|string|Object}\r\n   */\n  padding: 0,\n\n  /**\r\n   * Whether to append arrows.\r\n   *\r\n   * @type {boolean}\r\n   */\n  arrows: true,\n\n  /**\r\n   * Change the arrow SVG path like 'm7.61 0.807-2.12...'.\r\n   *\r\n   * @type {string}\r\n   */\n  arrowPath: '',\n\n  /**\r\n   * Whether to append pagination(indicator dots) or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  pagination: true,\n\n  /**\r\n   * Activate autoplay.\r\n   *\r\n   * @type {boolean}\r\n   */\n  autoplay: false,\n\n  /**\r\n   * Autoplay interval in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\n  interval: 5000,\n\n  /**\r\n   * Whether to stop autoplay when a slider is hovered.\r\n   *\r\n   * @type {boolean}\r\n   */\n  pauseOnHover: true,\n\n  /**\r\n   * Whether to stop autoplay when a slider elements are focused.\r\n   * True is recommended for accessibility.\r\n   *\r\n   * @type {boolean}\r\n   */\n  pauseOnFocus: true,\n\n  /**\r\n   * Whether to reset progress of the autoplay timer when resumed.\r\n   *\r\n   * @type {boolean}\r\n   */\n  resetProgress: true,\n\n  /**\r\n   * Loading images lazily.\r\n   * Image src must be provided by a data-splide-lazy attribute.\r\n   *\r\n   * - false: Do nothing.\r\n   * - 'nearby': Only images around an active slide will be loaded.\r\n   * - 'sequential': All images will be sequentially loaded.\r\n   *\r\n   * @type {boolean|string}\r\n   */\n  lazyLoad: false,\n\n  /**\r\n   * This option works only when a lazyLoad option is \"nearby\".\r\n   * Determine how many pages(not slides) around an active slide should be loaded beforehand.\r\n   *\r\n   * @type {number}\r\n   */\n  preloadPages: 1,\n\n  /**\r\n   * Easing for CSS transition. For example, linear, ease or cubic-bezier().\r\n   *\r\n   * @type {string}\r\n   */\n  easing: 'cubic-bezier(.42,.65,.27,.99)',\n\n  /**\r\n   * Whether to enable keyboard shortcuts\r\n   * - true or 'global': Listen to keydown event of the document.\r\n   * - 'focused': Listen to the keydown event of the slider root element. tabindex=\"0\" will be added to the element.\r\n   * - false: Disable keyboard shortcuts.\r\n   *\r\n   * @type {boolean|string}\r\n   */\n  keyboard: 'global',\n\n  /**\r\n   * Whether to allow mouse drag and touch swipe.\r\n   *\r\n   * @type {boolean}\r\n   */\n  drag: true,\n\n  /**\r\n   * The angle threshold for drag.\r\n   * The slider starts moving only when the drag angle is less than this threshold.\r\n   *\r\n   * @type {number}\r\n   */\n  dragAngleThreshold: 30,\n\n  /**\r\n   * Distance threshold for determining if the action is \"flick\" or \"swipe\".\r\n   * When a drag distance is over this value, the action will be treated as \"swipe\", not \"flick\".\r\n   *\r\n   * @type {number}\r\n   */\n  swipeDistanceThreshold: 150,\n\n  /**\r\n   * Velocity threshold for determining if the action is \"flick\" or \"swipe\".\r\n   * Around 0.5 is recommended.\r\n   *\r\n   * @type {number}\r\n   */\n  flickVelocityThreshold: .6,\n\n  /**\r\n   * Determine power of flick. The larger number this is, the farther a slider runs by flick.\r\n   * Around 500 is recommended.\r\n   *\r\n   * @type {number}\r\n   */\n  flickPower: 600,\n\n  /**\r\n   * Limit a number of pages to move by flick.\r\n   *\r\n   * @type {number}\r\n   */\n  flickMaxPages: 1,\n\n  /**\r\n   * Slider direction.\r\n   * - 'ltr': Left to right.\r\n   * - 'rtl': Right to left.\r\n   * - 'ttb': Top to bottom.\r\n   *\r\n   * @type {string}\r\n   */\n  direction: 'ltr',\n\n  /**\r\n   * Set img src to background-image of its parent element.\r\n   * Images with various sizes can be displayed as same dimension without cropping work.\r\n   * fixedHeight or heightRatio is required.\r\n   *\r\n   * @type {boolean}\r\n   */\n  cover: false,\n\n  /**\r\n   * Whether to enable accessibility(aria and screen reader texts) or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  accessibility: true,\n\n  /**\r\n   * Whether to add tabindex=\"0\" to visible slides or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  slideFocus: true,\n\n  /**\r\n   * Determine if a slider is navigation for another.\r\n   * Use \"sync\" API to synchronize two sliders.\r\n   *\r\n   * @type {boolean}\r\n   */\n  isNavigation: false,\n\n  /**\r\n   * Whether to trim spaces before the fist slide or after the last one when \"focus\" is not 0.\r\n   *\r\n   * @type {boolean}\r\n   */\n  trimSpace: true,\n\n  /**\r\n   * The \"is-active\" class is added after transition as default.\r\n   * If true, it will be added before move.\r\n   *\r\n   * @type {boolean}\r\n   */\n  updateOnMove: false,\n\n  /**\r\n   * Throttle duration in milliseconds for the resize event.\r\n   *\r\n   * @type {number}\r\n   */\n  throttle: 100,\n\n  /**\r\n   * Whether to destroy a slider or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  destroy: false,\n\n  /**\r\n   * Options for specific breakpoints.\r\n   *\r\n   * @example\r\n   * {\r\n   *   1000: {\r\n   *     perPage: 3,\r\n   *     gap: 20\r\n   *   },\r\n   *   600: {\r\n   *     perPage: 1,\r\n   *     gap: 5,\r\n   *   }\r\n   * }\r\n   *\r\n   * @type {boolean|Object}\r\n   */\n  breakpoints: false,\n\n  /**\r\n   * Collection of class names.\r\n   *\r\n   * @see ./classes.js\r\n   *\r\n   * @type {Object}\r\n   */\n  classes: ELEMENT_CLASSES,\n\n  /**\r\n   * Collection of i18n texts.\r\n   *\r\n   * @see ./i18n.js\r\n   *\r\n   * @type {Object}\r\n   */\n  i18n: I18N\n};\n;// CONCATENATED MODULE: ./src/js/constants/states.js\n/**\r\n * Export state constants.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Splide has been just created.\r\n *\r\n * @type {number}\r\n */\nvar CREATED = 1;\n/**\r\n * All components have been mounted and initialized.\r\n *\r\n * @type {number}\r\n */\n\nvar MOUNTED = 2;\n/**\r\n * Splide is ready for transition.\r\n *\r\n * @type {number}\r\n */\n\nvar IDLE = 3;\n/**\r\n * Splide is moving.\r\n *\r\n * @type {number}\r\n */\n\nvar MOVING = 4;\n/**\r\n * Splide is moving.\r\n *\r\n * @type {number}\r\n */\n\nvar DESTROYED = 5;\n;// CONCATENATED MODULE: ./src/js/splide.js\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * The main class for applying Splide to an element.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n\n\n/**\r\n * The main class for applying Splide to an element,\r\n * providing some APIs to control the behavior.\r\n */\n\nvar Splide = /*#__PURE__*/function () {\n  /**\r\n   * Splide constructor.\r\n   *\r\n   * @throws {Error} When the given root element or selector is invalid.\r\n   *\r\n   * @param {Element|string}  root       - A selector for a root element or an element itself.\r\n   * @param {Object}          options    - Optional. Options to change default behaviour.\r\n   * @param {Object}          Components - Optional. Components.\r\n   */\n  function Splide(root, options, Components) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (Components === void 0) {\n      Components = {};\n    }\n\n    this.root = root instanceof Element ? root : document.querySelector(root);\n    exist(this.root, 'An invalid element/selector was given.');\n    this.Components = null;\n    this.Event = core_event();\n    this.State = state(CREATED);\n    this.STATES = states_namespaceObject;\n    this._o = merge(DEFAULTS, options);\n    this._i = 0;\n    this._c = Components;\n    this._e = {}; // Extensions\n\n    this._t = null; // Transition\n  }\n  /**\r\n   * Compose and mount components.\r\n   *\r\n   * @param {Object}   Extensions - Optional. Additional components.\r\n   * @param {function} Transition - Optional. Set a custom transition component.\r\n   *\r\n   * @return {Splide|undefined} - This instance or undefined if an exception occurred.\r\n   */\n\n\n  var _proto = Splide.prototype;\n\n  _proto.mount = function mount(Extensions, Transition) {\n    var _this = this;\n\n    if (Extensions === void 0) {\n      Extensions = this._e;\n    }\n\n    if (Transition === void 0) {\n      Transition = this._t;\n    }\n\n    // Reset the state.\n    this.State.set(CREATED);\n    this._e = Extensions;\n    this._t = Transition;\n    this.Components = compose(this, merge(this._c, Extensions), Transition);\n\n    try {\n      each(this.Components, function (component, key) {\n        var required = component.required;\n\n        if (required === undefined || required) {\n          component.mount && component.mount();\n        } else {\n          delete _this.Components[key];\n        }\n      });\n    } catch (e) {\n      error(e.message);\n      return;\n    }\n\n    var State = this.State;\n    State.set(MOUNTED);\n    each(this.Components, function (component) {\n      component.mounted && component.mounted();\n    });\n    this.emit('mounted');\n    State.set(IDLE);\n    this.emit('ready');\n    applyStyle(this.root, {\n      visibility: 'visible'\n    });\n    this.on('move drag', function () {\n      return State.set(MOVING);\n    }).on('moved dragged', function () {\n      return State.set(IDLE);\n    });\n    return this;\n  }\n  /**\r\n   * Set sync target.\r\n   *\r\n   * @param {Splide} splide - A Splide instance.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\n  ;\n\n  _proto.sync = function sync(splide) {\n    this.sibling = splide;\n    return this;\n  }\n  /**\r\n   * Register callback fired on the given event(s).\r\n   *\r\n   * @param {string}   events  - An event name. Use space to separate multiple events.\r\n   *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.\r\n   * @param {function} handler - A callback function.\r\n   * @param {Element}  elm     - Optional. Native event will be listened to when this arg is provided.\r\n   * @param {Object}   options - Optional. Options for addEventListener.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\n  ;\n\n  _proto.on = function on(events, handler, elm, options) {\n    if (elm === void 0) {\n      elm = null;\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.Event.on(events, handler, elm, options);\n    return this;\n  }\n  /**\r\n   * Unsubscribe the given event.\r\n   *\r\n   * @param {string}  events - A event name.\r\n   * @param {Element} elm    - Optional. removeEventListener() will be called when this arg is provided.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\n  ;\n\n  _proto.off = function off(events, elm) {\n    if (elm === void 0) {\n      elm = null;\n    }\n\n    this.Event.off(events, elm);\n    return this;\n  }\n  /**\r\n   * Emit an event.\r\n   *\r\n   * @param {string} event - An event name.\r\n   * @param {*}      args  - Any number of arguments passed to handlers.\r\n   */\n  ;\n\n  _proto.emit = function emit(event) {\n    var _this$Event;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    (_this$Event = this.Event).emit.apply(_this$Event, [event].concat(args));\n\n    return this;\n  }\n  /**\r\n   * Go to the slide specified by the given control.\r\n   *\r\n   * @param {string|number} control - A control pattern.\r\n   * @param {boolean}       wait    - Optional. Whether to wait for transition.\r\n   */\n  ;\n\n  _proto.go = function go(control, wait) {\n    if (wait === void 0) {\n      wait = this.options.waitForTransition;\n    }\n\n    if (this.State.is(IDLE) || this.State.is(MOVING) && !wait) {\n      this.Components.Controller.go(control, false);\n    }\n\n    return this;\n  }\n  /**\r\n   * Verify whether the slider type is the given one or not.\r\n   *\r\n   * @param {string} type - A slider type.\r\n   *\r\n   * @return {boolean} - True if the slider type is the provided type or false if not.\r\n   */\n  ;\n\n  _proto.is = function is(type) {\n    return type === this._o.type;\n  }\n  /**\r\n   * Insert a slide.\r\n   *\r\n   * @param {Element|string} slide - A slide element to be added.\r\n   * @param {number}         index - A slide will be added at the position.\r\n   */\n  ;\n\n  _proto.add = function add(slide, index) {\n    if (index === void 0) {\n      index = -1;\n    }\n\n    this.Components.Elements.add(slide, index, this.refresh.bind(this));\n    return this;\n  }\n  /**\r\n   * Remove the slide designated by the index.\r\n   *\r\n   * @param {number} index - A slide index.\r\n   */\n  ;\n\n  _proto.remove = function remove(index) {\n    this.Components.Elements.remove(index);\n    this.refresh();\n    return this;\n  }\n  /**\r\n   * Destroy all Slide objects and clones and recreate them again.\r\n   */\n  ;\n\n  _proto.refresh = function refresh() {\n    this.emit('refresh:before').emit('refresh').emit('resize');\n    return this;\n  }\n  /**\r\n   * Destroy the Splide.\r\n   * \"Completely\" boolean is mainly for breakpoints.\r\n   *\r\n   * @param {boolean} completely - Destroy completely.\r\n   */\n  ;\n\n  _proto.destroy = function destroy(completely) {\n    var _this2 = this;\n\n    if (completely === void 0) {\n      completely = true;\n    }\n\n    // Postpone destroy because it should be done after mount.\n    if (this.State.is(CREATED)) {\n      this.on('ready', function () {\n        return _this2.destroy(completely);\n      });\n      return;\n    }\n\n    values(this.Components).reverse().forEach(function (component) {\n      component.destroy && component.destroy(completely);\n    });\n    this.emit('destroy', completely); // Destroy all event handlers, including ones for native events.\n\n    this.Event.destroy();\n    this.State.set(DESTROYED);\n    return this;\n  }\n  /**\r\n   * Return the current slide index.\r\n   *\r\n   * @return {number} - The current slide index.\r\n   // */\n  ;\n\n  _createClass(Splide, [{\n    key: \"index\",\n    get: function get() {\n      return this._i;\n    }\n    /**\r\n     * Set the current slide index.\r\n     *\r\n     * @param {number|string} index - A new index.\r\n     */\n    ,\n    set: function set(index) {\n      this._i = parseInt(index);\n    }\n    /**\r\n     * Return length of slides.\r\n     * This is an alias of Elements.length.\r\n     *\r\n     * @return {number} - A number of slides.\r\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.Components.Elements.length;\n    }\n    /**\r\n     * Return options.\r\n     *\r\n     * @return {Object} - Options object.\r\n     */\n\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this._o;\n    }\n    /**\r\n     * Set options with merging the given object to the current one.\r\n     *\r\n     * @param {Object} options - New options.\r\n     */\n    ,\n    set: function set(options) {\n      var created = this.State.is(CREATED);\n\n      if (!created) {\n        this.emit('update');\n      }\n\n      this._o = merge(this._o, options);\n\n      if (!created) {\n        this.emit('updated', this._o);\n      }\n    }\n    /**\r\n     * Return the class list.\r\n     * This is an alias of Splide.options.classList.\r\n     *\r\n     * @return {Object} - An object containing all class list.\r\n     */\n\n  }, {\n    key: \"classes\",\n    get: function get() {\n      return this._o.classes;\n    }\n    /**\r\n     * Return the i18n strings.\r\n     * This is an alias of Splide.options.i18n.\r\n     *\r\n     * @return {Object} - An object containing all i18n strings.\r\n     */\n\n  }, {\n    key: \"i18n\",\n    get: function get() {\n      return this._o.i18n;\n    }\n  }]);\n\n  return Splide;\n}();\n\n\n;// CONCATENATED MODULE: ./src/js/components/options/index.js\n/**\r\n * The component for initializing options.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The component for initializing options.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const options = (function (Splide) {\n  /**\r\n   * Retrieve options from the data attribute.\r\n   * Note that IE10 doesn't support dataset property.\r\n   *\r\n   * @type {string}\r\n   */\n  var options = getAttribute(Splide.root, 'data-splide');\n\n  if (options) {\n    try {\n      Splide.options = JSON.parse(options);\n    } catch (e) {\n      error(e.message);\n    }\n  }\n\n  return {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      if (Splide.State.is(CREATED)) {\n        Splide.index = Splide.options.start;\n      }\n    }\n  };\n});\n;// CONCATENATED MODULE: ./src/js/constants/directions.js\n/**\r\n * Export layout modes.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Enumerate slides from left to right.\r\n *\r\n * @type {string}\r\n */\nvar LTR = 'ltr';\n/**\r\n * Enumerate slides from right to left.\r\n *\r\n * @type {string}\r\n */\n\nvar RTL = 'rtl';\n/**\r\n * Enumerate slides in a col.\r\n *\r\n * @type {string}\r\n */\n\nvar TTB = 'ttb';\n;// CONCATENATED MODULE: ./src/js/components/elements/slide.js\n/**\r\n * The sub component for handling each slide.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n/**\r\n * Events for restoring original styles.\r\n *\r\n * @type {string}\r\n */\n\nvar STYLE_RESTORE_EVENTS = 'update.slide';\n/**\r\n * The sub component for handling each slide.\r\n *\r\n * @param {Splide}  Splide    - A Splide instance.\r\n * @param {number}  index     - An unique slide index.\r\n * @param {number}  realIndex - Clones should pass a real slide index.\r\n * @param {Element} slide     - A slide element.\r\n *\r\n * @return {Object} - The sub component object.\r\n */\n\n/* harmony default export */ const elements_slide = (function (Splide, index, realIndex, slide) {\n  /**\r\n   * Whether to update \"is-active\" class before or after transition.\r\n   *\r\n   * @type {boolean}\r\n   */\n  var updateOnMove = Splide.options.updateOnMove;\n  /**\r\n   * Events when the slide status is updated.\r\n   * Append a namespace to remove listeners later.\r\n   *\r\n   * @type {string}\r\n   */\n\n  var STATUS_UPDATE_EVENTS = 'ready.slide updated.slide resized.slide moved.slide' + (updateOnMove ? ' move.slide' : '');\n  /**\r\n   * Slide sub component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Slide = {\n    /**\r\n     * Slide element.\r\n     *\r\n     * @type {Element}\r\n     */\n    slide: slide,\n\n    /**\r\n     * Slide index.\r\n     *\r\n     * @type {number}\r\n     */\n    index: index,\n\n    /**\r\n     * Real index for clones.\r\n     *\r\n     * @type {number}\r\n     */\n    realIndex: realIndex,\n\n    /**\r\n     * Container element if available.\r\n     *\r\n     * @type {Element|undefined}\r\n     */\n    container: child(slide, Splide.classes.container),\n\n    /**\r\n     * Whether this is a cloned slide or not.\r\n     *\r\n     * @type {boolean}\r\n     */\n    isClone: realIndex > -1,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      if (!this.isClone) {\n        slide.id = Splide.root.id + \"-slide\" + pad(index + 1);\n      }\n\n      Splide.on(STATUS_UPDATE_EVENTS, function () {\n        return _this.update();\n      }).on(STYLE_RESTORE_EVENTS, restoreStyles).on('click', function () {\n        return Splide.emit('click', _this);\n      }, slide);\n      /*\r\n       * Add \"is-active\" class to a clone element temporarily\r\n       * and it will be removed on \"moved\" event.\r\n       */\n\n      if (updateOnMove) {\n        Splide.on('move.slide', function (newIndex) {\n          if (newIndex === realIndex) {\n            _update(true, false);\n          }\n        });\n      } // Make sure the slide is shown.\n\n\n      applyStyle(slide, {\n        display: ''\n      }); // Hold the original styles.\n\n      this.styles = getAttribute(slide, 'style') || '';\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      Splide.off(STATUS_UPDATE_EVENTS).off(STYLE_RESTORE_EVENTS).off('click', slide);\n      removeClass(slide, values(STATUS_CLASSES));\n      restoreStyles();\n      removeAttribute(this.container, 'style');\n    },\n\n    /**\r\n     * Update active and visible status.\r\n     */\n    update: function update() {\n      _update(this.isActive(), false);\n\n      _update(this.isVisible(), true);\n    },\n\n    /**\r\n     * Check whether this slide is active or not.\r\n     *\r\n     * @return {boolean} - True if the slide is active or false if not.\r\n     */\n    isActive: function isActive() {\n      return Splide.index === index;\n    },\n\n    /**\r\n     * Check whether this slide is visible in the viewport or not.\r\n     *\r\n     * @return {boolean} - True if the slide is visible or false if not.\r\n     */\n    isVisible: function isVisible() {\n      var active = this.isActive();\n\n      if (Splide.is(FADE) || active) {\n        return active;\n      }\n\n      var ceil = Math.ceil;\n      var trackRect = getRect(Splide.Components.Elements.track);\n      var slideRect = getRect(slide);\n\n      if (Splide.options.direction === TTB) {\n        return trackRect.top <= slideRect.top && slideRect.bottom <= ceil(trackRect.bottom);\n      }\n\n      return trackRect.left <= slideRect.left && slideRect.right <= ceil(trackRect.right);\n    },\n\n    /**\r\n     * Calculate how far this slide is from another slide and\r\n     * return true if the distance is within the given number.\r\n     *\r\n     * @param {number} from   - Index of a target slide.\r\n     * @param {number} within - True if the slide is within this number.\r\n     *\r\n     * @return {boolean} - True if the slide is within the number or false otherwise.\r\n     */\n    isWithin: function isWithin(from, within) {\n      var diff = Math.abs(from - index);\n\n      if (!Splide.is(SLIDE) && !this.isClone) {\n        diff = Math.min(diff, Splide.length - diff);\n      }\n\n      return diff < within;\n    }\n  };\n  /**\r\n   * Update classes for activity or visibility.\r\n   *\r\n   * @param {boolean} active        - Is active/visible or not.\r\n   * @param {boolean} forVisibility - Toggle classes for activity or visibility.\r\n   */\n\n  function _update(active, forVisibility) {\n    var type = forVisibility ? 'visible' : 'active';\n    var className = STATUS_CLASSES[type];\n\n    if (active) {\n      addClass(slide, className);\n      Splide.emit(\"\" + type, Slide);\n    } else {\n      if (hasClass(slide, className)) {\n        removeClass(slide, className);\n        Splide.emit(\"\" + (forVisibility ? 'hidden' : 'inactive'), Slide);\n      }\n    }\n  }\n  /**\r\n   * Restore the original styles.\r\n   */\n\n\n  function restoreStyles() {\n    setAttribute(slide, 'style', Slide.styles);\n  }\n\n  return Slide;\n});\n;// CONCATENATED MODULE: ./src/js/components/elements/index.js\n/**\r\n * The component for main elements.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n/**\r\n * The property name for UID stored in a window object.\r\n *\r\n * @type {string}\r\n */\n\nvar UID_NAME = 'uid';\n/**\r\n * The component for main elements.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const components_elements = (function (Splide, Components) {\n  /**\r\n   * Hold the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n  var root = Splide.root;\n  /**\r\n   * Hold the class list.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var classes = Splide.classes;\n  /**\r\n   * Store Slide objects.\r\n   *\r\n   * @type {Array}\r\n   */\n\n  var Slides = [];\n  /*\r\n   * Assign unique ID to the root element if it doesn't have the one.\r\n   * Note that IE doesn't support padStart() to fill the uid by 0.\r\n   */\n\n  if (!root.id) {\n    window.splide = window.splide || {};\n    var uid = window.splide[UID_NAME] || 0;\n    window.splide[UID_NAME] = ++uid;\n    root.id = \"splide\" + pad(uid);\n  }\n  /**\r\n   * Elements component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n\n  var Elements = {\n    /**\r\n     * Called when the component is mounted.\r\n     * Collect main elements and store them as member properties.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      this.init();\n      Splide.on('refresh', function () {\n        _this.destroy();\n\n        _this.init();\n      }).on('updated', function () {\n        removeClass(root, getClasses());\n        addClass(root, getClasses());\n      });\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      Slides.forEach(function (Slide) {\n        Slide.destroy();\n      });\n      Slides = [];\n      removeClass(root, getClasses());\n    },\n\n    /**\r\n     * Initialization.\r\n     */\n    init: function init() {\n      var _this2 = this;\n\n      collect();\n      addClass(root, getClasses());\n      this.slides.forEach(function (slide, index) {\n        _this2.register(slide, index, -1);\n      });\n    },\n\n    /**\r\n     * Register a slide to create a Slide object and handle its behavior.\r\n     *\r\n     * @param {Element} slide     - A slide element.\r\n     * @param {number}  index     - A unique index. This can be negative.\r\n     * @param {number}  realIndex - A real index for clones. Set -1 for real slides.\r\n     */\n    register: function register(slide, index, realIndex) {\n      var SlideObject = elements_slide(Splide, index, realIndex, slide);\n      SlideObject.mount();\n      Slides.push(SlideObject);\n    },\n\n    /**\r\n     * Return the Slide object designated by the index.\r\n     * Note that \"find\" is not supported by IE.\r\n     *\r\n     * @return {Object|undefined} - A Slide object if available. Undefined if not.\r\n     */\n    getSlide: function getSlide(index) {\n      return Slides.filter(function (Slide) {\n        return Slide.index === index;\n      })[0];\n    },\n\n    /**\r\n     * Return all Slide objects.\r\n     *\r\n     * @param {boolean} includeClones - Whether to include cloned slides or not.\r\n     *\r\n     * @return {Object[]} - Slide objects.\r\n     */\n    getSlides: function getSlides(includeClones) {\n      return includeClones ? Slides : Slides.filter(function (Slide) {\n        return !Slide.isClone;\n      });\n    },\n\n    /**\r\n     * Return Slide objects belonging to the given page.\r\n     *\r\n     * @param {number} page - A page number.\r\n     *\r\n     * @return {Object[]} - An array containing Slide objects.\r\n     */\n    getSlidesByPage: function getSlidesByPage(page) {\n      var idx = Components.Controller.toIndex(page);\n      var options = Splide.options;\n      var max = options.focus !== false ? 1 : options.perPage;\n      return Slides.filter(function (_ref) {\n        var index = _ref.index;\n        return idx <= index && index < idx + max;\n      });\n    },\n\n    /**\r\n     * Insert a slide to a slider.\r\n     * Need to refresh Splide after adding a slide.\r\n     *\r\n     * @param {Node|string} slide    - A slide element to be added.\r\n     * @param {number}      index    - A slide will be added at the position.\r\n     * @param {Function}    callback - Called right after the slide is added to the DOM tree.\r\n     */\n    add: function add(slide, index, callback) {\n      if (typeof slide === 'string') {\n        slide = domify(slide);\n      }\n\n      if (slide instanceof Element) {\n        var ref = this.slides[index]; // This will be removed in mount() of a Slide component.\n\n        applyStyle(slide, {\n          display: 'none'\n        });\n\n        if (ref) {\n          before(slide, ref);\n          this.slides.splice(index, 0, slide);\n        } else {\n          append(this.list, slide);\n          this.slides.push(slide);\n        }\n\n        loaded(slide, function () {\n          callback && callback(slide);\n        });\n      }\n    },\n\n    /**\r\n     * Remove a slide from a slider.\r\n     * Need to refresh Splide after removing a slide.\r\n     *\r\n     * @param index - Slide index.\r\n     */\n    remove: function remove(index) {\n      dom_remove(this.slides.splice(index, 1)[0]);\n    },\n\n    /**\r\n     * Trigger the provided callback for each Slide object.\r\n     *\r\n     * @param {Function} callback - A callback function. The first argument will be the Slide object.\r\n     */\n    each: function each(callback) {\n      Slides.forEach(callback);\n    },\n\n    /**\r\n     * Return slides length without clones.\r\n     *\r\n     * @return {number} - Slide length.\r\n     */\n    get length() {\n      return this.slides.length;\n    },\n\n    /**\r\n     * Return \"SlideObjects\" length including clones.\r\n     *\r\n     * @return {number} - Slide length including clones.\r\n     */\n    get total() {\n      return Slides.length;\n    }\n\n  };\n  /**\r\n   * Collect elements.\r\n   */\n\n  function collect() {\n    Elements.slider = child(root, classes.slider);\n    Elements.track = find(root, \".\" + classes.track);\n    Elements.list = child(Elements.track, classes.list);\n    exist(Elements.track && Elements.list, 'Track or list was not found.');\n    Elements.slides = children(Elements.list, classes.slide);\n    var arrows = findParts(classes.arrows);\n    Elements.arrows = {\n      prev: find(arrows, \".\" + classes.prev),\n      next: find(arrows, \".\" + classes.next)\n    };\n    var autoplay = findParts(classes.autoplay);\n    Elements.bar = find(findParts(classes.progress), \".\" + classes.bar);\n    Elements.play = find(autoplay, \".\" + classes.play);\n    Elements.pause = find(autoplay, \".\" + classes.pause);\n    Elements.track.id = Elements.track.id || root.id + \"-track\";\n    Elements.list.id = Elements.list.id || root.id + \"-list\";\n  }\n  /**\r\n   * Return class names for the root element.\r\n   */\n\n\n  function getClasses() {\n    var rootClass = classes.root;\n    var options = Splide.options;\n    return [rootClass + \"--\" + options.type, rootClass + \"--\" + options.direction, options.drag ? rootClass + \"--draggable\" : '', options.isNavigation ? rootClass + \"--nav\" : '', STATUS_CLASSES.active];\n  }\n  /**\r\n   * Find parts only from children of the root or track.\r\n   *\r\n   * @return {Element} - A found element or undefined.\r\n   */\n\n\n  function findParts(className) {\n    return child(root, className) || child(Elements.slider, className);\n  }\n\n  return Elements;\n});\n;// CONCATENATED MODULE: ./src/js/components/controller/index.js\n/**\r\n * The component for controlling the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\nvar floor = Math.floor;\n/**\r\n * The component for controlling the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const controller = (function (Splide, Components) {\n  /**\r\n   * Store current options.\r\n   *\r\n   * @type {Object}\r\n   */\n  var options;\n  /**\r\n   * True if the slide is LOOP mode.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isLoop;\n  /**\r\n   * Controller component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Controller = {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      options = Splide.options;\n      isLoop = Splide.is(LOOP);\n      bind();\n    },\n\n    /**\r\n     * Make track run by the given control.\r\n     * - \"+{i}\" : Increment the slide index by i.\r\n     * - \"-{i}\" : Decrement the slide index by i.\r\n     * - \"{i}\"  : Go to the slide whose index is i.\r\n     * - \">\"    : Go to next page.\r\n     * - \"<\"    : Go to prev page.\r\n     * - \">{i}\" : Go to page i.\r\n     *\r\n     * @param {string|number} control  - A control pattern.\r\n     * @param {boolean}       silently - Go to the destination without event emission.\r\n     */\n    go: function go(control, silently) {\n      var destIndex = this.trim(this.parse(control));\n      Components.Track.go(destIndex, this.rewind(destIndex), silently);\n    },\n\n    /**\r\n     * Parse the given control and return the destination index for the track.\r\n     *\r\n     * @param {string} control - A control target pattern.\r\n     *\r\n     * @return {number} - A parsed target.\r\n     */\n    parse: function parse(control) {\n      var index = Splide.index;\n      var matches = String(control).match(/([+\\-<>]+)(\\d+)?/);\n      var indicator = matches ? matches[1] : '';\n      var number = matches ? parseInt(matches[2]) : 0;\n\n      switch (indicator) {\n        case '+':\n          index += number || 1;\n          break;\n\n        case '-':\n          index -= number || 1;\n          break;\n\n        case '>':\n        case '<':\n          index = parsePage(number, index, indicator === '<');\n          break;\n\n        default:\n          index = parseInt(control);\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Compute index from the given page number.\r\n     *\r\n     * @param {number} page - Page number.\r\n     *\r\n     * @return {number} - A computed page number.\r\n     */\n    toIndex: function toIndex(page) {\n      if (hasFocus()) {\n        return page;\n      }\n\n      var length = Splide.length;\n      var perPage = options.perPage;\n      var index = page * perPage;\n      index = index - (this.pageLength * perPage - length) * floor(index / length); // Adjustment for the last page.\n\n      if (length - perPage <= index && index < length) {\n        index = length - perPage;\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Compute page number from the given slide index.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - A computed page number.\r\n     */\n    toPage: function toPage(index) {\n      if (hasFocus()) {\n        return index;\n      }\n\n      var length = Splide.length;\n      var perPage = options.perPage; // Make the last \"perPage\" number of slides belong to the last page.\n\n      if (length - perPage <= index && index < length) {\n        return floor((length - 1) / perPage);\n      }\n\n      return floor(index / perPage);\n    },\n\n    /**\r\n     * Trim the given index according to the current mode.\r\n     * Index being returned could be less than 0 or greater than the length in Loop mode.\r\n     *\r\n     * @param {number} index - An index being trimmed.\r\n     *\r\n     * @return {number} - A trimmed index.\r\n     */\n    trim: function trim(index) {\n      if (!isLoop) {\n        index = options.rewind ? this.rewind(index) : between(index, 0, this.edgeIndex);\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Rewind the given index if it's out of range.\r\n     *\r\n     * @param {number} index - An index.\r\n     *\r\n     * @return {number} - A rewound index.\r\n     */\n    rewind: function rewind(index) {\n      var edge = this.edgeIndex;\n\n      if (isLoop) {\n        while (index > edge) {\n          index -= edge + 1;\n        }\n\n        while (index < 0) {\n          index += edge + 1;\n        }\n      } else {\n        if (index > edge) {\n          index = 0;\n        } else if (index < 0) {\n          index = edge;\n        }\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Check if the direction is \"rtl\" or not.\r\n     *\r\n     * @return {boolean} - True if \"rtl\" or false if not.\r\n     */\n    isRtl: function isRtl() {\n      return options.direction === RTL;\n    },\n\n    /**\r\n     * Return the page length.\r\n     *\r\n     * @return {number} - Max page number.\r\n     */\n    get pageLength() {\n      var length = Splide.length;\n      return hasFocus() ? length : Math.ceil(length / options.perPage);\n    },\n\n    /**\r\n     * Return the edge index.\r\n     *\r\n     * @return {number} - Edge index.\r\n     */\n    get edgeIndex() {\n      var length = Splide.length;\n\n      if (!length) {\n        return 0;\n      }\n\n      if (hasFocus() || options.isNavigation || isLoop) {\n        return length - 1;\n      }\n\n      return length - options.perPage;\n    },\n\n    /**\r\n     * Return the index of the previous slide.\r\n     *\r\n     * @return {number} - The index of the previous slide if available. -1 otherwise.\r\n     */\n    get prevIndex() {\n      var prev = Splide.index - 1;\n\n      if (isLoop || options.rewind) {\n        prev = this.rewind(prev);\n      }\n\n      return prev > -1 ? prev : -1;\n    },\n\n    /**\r\n     * Return the index of the next slide.\r\n     *\r\n     * @return {number} - The index of the next slide if available. -1 otherwise.\r\n     */\n    get nextIndex() {\n      var next = Splide.index + 1;\n\n      if (isLoop || options.rewind) {\n        next = this.rewind(next);\n      }\n\n      return Splide.index < next && next <= this.edgeIndex || next === 0 ? next : -1;\n    }\n\n  };\n  /**\r\n   * Listen to some events.\r\n   */\n\n  function bind() {\n    Splide.on('move', function (newIndex) {\n      Splide.index = newIndex;\n    }).on('updated refresh', function (newOptions) {\n      options = newOptions || options;\n      Splide.index = between(Splide.index, 0, Controller.edgeIndex);\n    });\n  }\n  /**\r\n   * Verify if the focus option is available or not.\r\n   *\r\n   * @return {boolean} - True if a slider has the focus option.\r\n   */\n\n\n  function hasFocus() {\n    return options.focus !== false;\n  }\n  /**\r\n   * Return the next or previous page index computed by the page number and current index.\r\n   *\r\n   * @param {number}  number - Specify the page number.\r\n   * @param {number}  index  - Current index.\r\n   * @param {boolean} prev   - Prev or next.\r\n   *\r\n   * @return {number} - Slide index.\r\n   */\n\n\n  function parsePage(number, index, prev) {\n    if (number > -1) {\n      return Controller.toIndex(number);\n    }\n\n    var perMove = options.perMove;\n    var sign = prev ? -1 : 1;\n\n    if (perMove) {\n      return index + perMove * sign;\n    }\n\n    return Controller.toIndex(Controller.toPage(index) + sign);\n  }\n\n  return Controller;\n});\n;// CONCATENATED MODULE: ./src/js/components/track/index.js\n/**\r\n * The component for moving list in the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\nvar abs = Math.abs;\n/**\r\n * The component for moving list in the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const track = (function (Splide, Components) {\n  /**\r\n   * Hold the Layout component.\r\n   *\r\n   * @type {Object}\r\n   */\n  var Layout;\n  /**\r\n   * Hold the Layout component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements;\n  /**\r\n   * Store the list element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var list;\n  /**\r\n   * Whether the current direction is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isVertical = Splide.options.direction === TTB;\n  /**\r\n   * Whether the slider type is FADE or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isFade = Splide.is(FADE);\n  /**\r\n   * Whether the slider direction is RTL or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isRTL = Splide.options.direction === RTL;\n  /**\r\n   * This will be true while transitioning from the last index to the first one.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isLoopPending = false;\n  /**\r\n   * Sign for the direction. Only RTL mode uses the positive sign.\r\n   *\r\n   * @type {number}\r\n   */\n\n  var sign = isRTL ? 1 : -1;\n  /**\r\n   * Track component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Track = {\n    /**\r\n     * Make public the sign defined locally.\r\n     *\r\n     * @type {number}\r\n     */\n    sign: sign,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Elements = Components.Elements;\n      Layout = Components.Layout;\n      list = Elements.list;\n    },\n\n    /**\r\n     * Called after the component is mounted.\r\n     * The resize event must be registered after the Layout's one is done.\r\n     */\n    mounted: function mounted() {\n      var _this = this;\n\n      if (!isFade) {\n        this.jump(0);\n        Splide.on('mounted resize updated', function () {\n          _this.jump(Splide.index);\n        });\n      }\n    },\n\n    /**\r\n     * Go to the given destination index.\r\n     * After arriving there, the track is jump to the new index without animation, mainly for loop mode.\r\n     *\r\n     * @param {number}  destIndex - A destination index.\r\n     *                              This can be negative or greater than slides length for reaching clones.\r\n     * @param {number}  newIndex  - An actual new index. They are always same in Slide and Rewind mode.\r\n     * @param {boolean} silently  - If true, suppress emitting events.\r\n     */\n    go: function go(destIndex, newIndex, silently) {\n      var newPosition = getTrimmedPosition(destIndex);\n      var prevIndex = Splide.index; // Prevent any actions while transitioning from the last index to the first one for jump.\n\n      if (Splide.State.is(MOVING) && isLoopPending) {\n        return;\n      }\n\n      isLoopPending = destIndex !== newIndex;\n\n      if (!silently) {\n        Splide.emit('move', newIndex, prevIndex, destIndex);\n      }\n\n      if (Math.abs(newPosition - this.position) >= 1 || isFade) {\n        Components.Transition.start(destIndex, newIndex, prevIndex, this.toCoord(newPosition), function () {\n          onTransitionEnd(destIndex, newIndex, prevIndex, silently);\n        });\n      } else {\n        if (destIndex !== prevIndex && Splide.options.trimSpace === 'move') {\n          Components.Controller.go(destIndex + destIndex - prevIndex, silently);\n        } else {\n          onTransitionEnd(destIndex, newIndex, prevIndex, silently);\n        }\n      }\n    },\n\n    /**\r\n     * Move the track to the specified index.\r\n     *\r\n     * @param {number} index - A destination index where the track jumps.\r\n     */\n    jump: function jump(index) {\n      this.translate(getTrimmedPosition(index));\n    },\n\n    /**\r\n     * Set the list position by CSS translate property.\r\n     *\r\n     * @param {number} position - A new position value.\r\n     */\n    translate: function translate(position) {\n      applyStyle(list, {\n        transform: \"translate\" + (isVertical ? 'Y' : 'X') + \"(\" + position + \"px)\"\n      });\n    },\n\n    /**\r\n     * Cancel the transition and set the list position.\r\n     * Also, loop the slider if necessary.\r\n     */\n    cancel: function cancel() {\n      if (Splide.is(LOOP)) {\n        this.shift();\n      } else {\n        // Ensure the current position.\n        this.translate(this.position);\n      }\n\n      applyStyle(list, {\n        transition: ''\n      });\n    },\n\n    /**\r\n     * Shift the slider if it exceeds borders on the edge.\r\n     */\n    shift: function shift() {\n      var position = abs(this.position);\n      var left = abs(this.toPosition(0));\n      var right = abs(this.toPosition(Splide.length));\n      var innerSize = right - left;\n\n      if (position < left) {\n        position += innerSize;\n      } else if (position > right) {\n        position -= innerSize;\n      }\n\n      this.translate(sign * position);\n    },\n\n    /**\r\n     * Trim redundant spaces on the left or right edge if necessary.\r\n     *\r\n     * @param {number} position - Position value to be trimmed.\r\n     *\r\n     * @return {number} - Trimmed position.\r\n     */\n    trim: function trim(position) {\n      if (!Splide.options.trimSpace || Splide.is(LOOP)) {\n        return position;\n      }\n\n      var edge = sign * (Layout.totalSize() - Layout.size - Layout.gap);\n      return between(position, edge, 0);\n    },\n\n    /**\r\n     * Calculate the closest slide index from the given position.\r\n     *\r\n     * @param {number} position - A position converted to an slide index.\r\n     *\r\n     * @return {number} - The closest slide index.\r\n     */\n    toIndex: function toIndex(position) {\n      var _this2 = this;\n\n      var index = 0;\n      var minDistance = Infinity;\n      Elements.getSlides(true).forEach(function (Slide) {\n        var slideIndex = Slide.index;\n        var distance = abs(_this2.toPosition(slideIndex) - position);\n\n        if (distance < minDistance) {\n          minDistance = distance;\n          index = slideIndex;\n        }\n      });\n      return index;\n    },\n\n    /**\r\n     * Return coordinates object by the given position.\r\n     *\r\n     * @param {number} position - A position value.\r\n     *\r\n     * @return {Object} - A coordinates object.\r\n     */\n    toCoord: function toCoord(position) {\n      return {\n        x: isVertical ? 0 : position,\n        y: isVertical ? position : 0\n      };\n    },\n\n    /**\r\n     * Calculate the track position by a slide index.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {Object} - Calculated position.\r\n     */\n    toPosition: function toPosition(index) {\n      var position = Layout.totalSize(index) - Layout.slideSize(index) - Layout.gap;\n      return sign * (position + this.offset(index));\n    },\n\n    /**\r\n     * Return the current offset value, considering direction.\r\n     *\r\n     * @return {number} - Offset amount.\r\n     */\n    offset: function offset(index) {\n      var focus = Splide.options.focus;\n      var slideSize = Layout.slideSize(index);\n\n      if (focus === 'center') {\n        return -(Layout.size - slideSize) / 2;\n      }\n\n      return -(parseInt(focus) || 0) * (slideSize + Layout.gap);\n    },\n\n    /**\r\n     * Return the current position.\r\n     * This returns the correct position even while transitioning by CSS.\r\n     *\r\n     * @return {number} - Current position.\r\n     */\n    get position() {\n      var prop = isVertical ? 'top' : isRTL ? 'right' : 'left';\n      return getRect(list)[prop] - (getRect(Elements.track)[prop] - Layout.padding[prop] * sign);\n    }\n\n  };\n  /**\r\n   * Called whenever slides arrive at a destination.\r\n   *\r\n   * @param {number}  destIndex - A destination index.\r\n   * @param {number}  newIndex  - A new index.\r\n   * @param {number}  prevIndex - A previous index.\r\n   * @param {boolean} silently  - If true, suppress emitting events.\r\n   */\n\n  function onTransitionEnd(destIndex, newIndex, prevIndex, silently) {\n    applyStyle(list, {\n      transition: ''\n    });\n    isLoopPending = false;\n\n    if (!isFade) {\n      Track.jump(newIndex);\n    }\n\n    if (!silently) {\n      Splide.emit('moved', newIndex, prevIndex, destIndex);\n    }\n  }\n  /**\r\n   * Convert index to the trimmed position.\r\n   *\r\n   * @return {number} - Trimmed position.\r\n   */\n\n\n  function getTrimmedPosition(index) {\n    return Track.trim(Track.toPosition(index));\n  }\n\n  return Track;\n});\n;// CONCATENATED MODULE: ./src/js/components/clones/index.js\n/**\r\n * The component for cloning some slides for \"loop\" mode of the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n/**\r\n * The component for cloning some slides for \"loop\" mode of the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const clones = (function (Splide, Components) {\n  /**\r\n   * Store information of all clones.\r\n   *\r\n   * @type {Array}\r\n   */\n  var clones = [];\n  /**\r\n   * Store the current clone count on one side.\r\n   *\r\n   * @type {number}\r\n   */\n\n  var cloneCount = 0;\n  /**\r\n   * Keep Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Clones component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Clones = {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      if (Splide.is(LOOP)) {\n        init();\n        Splide.on('refresh:before', function () {\n          _this.destroy();\n        }).on('refresh', init).on('resize', function () {\n          if (cloneCount !== getCloneCount()) {\n            // Destroy before refresh not to collect clones by the Elements component.\n            _this.destroy();\n\n            Splide.refresh();\n          }\n        });\n      }\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      dom_remove(clones);\n      clones = [];\n    },\n\n    /**\r\n     * Return all clones.\r\n     *\r\n     * @return {Element[]} - Cloned elements.\r\n     */\n    get clones() {\n      return clones;\n    },\n\n    /**\r\n     * Return clone length.\r\n     *\r\n     * @return {number} - A length of clones.\r\n     */\n    get length() {\n      return clones.length;\n    }\n\n  };\n  /**\r\n   * Initialization.\r\n   */\n\n  function init() {\n    Clones.destroy();\n    cloneCount = getCloneCount();\n    generateClones(cloneCount);\n  }\n  /**\r\n   * Generate and append/prepend clones.\r\n   *\r\n   * @param {number} count - The half number of clones.\r\n   */\n\n\n  function generateClones(count) {\n    var length = Elements.length,\n        register = Elements.register;\n\n    if (length) {\n      var slides = Elements.slides;\n\n      while (slides.length < count) {\n        slides = slides.concat(slides);\n      } // Clones after the last element.\n\n\n      slides.slice(0, count).forEach(function (elm, index) {\n        var clone = cloneDeeply(elm);\n        append(Elements.list, clone);\n        clones.push(clone);\n        register(clone, index + length, index % length);\n      }); // Clones before the first element.\n\n      slides.slice(-count).forEach(function (elm, index) {\n        var clone = cloneDeeply(elm);\n        before(clone, slides[0]);\n        clones.push(clone);\n        register(clone, index - count, (length + index - count % length) % length);\n      });\n    }\n  }\n  /**\r\n   * Return half count of clones to be generated.\r\n   * Clone count is determined by:\r\n   * - \"clones\" value in the options.\r\n   * - Number of slides that can be placed in a view in \"fixed\" mode.\r\n   * - Max pages a flick action can move.\r\n   * - Whether the slide length is enough for perPage.\r\n   *\r\n   * @return {number} - Count for clones.\r\n   */\n\n\n  function getCloneCount() {\n    var options = Splide.options;\n\n    if (options.clones) {\n      return options.clones;\n    } // Use the slide length in autoWidth mode because the number cannot be calculated.\n\n\n    var baseCount = options.autoWidth || options.autoHeight ? Elements.length : options.perPage;\n    var dimension = options.direction === TTB ? 'Height' : 'Width';\n    var fixedSize = toPixel(Splide.root, options[\"fixed\" + dimension]);\n\n    if (fixedSize) {\n      // Roughly calculate the count. This needs not to be strict.\n      baseCount = Math.ceil(Elements.track[\"client\" + dimension] / fixedSize);\n    }\n\n    return baseCount * (options.drag ? options.flickMaxPages + 1 : 1);\n  }\n  /**\r\n   * Clone deeply the given element.\r\n   *\r\n   * @param {Element} elm - An element being duplicated.\r\n   *\r\n   * @return {Node} - A cloned node(element).\r\n   */\n\n\n  function cloneDeeply(elm) {\n    var clone = elm.cloneNode(true);\n    addClass(clone, Splide.classes.clone); // ID should not be duplicated.\n\n    removeAttribute(clone, 'id');\n    return clone;\n  }\n\n  return Clones;\n});\n;// CONCATENATED MODULE: ./src/js/components/layout/directions/horizontal.js\n/**\r\n * The resolver component for horizontal layout.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The resolver component for horizontal layout.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The resolver object.\r\n */\n\n/* harmony default export */ const horizontal = (function (Splide, Components) {\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n  var Elements = Components.Elements;\n  /**\r\n   * Keep the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var root = Splide.root;\n  /**\r\n   * Keep the track element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var track;\n  /**\r\n   * Keep the latest options.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var options = Splide.options;\n  return {\n    /**\r\n     * Margin property name.\r\n     *\r\n     * @type {string}\r\n     */\n    margin: 'margin' + (options.direction === RTL ? 'Left' : 'Right'),\n\n    /**\r\n     * Always 0 because the height will be determined by inner contents.\r\n     *\r\n     * @type {number}\r\n     */\n    height: 0,\n\n    /**\r\n     * Initialization.\r\n     */\n    init: function init() {\n      this.resize();\n    },\n\n    /**\r\n     * Resize gap and padding.\r\n     * This must be called on init.\r\n     */\n    resize: function resize() {\n      options = Splide.options;\n      track = Elements.track;\n      this.gap = toPixel(root, options.gap);\n      var padding = options.padding;\n      var left = toPixel(root, padding.left || padding);\n      var right = toPixel(root, padding.right || padding);\n      this.padding = {\n        left: left,\n        right: right\n      };\n      applyStyle(track, {\n        paddingLeft: unit(left),\n        paddingRight: unit(right)\n      });\n    },\n\n    /**\r\n     * Return total width from the left of the list to the right of the slide specified by the provided index.\r\n     *\r\n     * @param {number} index - Optional. A slide index. If undefined, total width of the slider will be returned.\r\n     *\r\n     * @return {number} - Total width to the right side of the specified slide, or 0 for an invalid index.\r\n     */\n    totalWidth: function totalWidth(index) {\n      if (index === void 0) {\n        index = Splide.length - 1;\n      }\n\n      var Slide = Elements.getSlide(index);\n      var width = 0;\n\n      if (Slide) {\n        var slideRect = getRect(Slide.slide);\n        var listRect = getRect(Elements.list);\n\n        if (options.direction === RTL) {\n          width = listRect.right - slideRect.left;\n        } else {\n          width = slideRect.right - listRect.left;\n        }\n\n        width += this.gap;\n      }\n\n      return width;\n    },\n\n    /**\r\n     * Return the slide width in px.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - The slide width.\r\n     */\n    slideWidth: function slideWidth(index) {\n      if (options.autoWidth) {\n        var Slide = Elements.getSlide(index);\n        return Slide ? Slide.slide.offsetWidth : 0;\n      }\n\n      var width = options.fixedWidth || (this.width + this.gap) / options.perPage - this.gap;\n      return toPixel(root, width);\n    },\n\n    /**\r\n     * Return the slide height in px.\r\n     *\r\n     * @return {number} - The slide height.\r\n     */\n    slideHeight: function slideHeight() {\n      var height = options.height || options.fixedHeight || this.width * options.heightRatio;\n      return toPixel(root, height);\n    },\n\n    /**\r\n     * Return slider width without padding.\r\n     *\r\n     * @return {number} - Current slider width.\r\n     */\n    get width() {\n      return track.clientWidth - this.padding.left - this.padding.right;\n    }\n\n  };\n});\n;// CONCATENATED MODULE: ./src/js/components/layout/directions/vertical.js\n/**\r\n * The resolver component for vertical layout.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The resolver component for vertical layout.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The resolver object.\r\n */\n\n/* harmony default export */ const vertical = (function (Splide, Components) {\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n  var Elements = Components.Elements;\n  /**\r\n   * Keep the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var root = Splide.root;\n  /**\r\n   * Keep the track element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var track;\n  /**\r\n   * Keep the latest options.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var options;\n  return {\n    /**\r\n     * Margin property name.\r\n     *\r\n     * @type {string}\r\n     */\n    margin: 'marginBottom',\n\n    /**\r\n     * Initialization.\r\n     */\n    init: function init() {\n      this.resize();\n    },\n\n    /**\r\n     * Resize gap and padding.\r\n     * This must be called on init.\r\n     */\n    resize: function resize() {\n      options = Splide.options;\n      track = Elements.track;\n      this.gap = toPixel(root, options.gap);\n      var padding = options.padding;\n      var top = toPixel(root, padding.top || padding);\n      var bottom = toPixel(root, padding.bottom || padding);\n      this.padding = {\n        top: top,\n        bottom: bottom\n      };\n      applyStyle(track, {\n        paddingTop: unit(top),\n        paddingBottom: unit(bottom)\n      });\n    },\n\n    /**\r\n     * Return total height from the top of the list to the bottom of the slide specified by the provided index.\r\n     *\r\n     * @param {number} index - Optional. A slide index. If undefined, total height of the slider will be returned.\r\n     *\r\n     * @return {number} - Total height to the bottom of the specified slide, or 0 for an invalid index.\r\n     */\n    totalHeight: function totalHeight(index) {\n      if (index === void 0) {\n        index = Splide.length - 1;\n      }\n\n      var Slide = Elements.getSlide(index);\n\n      if (Slide) {\n        return getRect(Slide.slide).bottom - getRect(Elements.list).top + this.gap;\n      }\n\n      return 0;\n    },\n\n    /**\r\n     * Return the slide width in px.\r\n     *\r\n     * @return {number} - The slide width.\r\n     */\n    slideWidth: function slideWidth() {\n      return toPixel(root, options.fixedWidth || this.width);\n    },\n\n    /**\r\n     * Return the slide height in px.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - The slide height.\r\n     */\n    slideHeight: function slideHeight(index) {\n      if (options.autoHeight) {\n        var Slide = Elements.getSlide(index);\n        return Slide ? Slide.slide.offsetHeight : 0;\n      }\n\n      var height = options.fixedHeight || (this.height + this.gap) / options.perPage - this.gap;\n      return toPixel(root, height);\n    },\n\n    /**\r\n     * Return slider width without padding.\r\n     *\r\n     * @return {number} - Current slider width.\r\n     */\n    get width() {\n      return track.clientWidth;\n    },\n\n    /**\r\n     * Return slide height without padding.\r\n     *\r\n     * @return {number} - Slider height.\r\n     */\n    get height() {\n      var height = options.height || this.width * options.heightRatio;\n      exist(height, '\"height\" or \"heightRatio\" is missing.');\n      return toPixel(root, height) - this.padding.top - this.padding.bottom;\n    }\n\n  };\n});\n;// CONCATENATED MODULE: ./src/js/utils/time.js\n/**\r\n * A package of utility functions related with time.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Simple throttle function that controls how often the given function is executed.\r\n *\r\n * @param {function} func - A function to be throttled.\r\n * @param {number}   wait - Time in millisecond for interval of execution.\r\n *\r\n * @return {Function} - A debounced function.\r\n */\nfunction throttle(func, wait) {\n  var timeout; // Declare function by the \"function\" keyword to prevent \"this\" from being inherited.\n\n  return function () {\n    if (!timeout) {\n      timeout = setTimeout(function () {\n        func();\n        timeout = null;\n      }, wait);\n    }\n  };\n}\n/**\r\n * Custom setInterval function that provides progress rate as callback.\r\n *\r\n * @param {function} callback - A callback function fired every time the interval time passes.\r\n * @param {number}   interval - Interval duration in milliseconds.\r\n * @param {function} progress - A callback function fired whenever the progress goes.\r\n *\r\n * @return {Object} - An object containing play() and pause() functions.\r\n */\n\nfunction createInterval(callback, interval, progress) {\n  var _window = window,\n      requestAnimationFrame = _window.requestAnimationFrame;\n  var start,\n      elapse,\n      rate,\n      _pause = true;\n\n  var step = function step(timestamp) {\n    if (!_pause) {\n      if (!start) {\n        start = timestamp;\n\n        if (rate && rate < 1) {\n          start -= rate * interval;\n        }\n      }\n\n      elapse = timestamp - start;\n      rate = elapse / interval;\n\n      if (elapse >= interval) {\n        start = 0;\n        rate = 1;\n        callback();\n      }\n\n      if (progress) {\n        progress(rate);\n      }\n\n      requestAnimationFrame(step);\n    }\n  };\n\n  return {\n    pause: function pause() {\n      _pause = true;\n      start = 0;\n    },\n    play: function play(reset) {\n      start = 0;\n\n      if (reset) {\n        rate = 0;\n      }\n\n      if (_pause) {\n        _pause = false;\n        requestAnimationFrame(step);\n      }\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/js/components/layout/index.js\n/**\r\n * The component for handing slide layouts and their sizes.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n\n/**\r\n * The component for handing slide layouts and their sizes.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const layout = (function (Splide, Components) {\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n  var Elements = Components.Elements;\n  /**\r\n   * Whether the slider is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isVertical = Splide.options.direction === TTB;\n  /**\r\n   * Layout component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Layout = object_assign({\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      bind();\n      init(); // The word \"size\" means width for a horizontal slider and height for a vertical slider.\n\n      this.totalSize = isVertical ? this.totalHeight : this.totalWidth;\n      this.slideSize = isVertical ? this.slideHeight : this.slideWidth;\n    },\n\n    /**\r\n     * Destroy the component.\r\n     */\n    destroy: function destroy() {\n      removeAttribute([Elements.list, Elements.track], 'style');\n    },\n\n    /**\r\n     * Return the slider height on the vertical mode or width on the horizontal mode.\r\n     *\r\n     * @return {number}\r\n     */\n    get size() {\n      return isVertical ? this.height : this.width;\n    }\n\n  }, isVertical ? vertical(Splide, Components) : horizontal(Splide, Components));\n  /**\r\n   * Init slider styles according to options.\r\n   */\n\n  function init() {\n    Layout.init();\n    applyStyle(Splide.root, {\n      maxWidth: unit(Splide.options.width)\n    });\n    Elements.each(function (Slide) {\n      Slide.slide.style[Layout.margin] = unit(Layout.gap);\n    });\n    resize();\n  }\n  /**\r\n   * Listen the resize native event with throttle.\r\n   * Initialize when the component is mounted or options are updated.\r\n   */\n\n\n  function bind() {\n    Splide.on('resize load', throttle(function () {\n      Splide.emit('resize');\n    }, Splide.options.throttle), window).on('resize', resize).on('updated refresh', init);\n  }\n  /**\r\n   * Resize the track and slide elements.\r\n   */\n\n\n  function resize() {\n    var options = Splide.options;\n    Layout.resize();\n    applyStyle(Elements.track, {\n      height: unit(Layout.height)\n    });\n    var slideHeight = options.autoHeight ? null : unit(Layout.slideHeight());\n    Elements.each(function (Slide) {\n      applyStyle(Slide.container, {\n        height: slideHeight\n      });\n      applyStyle(Slide.slide, {\n        width: options.autoWidth ? null : unit(Layout.slideWidth(Slide.index)),\n        height: Slide.container ? null : slideHeight\n      });\n    });\n    Splide.emit('resized');\n  }\n\n  return Layout;\n});\n;// CONCATENATED MODULE: ./src/js/components/drag/index.js\n/**\r\n * The component for supporting mouse drag and swipe.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\nvar drag_abs = Math.abs;\n/**\r\n * If the absolute velocity is greater thant this value,\r\n * a slider always goes to a different slide after drag, not allowed to stay on a current slide.\r\n */\n\nvar MIN_VELOCITY = 0.1;\n/**\r\n * Adjust how much the track can be pulled on the first or last page.\r\n * The larger number this is, the farther the track moves.\r\n * This should be around 5 - 9.\r\n *\r\n * @type {number}\r\n */\n\nvar FRICTION_REDUCER = 7;\n/**\r\n * The component supporting mouse drag and swipe.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const drag = (function (Splide, Components) {\n  /**\r\n   * Store the Move component.\r\n   *\r\n   * @type {Object}\r\n   */\n  var Track = Components.Track;\n  /**\r\n   * Store the Controller component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Controller = Components.Controller;\n  /**\r\n   * Coordinate of the track on starting drag.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var startCoord;\n  /**\r\n   * Analyzed info on starting drag.\r\n   *\r\n   * @type {Object|null}\r\n   */\n\n  var startInfo;\n  /**\r\n   * Analyzed info being updated while dragging/swiping.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var currentInfo;\n  /**\r\n   * Determine whether slides are being dragged or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isDragging;\n  /**\r\n   * Whether the slider direction is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isVertical = Splide.options.direction === TTB;\n  /**\r\n   * Axis for the direction.\r\n   *\r\n   * @type {string}\r\n   */\n\n  var axis = isVertical ? 'y' : 'x';\n  /**\r\n   * Drag component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Drag = {\n    /**\r\n     * Whether dragging is disabled or not.\r\n     *\r\n     * @type {boolean}\r\n     */\n    disabled: false,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      var Elements = Components.Elements;\n      var track = Elements.track;\n      Splide.on('touchstart mousedown', start, track).on('touchmove mousemove', move, track, {\n        passive: false\n      }).on('touchend touchcancel mouseleave mouseup dragend', end, track).on('mounted refresh', function () {\n        // Prevent dragging an image or anchor itself.\n        each(Elements.list.querySelectorAll('img, a'), function (elm) {\n          Splide.off('dragstart', elm).on('dragstart', function (e) {\n            e.preventDefault();\n          }, elm, {\n            passive: false\n          });\n        });\n      }).on('mounted updated', function () {\n        _this.disabled = !Splide.options.drag;\n      });\n    }\n  };\n  /**\r\n   * Called when the track starts to be dragged.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\n\n  function start(e) {\n    if (!Drag.disabled && !isDragging) {\n      // These prams are used to evaluate whether the slider should start moving.\n      init(e);\n    }\n  }\n  /**\r\n   * Initialize parameters.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\n\n\n  function init(e) {\n    startCoord = Track.toCoord(Track.position);\n    startInfo = analyze(e, {});\n    currentInfo = startInfo;\n  }\n  /**\r\n   * Called while the track being dragged.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\n\n\n  function move(e) {\n    if (startInfo) {\n      currentInfo = analyze(e, startInfo);\n\n      if (isDragging) {\n        if (e.cancelable) {\n          e.preventDefault();\n        }\n\n        if (!Splide.is(FADE)) {\n          var position = startCoord[axis] + currentInfo.offset[axis];\n          Track.translate(resist(position));\n        }\n      } else {\n        if (shouldMove(currentInfo)) {\n          Splide.emit('drag', startInfo);\n          isDragging = true;\n          Track.cancel(); // These params are actual drag data.\n\n          init(e);\n        }\n      }\n    }\n  }\n  /**\r\n   * Determine whether to start moving the track or not by drag angle.\r\n   *\r\n   * @param {Object} info - An information object.\r\n   *\r\n   * @return {boolean} - True if the track should be moved or false if not.\r\n   */\n\n\n  function shouldMove(_ref) {\n    var offset = _ref.offset;\n\n    if (Splide.State.is(MOVING) && Splide.options.waitForTransition) {\n      return false;\n    }\n\n    var angle = Math.atan(drag_abs(offset.y) / drag_abs(offset.x)) * 180 / Math.PI;\n\n    if (isVertical) {\n      angle = 90 - angle;\n    }\n\n    return angle < Splide.options.dragAngleThreshold;\n  }\n  /**\r\n   * Resist dragging the track on the first/last page because there is no more.\r\n   *\r\n   * @param {number} position - A position being applied to the track.\r\n   *\r\n   * @return {Object} - Adjusted position.\r\n   */\n\n\n  function resist(position) {\n    if (Splide.is(SLIDE)) {\n      var sign = Track.sign;\n\n      var _start = sign * Track.trim(Track.toPosition(0));\n\n      var _end = sign * Track.trim(Track.toPosition(Controller.edgeIndex));\n\n      position *= sign;\n\n      if (position < _start) {\n        position = _start - FRICTION_REDUCER * Math.log(_start - position);\n      } else if (position > _end) {\n        position = _end + FRICTION_REDUCER * Math.log(position - _end);\n      }\n\n      position *= sign;\n    }\n\n    return position;\n  }\n  /**\r\n   * Called when dragging ends.\r\n   */\n\n\n  function end() {\n    startInfo = null;\n\n    if (isDragging) {\n      Splide.emit('dragged', currentInfo);\n      go(currentInfo);\n      isDragging = false;\n    }\n  }\n  /**\r\n   * Go to the slide determined by the analyzed data.\r\n   *\r\n   * @param {Object} info - An info object.\r\n   */\n\n\n  function go(info) {\n    var velocity = info.velocity[axis];\n    var absV = drag_abs(velocity);\n\n    if (absV > 0) {\n      var options = Splide.options;\n      var index = Splide.index;\n      var sign = velocity < 0 ? -1 : 1;\n      var destIndex = index;\n\n      if (!Splide.is(FADE)) {\n        var destination = Track.position;\n\n        if (absV > options.flickVelocityThreshold && drag_abs(info.offset[axis]) < options.swipeDistanceThreshold) {\n          destination += sign * Math.min(absV * options.flickPower, Components.Layout.size * (options.flickMaxPages || 1));\n        }\n\n        destIndex = Track.toIndex(destination);\n      }\n      /*\r\n       * Do not allow the track to go to a previous position if there is enough velocity.\r\n       * Always use the adjacent index for the fade mode.\r\n       */\n\n\n      if (destIndex === index && absV > MIN_VELOCITY) {\n        destIndex = index + sign * Track.sign;\n      }\n\n      if (Splide.is(SLIDE)) {\n        destIndex = between(destIndex, 0, Controller.edgeIndex);\n      }\n\n      Controller.go(destIndex, options.isNavigation);\n    }\n  }\n  /**\r\n   * Analyze the given event object and return important information for handling swipe behavior.\r\n   *\r\n   * @param {Event}   e          - Touch or Mouse event object.\r\n   * @param {Object}  startInfo  - Information analyzed on start for calculating difference from the current one.\r\n   *\r\n   * @return {Object} - An object containing analyzed information, such as offset, velocity, etc.\r\n   */\n\n\n  function analyze(e, startInfo) {\n    var timeStamp = e.timeStamp,\n        touches = e.touches;\n\n    var _ref2 = touches ? touches[0] : e,\n        clientX = _ref2.clientX,\n        clientY = _ref2.clientY;\n\n    var _ref3 = startInfo.to || {},\n        _ref3$x = _ref3.x,\n        fromX = _ref3$x === void 0 ? clientX : _ref3$x,\n        _ref3$y = _ref3.y,\n        fromY = _ref3$y === void 0 ? clientY : _ref3$y;\n\n    var startTime = startInfo.time || 0;\n    var offset = {\n      x: clientX - fromX,\n      y: clientY - fromY\n    };\n    var duration = timeStamp - startTime;\n    var velocity = {\n      x: offset.x / duration,\n      y: offset.y / duration\n    };\n    return {\n      to: {\n        x: clientX,\n        y: clientY\n      },\n      offset: offset,\n      time: timeStamp,\n      velocity: velocity\n    };\n  }\n\n  return Drag;\n});\n;// CONCATENATED MODULE: ./src/js/components/click/index.js\n/**\r\n * The component for handling a click event.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The component for handling a click event.\r\n * Click should be disabled during drag/swipe.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n/* harmony default export */ const click = (function (Splide, Components) {\n  /**\r\n   * Whether click is disabled or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  var disabled = false;\n  /**\r\n   * Click component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Click = {\n    /**\r\n     * Mount only when the drag is activated and the slide type is not \"fade\".\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.drag,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('click', onClick, Components.Elements.track, {\n        capture: true\n      }).on('drag', function () {\n        disabled = true;\n      }).on('dragged', function () {\n        // Make sure the flag is released after the click event is fired.\n        setTimeout(function () {\n          disabled = false;\n        });\n      });\n    }\n  };\n  /**\r\n   * Called when a track element is clicked.\r\n   *\r\n   * @param {Event} e - A click event.\r\n   */\n\n  function onClick(e) {\n    if (disabled) {\n      e.preventDefault();\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n\n  return Click;\n});\n;// CONCATENATED MODULE: ./src/js/components/autoplay/index.js\n/**\r\n * The component for playing slides automatically.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Set of pause flags.\r\n */\n\nvar PAUSE_FLAGS = {\n  HOVER: 1,\n  FOCUS: 2,\n  MANUAL: 3\n};\n/**\r\n * The component for playing slides automatically.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const autoplay = (function (Splide, Components, name) {\n  /**\r\n   * Store pause flags.\r\n   *\r\n   * @type {Array}\r\n   */\n  var flags = [];\n  /**\r\n   * Store an interval object.\r\n   *\r\n   * @type {Object};\r\n   */\n\n  var interval;\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Autoplay component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Autoplay = {\n    /**\r\n     * Required only when the autoplay option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.autoplay,\n\n    /**\r\n     * Called when the component is mounted.\r\n     * Note that autoplay starts only if there are slides over perPage number.\r\n     */\n    mount: function mount() {\n      var options = Splide.options;\n\n      if (Elements.slides.length > options.perPage) {\n        interval = createInterval(function () {\n          Splide.go('>');\n        }, options.interval, function (rate) {\n          Splide.emit(name + \":playing\", rate);\n\n          if (Elements.bar) {\n            applyStyle(Elements.bar, {\n              width: rate * 100 + \"%\"\n            });\n          }\n        });\n        bind();\n        this.play();\n      }\n    },\n\n    /**\r\n     * Start autoplay.\r\n     *\r\n     * @param {number} flag - A pause flag to be removed.\r\n     */\n    play: function play(flag) {\n      if (flag === void 0) {\n        flag = 0;\n      }\n\n      flags = flags.filter(function (f) {\n        return f !== flag;\n      });\n\n      if (!flags.length) {\n        Splide.emit(name + \":play\");\n        interval.play(Splide.options.resetProgress);\n      }\n    },\n\n    /**\r\n     * Pause autoplay.\r\n     * Note that Array.includes is not supported by IE.\r\n     *\r\n     * @param {number} flag - A pause flag to be added.\r\n     */\n    pause: function pause(flag) {\n      if (flag === void 0) {\n        flag = 0;\n      }\n\n      interval.pause();\n\n      if (flags.indexOf(flag) === -1) {\n        flags.push(flag);\n      }\n\n      if (flags.length === 1) {\n        Splide.emit(name + \":pause\");\n      }\n    }\n  };\n  /**\r\n   * Listen some events.\r\n   */\n\n  function bind() {\n    var options = Splide.options;\n    var sibling = Splide.sibling;\n    var elms = [Splide.root, sibling ? sibling.root : null];\n\n    if (options.pauseOnHover) {\n      switchOn(elms, 'mouseleave', PAUSE_FLAGS.HOVER, true);\n      switchOn(elms, 'mouseenter', PAUSE_FLAGS.HOVER, false);\n    }\n\n    if (options.pauseOnFocus) {\n      switchOn(elms, 'focusout', PAUSE_FLAGS.FOCUS, true);\n      switchOn(elms, 'focusin', PAUSE_FLAGS.FOCUS, false);\n    }\n\n    if (Elements.play) {\n      Splide.on('click', function () {\n        // Need to be removed a focus flag at first.\n        Autoplay.play(PAUSE_FLAGS.FOCUS);\n        Autoplay.play(PAUSE_FLAGS.MANUAL);\n      }, Elements.play);\n    }\n\n    if (Elements.pause) {\n      switchOn([Elements.pause], 'click', PAUSE_FLAGS.MANUAL, false);\n    }\n\n    Splide.on('move refresh', function () {\n      Autoplay.play();\n    }) // Rewind the timer.\n    .on('destroy', function () {\n      Autoplay.pause();\n    });\n  }\n  /**\r\n   * Play or pause on the given event.\r\n   *\r\n   * @param {Element[]} elms  - Elements.\r\n   * @param {string}    event - An event name or names.\r\n   * @param {number}    flag  - A pause flag defined on the top.\r\n   * @param {boolean}   play  - Determine whether to play or pause.\r\n   */\n\n\n  function switchOn(elms, event, flag, play) {\n    elms.forEach(function (elm) {\n      Splide.on(event, function () {\n        Autoplay[play ? 'play' : 'pause'](flag);\n      }, elm);\n    });\n  }\n\n  return Autoplay;\n});\n;// CONCATENATED MODULE: ./src/js/components/cover/index.js\n/**\r\n * The component for change an img element to background image of its wrapper.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The component for change an img element to background image of its wrapper.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const cover = (function (Splide, Components) {\n  /**\r\n   * Hold options.\r\n   *\r\n   * @type {Object}\r\n   */\n  var options = Splide.options;\n  /**\r\n   * Cover component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Cover = {\n    /**\r\n     * Required only when \"cover\" option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: options.cover,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('lazyload:loaded', function (img) {\n        cover(img, false);\n      });\n      Splide.on('mounted updated refresh', function () {\n        return apply(false);\n      });\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      apply(true);\n    }\n  };\n  /**\r\n   * Apply \"cover\" to all slides.\r\n   *\r\n   * @param {boolean} uncover - If true, \"cover\" will be clear.\r\n   */\n\n  function apply(uncover) {\n    Components.Elements.each(function (Slide) {\n      var img = child(Slide.slide, 'IMG') || child(Slide.container, 'IMG');\n\n      if (img && img.src) {\n        cover(img, uncover);\n      }\n    });\n  }\n  /**\r\n   * Set background image of the parent element, using source of the given image element.\r\n   *\r\n   * @param {Element} img     - An image element.\r\n   * @param {boolean} uncover - Reset \"cover\".\r\n   */\n\n\n  function cover(img, uncover) {\n    applyStyle(img.parentElement, {\n      background: uncover ? '' : \"center/cover no-repeat url(\\\"\" + img.src + \"\\\")\"\n    });\n    applyStyle(img, {\n      display: uncover ? '' : 'none'\n    });\n  }\n\n  return Cover;\n});\n;// CONCATENATED MODULE: ./src/js/components/arrows/path.js\n/**\r\n * Export vector path for an arrow.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Namespace definition for SVG element.\r\n *\r\n * @type {string}\r\n */\nvar XML_NAME_SPACE = 'http://www.w3.org/2000/svg';\n/**\r\n * The arrow vector path.\r\n *\r\n * @type {number}\r\n */\n\nvar PATH = 'm15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z';\n/**\r\n * SVG width and height.\r\n *\r\n * @type {number}\r\n */\n\nvar SIZE = 40;\n;// CONCATENATED MODULE: ./src/js/components/arrows/index.js\n/**\r\n * The component for appending prev/next arrows.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The component for appending prev/next arrows.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const arrows = (function (Splide, Components, name) {\n  /**\r\n   * Previous arrow element.\r\n   *\r\n   * @type {Element|undefined}\r\n   */\n  var prev;\n  /**\r\n   * Next arrow element.\r\n   *\r\n   * @type {Element|undefined}\r\n   */\n\n  var next;\n  /**\r\n   * Store the class list.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var classes = Splide.classes;\n  /**\r\n   * Hold the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var root = Splide.root;\n  /**\r\n   * Whether arrows are created programmatically or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var created;\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Arrows component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Arrows = {\n    /**\r\n     * Required when the arrows option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.arrows,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      // Attempt to get arrows from HTML source.\n      prev = Elements.arrows.prev;\n      next = Elements.arrows.next; // If arrows were not found in HTML, let's generate them.\n\n      if ((!prev || !next) && Splide.options.arrows) {\n        prev = createArrow(true);\n        next = createArrow(false);\n        created = true;\n        appendArrows();\n      }\n\n      if (prev && next) {\n        bind();\n      }\n\n      this.arrows = {\n        prev: prev,\n        next: next\n      };\n    },\n\n    /**\r\n     * Called after all components are mounted.\r\n     */\n    mounted: function mounted() {\n      Splide.emit(name + \":mounted\", prev, next);\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      removeAttribute([prev, next], 'disabled');\n\n      if (created) {\n        dom_remove(prev.parentElement);\n      }\n    }\n  };\n  /**\r\n   * Listen to native and custom events.\r\n   */\n\n  function bind() {\n    Splide.on('click', function () {\n      Splide.go('<');\n    }, prev).on('click', function () {\n      Splide.go('>');\n    }, next).on('mounted move updated refresh', updateDisabled);\n  }\n  /**\r\n   * Update a disabled attribute.\r\n   */\n\n\n  function updateDisabled() {\n    var _Components$Controlle = Components.Controller,\n        prevIndex = _Components$Controlle.prevIndex,\n        nextIndex = _Components$Controlle.nextIndex;\n    var isEnough = Splide.length > Splide.options.perPage || Splide.is(LOOP);\n    prev.disabled = prevIndex < 0 || !isEnough;\n    next.disabled = nextIndex < 0 || !isEnough;\n    Splide.emit(name + \":updated\", prev, next, prevIndex, nextIndex);\n  }\n  /**\r\n   * Create a wrapper element and append arrows.\r\n   */\n\n\n  function appendArrows() {\n    var wrapper = create('div', {\n      \"class\": classes.arrows\n    });\n    append(wrapper, prev);\n    append(wrapper, next);\n    var slider = Elements.slider;\n    var parent = Splide.options.arrows === 'slider' && slider ? slider : root;\n    before(wrapper, parent.firstElementChild);\n  }\n  /**\r\n   * Create an arrow element.\r\n   *\r\n   * @param {boolean} prev - Determine to create a prev arrow or next arrow.\r\n   *\r\n   * @return {Element} - A created arrow element.\r\n   */\n\n\n  function createArrow(prev) {\n    var arrow = \"<button class=\\\"\" + classes.arrow + \" \" + (prev ? classes.prev : classes.next) + \"\\\" type=\\\"button\\\">\" + (\"<svg xmlns=\\\"\" + XML_NAME_SPACE + \"\\\"\\tviewBox=\\\"0 0 \" + SIZE + \" \" + SIZE + \"\\\"\\twidth=\\\"\" + SIZE + \"\\\"\\theight=\\\"\" + SIZE + \"\\\">\") + (\"<path d=\\\"\" + (Splide.options.arrowPath || PATH) + \"\\\" />\");\n    return domify(arrow);\n  }\n\n  return Arrows;\n});\n;// CONCATENATED MODULE: ./src/js/components/pagination/index.js\n/**\r\n * The component for handling pagination\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The event name for updating some attributes of pagination nodes.\r\n *\r\n * @type {string}\r\n */\n\nvar ATTRIBUTES_UPDATE_EVENT = 'move.page';\n/**\r\n * The event name for recreating pagination.\r\n *\r\n * @type {string}\r\n */\n\nvar UPDATE_EVENT = 'updated.page refresh.page';\n/**\r\n * The component for handling pagination\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const pagination = (function (Splide, Components, name) {\n  /**\r\n   * Store all data for pagination.\r\n   * - list: A list element.\r\n   * - items: An array that contains objects(li, button, index, page).\r\n   *\r\n   * @type {Object}\r\n   */\n  var data = {};\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Pagination component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Pagination = {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var pagination = Splide.options.pagination;\n\n      if (pagination) {\n        data = createPagination();\n        var slider = Elements.slider;\n        var parent = pagination === 'slider' && slider ? slider : Splide.root;\n        append(parent, data.list);\n        Splide.on(ATTRIBUTES_UPDATE_EVENT, updateAttributes);\n      }\n\n      Splide.off(UPDATE_EVENT).on(UPDATE_EVENT, function () {\n        Pagination.destroy();\n\n        if (Splide.options.pagination) {\n          Pagination.mount();\n          Pagination.mounted();\n        }\n      });\n    },\n\n    /**\r\n     * Called after all components are mounted.\r\n     */\n    mounted: function mounted() {\n      if (Splide.options.pagination) {\n        var index = Splide.index;\n        Splide.emit(name + \":mounted\", data, this.getItem(index));\n        updateAttributes(index, -1);\n      }\n    },\n\n    /**\r\n     * Destroy the pagination.\r\n     * Be aware that node.remove() is not supported by IE.\r\n     */\n    destroy: function destroy() {\n      dom_remove(data.list);\n\n      if (data.items) {\n        data.items.forEach(function (item) {\n          Splide.off('click', item.button);\n        });\n      } // Do not remove UPDATE_EVENT to recreate pagination if needed.\n\n\n      Splide.off(ATTRIBUTES_UPDATE_EVENT);\n      data = {};\n    },\n\n    /**\r\n     * Return an item by index.\r\n     *\r\n     * @param {number} index - A slide index.\r\n     *\r\n     * @return {Object|undefined} - An item object on success or undefined on failure.\r\n     */\n    getItem: function getItem(index) {\n      return data.items[Components.Controller.toPage(index)];\n    },\n\n    /**\r\n     * Return object containing pagination data.\r\n     *\r\n     * @return {Object} - Pagination data including list and items.\r\n     */\n    get data() {\n      return data;\n    }\n\n  };\n  /**\r\n   * Update attributes.\r\n   *\r\n   * @param {number} index     - Active index.\r\n   * @param {number} prevIndex - Prev index.\r\n   */\n\n  function updateAttributes(index, prevIndex) {\n    var prev = Pagination.getItem(prevIndex);\n    var curr = Pagination.getItem(index);\n    var active = STATUS_CLASSES.active;\n\n    if (prev) {\n      removeClass(prev.button, active);\n    }\n\n    if (curr) {\n      addClass(curr.button, active);\n    }\n\n    Splide.emit(name + \":updated\", data, prev, curr);\n  }\n  /**\r\n   * Create a wrapper and button elements.\r\n   *\r\n   * @return {Object} - An object contains all data.\r\n   */\n\n\n  function createPagination() {\n    var options = Splide.options;\n    var classes = Splide.classes;\n    var list = create('ul', {\n      \"class\": classes.pagination\n    });\n    var items = Elements.getSlides(false).filter(function (Slide) {\n      return options.focus !== false || Slide.index % options.perPage === 0;\n    }).map(function (Slide, page) {\n      var li = create('li', {});\n      var button = create('button', {\n        \"class\": classes.page,\n        type: 'button'\n      });\n      append(li, button);\n      append(list, li);\n      Splide.on('click', function () {\n        Splide.go(\">\" + page);\n      }, button);\n      return {\n        li: li,\n        button: button,\n        page: page,\n        Slides: Elements.getSlidesByPage(page)\n      };\n    });\n    return {\n      list: list,\n      items: items\n    };\n  }\n\n  return Pagination;\n});\n;// CONCATENATED MODULE: ./src/js/components/lazyload/index.js\n/**\r\n * The component for loading slider images lazily.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The name for a data attribute of src.\r\n *\r\n * @type {string}\r\n */\n\nvar SRC_DATA_NAME = 'data-splide-lazy';\n/**\r\n * The name for a data attribute of srcset.\r\n *\r\n * @type {string}\r\n */\n\nvar SRCSET_DATA_NAME = 'data-splide-lazy-srcset';\n/**\r\n * The component for loading slider images lazily.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const lazyload = (function (Splide, Components, name) {\n  /**\r\n   * Next index for sequential loading.\r\n   *\r\n   * @type {number}\r\n   */\n  var nextIndex;\n  /**\r\n   * Store objects containing an img element and a Slide object.\r\n   *\r\n   * @type {Object[]}\r\n   */\n\n  var images;\n  /**\r\n   * Store the options.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var options = Splide.options;\n  /**\r\n   * Whether to load images sequentially or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isSequential = options.lazyLoad === 'sequential';\n  /**\r\n   * Lazyload component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Lazyload = {\n    /**\r\n     * Mount only when the lazyload option is provided.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: options.lazyLoad,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('mounted refresh', function () {\n        init();\n        Components.Elements.each(function (Slide) {\n          each(Slide.slide.querySelectorAll(\"[\" + SRC_DATA_NAME + \"], [\" + SRCSET_DATA_NAME + \"]\"), function (img) {\n            if (!img.src && !img.srcset) {\n              images.push({\n                img: img,\n                Slide: Slide\n              });\n              applyStyle(img, {\n                display: 'none'\n              });\n            }\n          });\n        });\n\n        if (isSequential) {\n          loadNext();\n        }\n      });\n\n      if (!isSequential) {\n        Splide.on(\"mounted refresh moved.\" + name, check);\n      }\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: init\n  };\n  /**\r\n   * Initialize parameters.\r\n   */\n\n  function init() {\n    images = [];\n    nextIndex = 0;\n  }\n  /**\r\n   * Check how close each image is from the active slide and\r\n   * determine whether to start loading or not, according to the distance.\r\n   *\r\n   * @param {number} index - Current index.\r\n   */\n\n\n  function check(index) {\n    index = isNaN(index) ? Splide.index : index;\n    images = images.filter(function (image) {\n      if (image.Slide.isWithin(index, options.perPage * (options.preloadPages + 1))) {\n        load(image.img, image.Slide);\n        return false;\n      }\n\n      return true;\n    }); // Unbind if all images are loaded.\n\n    if (!images[0]) {\n      Splide.off(\"moved.\" + name);\n    }\n  }\n  /**\r\n   * Start loading an image.\r\n   * Creating a clone of the image element since setting src attribute directly to it\r\n   * often occurs 'hitch', blocking some other processes of a browser.\r\n   *\r\n   * @param {Element} img   - An image element.\r\n   * @param {Object}  Slide - A Slide object.\r\n   */\n\n\n  function load(img, Slide) {\n    addClass(Slide.slide, STATUS_CLASSES.loading);\n    var spinner = create('span', {\n      \"class\": Splide.classes.spinner\n    });\n    append(img.parentElement, spinner);\n\n    img.onload = function () {\n      loaded(img, spinner, Slide, false);\n    };\n\n    img.onerror = function () {\n      loaded(img, spinner, Slide, true);\n    };\n\n    setAttribute(img, 'srcset', getAttribute(img, SRCSET_DATA_NAME) || '');\n    setAttribute(img, 'src', getAttribute(img, SRC_DATA_NAME) || '');\n  }\n  /**\r\n   * Start loading a next image in images array.\r\n   */\n\n\n  function loadNext() {\n    if (nextIndex < images.length) {\n      var image = images[nextIndex];\n      load(image.img, image.Slide);\n    }\n\n    nextIndex++;\n  }\n  /**\r\n   * Called just after the image was loaded or loading was aborted by some error.\r\n   *\r\n   * @param {Element} img     - An image element.\r\n   * @param {Element} spinner - A spinner element.\r\n   * @param {Object}  Slide   - A Slide object.\r\n   * @param {boolean} error   - True if the image was loaded successfully or false on error.\r\n   */\n\n\n  function loaded(img, spinner, Slide, error) {\n    removeClass(Slide.slide, STATUS_CLASSES.loading);\n\n    if (!error) {\n      dom_remove(spinner);\n      applyStyle(img, {\n        display: ''\n      });\n      Splide.emit(name + \":loaded\", img).emit('resize');\n    }\n\n    if (isSequential) {\n      loadNext();\n    }\n  }\n\n  return Lazyload;\n});\n;// CONCATENATED MODULE: ./src/js/constants/a11y.js\n/**\r\n * Export aria attribute names.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Attribute name for aria-current.\r\n *\r\n * @type {string}\r\n */\nvar ARIA_CURRENRT = 'aria-current';\n/**\r\n * Attribute name for aria-control.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_CONTROLS = 'aria-controls';\n/**\r\n * Attribute name for aria-control.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_LABEL = 'aria-label';\n/**\r\n * Attribute name for aria-labelledby.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_LABELLEDBY = 'aria-labelledby';\n/**\r\n * Attribute name for aria-hidden.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_HIDDEN = 'aria-hidden';\n/**\r\n * Attribute name for tab-index.\r\n *\r\n * @type {string}\r\n */\n\nvar TAB_INDEX = 'tabindex';\n;// CONCATENATED MODULE: ./src/js/components/keyboard/index.js\n/**\r\n * The component for controlling slides via keyboard.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Map a key to a slide control.\r\n *\r\n * @type {Object}\r\n */\n\nvar KEY_MAP = {\n  ltr: {\n    ArrowLeft: '<',\n    ArrowRight: '>',\n    // For IE.\n    Left: '<',\n    Right: '>'\n  },\n  rtl: {\n    ArrowLeft: '>',\n    ArrowRight: '<',\n    // For IE.\n    Left: '>',\n    Right: '<'\n  },\n  ttb: {\n    ArrowUp: '<',\n    ArrowDown: '>',\n    // For IE.\n    Up: '<',\n    Down: '>'\n  }\n};\n/**\r\n * The component for controlling slides via keyboard.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const keyboard = (function (Splide) {\n  /**\r\n   * Hold the target element.\r\n   *\r\n   * @type {Element|Document|undefined}\r\n   */\n  var target;\n  return {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('mounted updated', function () {\n        var options = Splide.options;\n        var root = Splide.root;\n        var map = KEY_MAP[options.direction];\n        var keyboard = options.keyboard;\n\n        if (target) {\n          Splide.off('keydown', target);\n          removeAttribute(root, TAB_INDEX);\n        }\n\n        if (keyboard) {\n          if (keyboard === 'focused') {\n            target = root;\n            setAttribute(root, TAB_INDEX, 0);\n          } else {\n            target = document;\n          }\n\n          Splide.on('keydown', function (e) {\n            if (map[e.key]) {\n              Splide.go(map[e.key]);\n            }\n          }, target);\n        }\n      });\n    }\n  };\n});\n;// CONCATENATED MODULE: ./src/js/components/a11y/index.js\n/**\r\n * The component for enhancing accessibility.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The component for enhancing accessibility.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const a11y = (function (Splide, Components) {\n  /**\r\n   * Hold a i18n object.\r\n   *\r\n   * @type {Object}\r\n   */\n  var i18n = Splide.i18n;\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * All attributes related with A11y.\r\n   *\r\n   * @type {string[]}\r\n   */\n\n  var allAttributes = [ARIA_HIDDEN, TAB_INDEX, ARIA_CONTROLS, ARIA_LABEL, ARIA_CURRENRT, 'role'];\n  /**\r\n   * A11y component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var A11y = {\n    /**\r\n     * Required only when the accessibility option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.accessibility,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('visible', function (Slide) {\n        updateSlide(Slide.slide, true);\n      }).on('hidden', function (Slide) {\n        updateSlide(Slide.slide, false);\n      }).on('arrows:mounted', initArrows).on('arrows:updated', updateArrows).on('pagination:mounted', initPagination).on('pagination:updated', updatePagination).on('refresh', function () {\n        removeAttribute(Components.Clones.clones, allAttributes);\n      });\n\n      if (Splide.options.isNavigation) {\n        Splide.on('navigation:mounted navigation:updated', initNavigation).on('active', function (Slide) {\n          updateNavigation(Slide, true);\n        }).on('inactive', function (Slide) {\n          updateNavigation(Slide, false);\n        });\n      }\n\n      initAutoplay();\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      var Arrows = Components.Arrows;\n      var arrows = Arrows ? Arrows.arrows : {};\n      removeAttribute(Elements.slides.concat([arrows.prev, arrows.next, Elements.play, Elements.pause]), allAttributes);\n    }\n  };\n  /**\r\n   * Update slide attributes when it gets visible or hidden.\r\n   *\r\n   * @param {Element} slide   - A slide element.\r\n   * @param {Boolean} visible - True when the slide gets visible, or false when hidden.\r\n   */\n\n  function updateSlide(slide, visible) {\n    setAttribute(slide, ARIA_HIDDEN, !visible);\n\n    if (Splide.options.slideFocus) {\n      setAttribute(slide, TAB_INDEX, visible ? 0 : -1);\n    }\n  }\n  /**\r\n   * Initialize arrows if they are available.\r\n   * Append screen reader elements and add aria-controls attribute.\r\n   *\r\n   * @param {Element} prev - Previous arrow element.\r\n   * @param {Element} next - Next arrow element.\r\n   */\n\n\n  function initArrows(prev, next) {\n    var controls = Elements.track.id;\n    setAttribute(prev, ARIA_CONTROLS, controls);\n    setAttribute(next, ARIA_CONTROLS, controls);\n  }\n  /**\r\n   * Update arrow attributes.\r\n   *\r\n   * @param {Element} prev      - Previous arrow element.\r\n   * @param {Element} next      - Next arrow element.\r\n   * @param {number}  prevIndex - Previous slide index or -1 when there is no precede slide.\r\n   * @param {number}  nextIndex - Next slide index or -1 when there is no next slide.\r\n   */\n\n\n  function updateArrows(prev, next, prevIndex, nextIndex) {\n    var index = Splide.index;\n    var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;\n    var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;\n    setAttribute(prev, ARIA_LABEL, prevLabel);\n    setAttribute(next, ARIA_LABEL, nextLabel);\n  }\n  /**\r\n   * Initialize pagination if it's available.\r\n   * Append a screen reader element and add aria-controls/label attribute to each item.\r\n   *\r\n   * @param {Object} data       - Data object containing all items.\r\n   * @param {Object} activeItem - An initial active item.\r\n   */\n\n\n  function initPagination(data, activeItem) {\n    if (activeItem) {\n      setAttribute(activeItem.button, ARIA_CURRENRT, true);\n    }\n\n    data.items.forEach(function (item) {\n      var options = Splide.options;\n      var text = options.focus === false && options.perPage > 1 ? i18n.pageX : i18n.slideX;\n      var label = sprintf(text, item.page + 1);\n      var button = item.button;\n      var controls = item.Slides.map(function (Slide) {\n        return Slide.slide.id;\n      });\n      setAttribute(button, ARIA_CONTROLS, controls.join(' '));\n      setAttribute(button, ARIA_LABEL, label);\n    });\n  }\n  /**\r\n   * Update pagination attributes.\r\n   *\r\n   * @param {Object}  data - Data object containing all items.\r\n   * @param {Element} prev - A previous active element.\r\n   * @param {Element} curr - A current active element.\r\n   */\n\n\n  function updatePagination(data, prev, curr) {\n    if (prev) {\n      removeAttribute(prev.button, ARIA_CURRENRT);\n    }\n\n    if (curr) {\n      setAttribute(curr.button, ARIA_CURRENRT, true);\n    }\n  }\n  /**\r\n   * Initialize autoplay buttons.\r\n   */\n\n\n  function initAutoplay() {\n    ['play', 'pause'].forEach(function (name) {\n      var elm = Elements[name];\n\n      if (elm) {\n        if (!isButton(elm)) {\n          setAttribute(elm, 'role', 'button');\n        }\n\n        setAttribute(elm, ARIA_CONTROLS, Elements.track.id);\n        setAttribute(elm, ARIA_LABEL, i18n[name]);\n      }\n    });\n  }\n  /**\r\n   * Initialize navigation slider.\r\n   * Add button role, aria-label, aria-controls to slide elements and append screen reader text to them.\r\n   *\r\n   * @param {Splide} main - A main Splide instance.\r\n   */\n\n\n  function initNavigation(main) {\n    Elements.each(function (Slide) {\n      var slide = Slide.slide;\n      var realIndex = Slide.realIndex;\n\n      if (!isButton(slide)) {\n        setAttribute(slide, 'role', 'button');\n      }\n\n      var slideIndex = realIndex > -1 ? realIndex : Slide.index;\n      var label = sprintf(i18n.slideX, slideIndex + 1);\n      var mainSlide = main.Components.Elements.getSlide(slideIndex);\n      setAttribute(slide, ARIA_LABEL, label);\n\n      if (mainSlide) {\n        setAttribute(slide, ARIA_CONTROLS, mainSlide.slide.id);\n      }\n    });\n  }\n  /**\r\n   * Update navigation attributes.\r\n   *\r\n   * @param {Object}  Slide  - A target Slide object.\r\n   * @param {boolean} active - True if the slide is active or false if inactive.\r\n   */\n\n\n  function updateNavigation(_ref, active) {\n    var slide = _ref.slide;\n\n    if (active) {\n      setAttribute(slide, ARIA_CURRENRT, true);\n    } else {\n      removeAttribute(slide, ARIA_CURRENRT);\n    }\n  }\n  /**\r\n   * Check if the given element is button or not.\r\n   *\r\n   * @param {Element} elm - An element to be checked.\r\n   *\r\n   * @return {boolean} - True if the given element is button.\r\n   */\n\n\n  function isButton(elm) {\n    return elm.tagName === 'BUTTON';\n  }\n\n  return A11y;\n});\n;// CONCATENATED MODULE: ./src/js/components/sync/index.js\n/**\r\n * The component for synchronizing a slider with another.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The event name for sync.\r\n *\r\n * @type {string}\r\n */\n\nvar SYNC_EVENT = 'move.sync';\n/**\r\n * The event names for click navigation.\r\n * @type {string}\r\n */\n\nvar CLICK_EVENTS = 'mouseup touchend';\n/**\r\n * The keys for triggering the navigation button.\r\n *\r\n * @type {String[]}\r\n */\n\nvar TRIGGER_KEYS = [' ', 'Enter', 'Spacebar'];\n/**\r\n * The component for synchronizing a slider with another.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const sync = (function (Splide) {\n  /**\r\n   * Keep the sibling Splide instance.\r\n   *\r\n   * @type {Splide}\r\n   */\n  var sibling = Splide.sibling;\n  /**\r\n   * Whether the sibling slider is navigation or not.\r\n   *\r\n   * @type {Splide|boolean}\r\n   */\n\n  var isNavigation = sibling && sibling.options.isNavigation;\n  /**\r\n   * Layout component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Sync = {\n    /**\r\n     * Required only when the sub slider is available.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: !!sibling,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      syncMain();\n      syncSibling();\n\n      if (isNavigation) {\n        bind();\n        Splide.on('refresh', function () {\n          setTimeout(function () {\n            bind();\n            sibling.emit('navigation:updated', Splide);\n          });\n        });\n      }\n    },\n\n    /**\r\n     * Called after all components are mounted.\r\n     */\n    mounted: function mounted() {\n      if (isNavigation) {\n        sibling.emit('navigation:mounted', Splide);\n      }\n    }\n  };\n  /**\r\n   * Listen the primary slider event to move secondary one.\r\n   * Must unbind a handler at first to avoid infinite loop.\r\n   */\n\n  function syncMain() {\n    Splide.on(SYNC_EVENT, function (newIndex, prevIndex, destIndex) {\n      sibling.off(SYNC_EVENT).go(sibling.is(LOOP) ? destIndex : newIndex, false);\n      syncSibling();\n    });\n  }\n  /**\r\n   * Listen the secondary slider event to move primary one.\r\n   * Must unbind a handler at first to avoid infinite loop.\r\n   */\n\n\n  function syncSibling() {\n    sibling.on(SYNC_EVENT, function (newIndex, prevIndex, destIndex) {\n      Splide.off(SYNC_EVENT).go(Splide.is(LOOP) ? destIndex : newIndex, false);\n      syncMain();\n    });\n  }\n  /**\r\n   * Listen some events on each slide.\r\n   */\n\n\n  function bind() {\n    sibling.Components.Elements.each(function (_ref) {\n      var slide = _ref.slide,\n          index = _ref.index;\n\n      /*\r\n       * Listen mouseup and touchend events to handle click.\r\n       */\n      Splide.off(CLICK_EVENTS, slide).on(CLICK_EVENTS, function (e) {\n        // Ignore a middle or right click.\n        if (!e.button || e.button === 0) {\n          moveSibling(index);\n        }\n      }, slide);\n      /*\r\n       * Subscribe keyup to handle Enter and Space key.\r\n       * Note that Array.includes is not supported by IE.\r\n       */\n\n      Splide.off('keyup', slide).on('keyup', function (e) {\n        if (TRIGGER_KEYS.indexOf(e.key) > -1) {\n          e.preventDefault();\n          moveSibling(index);\n        }\n      }, slide, {\n        passive: false\n      });\n    });\n  }\n  /**\r\n   * Move the sibling to the given index.\r\n   * Need to check \"IDLE\" status because slides can be moving by Drag component.\r\n   *\r\n   * @param {number} index - Target index.\r\n   */\n\n\n  function moveSibling(index) {\n    if (Splide.State.is(IDLE)) {\n      sibling.go(index);\n    }\n  }\n\n  return Sync;\n});\n;// CONCATENATED MODULE: ./src/js/components/breakpoints/index.js\n/**\r\n * The component for updating options according to a current window width.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Interval time for throttle.\r\n *\r\n * @type {number}\r\n */\n\nvar THROTTLE = 50;\n/**\r\n * The component for updating options according to a current window width.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const breakpoints = (function (Splide) {\n  /**\r\n   * Store breakpoints.\r\n   *\r\n   * @type {Object|boolean}\r\n   */\n  var breakpoints = Splide.options.breakpoints;\n  /**\r\n   * The check function whose frequency of call is reduced.\r\n   *\r\n   * @type {Function}\r\n   */\n\n  var throttledCheck = throttle(check, THROTTLE);\n  /**\r\n   * Keep initial options.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var initialOptions;\n  /**\r\n   * An array containing objects of point and MediaQueryList.\r\n   *\r\n   * @type {Object[]}\r\n   */\n\n  var map = [];\n  /**\r\n   * Hold the previous breakpoint.\r\n   *\r\n   * @type {number|undefined}\r\n   */\n\n  var prevPoint;\n  /**\r\n   * Breakpoints component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Breakpoints = {\n    /**\r\n     * Required only when the breakpoints definition is provided and browser supports matchMedia.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: breakpoints && matchMedia,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      map = Object.keys(breakpoints).sort(function (n, m) {\n        return +n - +m;\n      }).map(function (point) {\n        return {\n          point: point,\n          mql: matchMedia(\"(max-width:\" + point + \"px)\")\n        };\n      });\n      /*\r\n       * To keep monitoring resize event after destruction without \"completely\",\r\n       * use native addEventListener instead of Splide.on.\r\n       */\n\n      this.destroy(true);\n      addEventListener('resize', throttledCheck); // Keep initial options to apply them when no breakpoint matches.\n\n      initialOptions = Splide.options;\n      check();\n    },\n\n    /**\r\n     * Destroy.\r\n     *\r\n     * @param {boolean} completely - Whether to destroy Splide completely.\r\n     */\n    destroy: function destroy(completely) {\n      if (completely) {\n        removeEventListener('resize', throttledCheck);\n      }\n    }\n  };\n  /**\r\n   * Check the breakpoint.\r\n   */\n\n  function check() {\n    var point = getPoint();\n\n    if (point !== prevPoint) {\n      prevPoint = point;\n      var State = Splide.State;\n      var options = breakpoints[point] || initialOptions;\n      var destroy = options.destroy;\n\n      if (destroy) {\n        Splide.options = initialOptions;\n        Splide.destroy(destroy === 'completely');\n      } else {\n        if (State.is(DESTROYED)) {\n          Splide.mount();\n        }\n\n        Splide.options = options;\n      }\n    }\n  }\n  /**\r\n   * Return the breakpoint matching current window width.\r\n   * Note that Array.prototype.find is not supported by IE.\r\n   *\r\n   * @return {number|string} - A breakpoint as number or string. -1 if no point matches.\r\n   */\n\n\n  function getPoint() {\n    var item = map.filter(function (item) {\n      return item.mql.matches;\n    })[0];\n    return item ? item.point : -1;\n  }\n\n  return Breakpoints;\n});\n;// CONCATENATED MODULE: ./src/js/components/index.js\n/**\r\n * Export components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar COMPLETE = {\n  Options: options,\n  Breakpoints: breakpoints,\n  Controller: controller,\n  Elements: components_elements,\n  Track: track,\n  Clones: clones,\n  Layout: layout,\n  Drag: drag,\n  Click: click,\n  Autoplay: autoplay,\n  Cover: cover,\n  Arrows: arrows,\n  Pagination: pagination,\n  LazyLoad: lazyload,\n  Keyboard: keyboard,\n  Sync: sync,\n  A11y: a11y\n};\nvar LIGHT = {\n  Options: options,\n  Controller: controller,\n  Elements: components_elements,\n  Track: track,\n  Clones: clones,\n  Layout: layout,\n  Drag: drag,\n  Click: click,\n  Arrows: arrows,\n  Pagination: pagination,\n  A11y: a11y\n};\n;// CONCATENATED MODULE: ./build/module/module.js\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\r\n * Export Splide class for import.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Export Splide class for import from other projects.\r\n */\n\nvar module_Splide = /*#__PURE__*/function (_Core) {\n  _inheritsLoose(Splide, _Core);\n\n  function Splide(root, options) {\n    return _Core.call(this, root, options, COMPLETE) || this;\n  }\n\n  return Splide;\n}(Splide);\n\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_139193__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(__webpack_module_cache__[moduleId]) {\n/******/ \t\t\treturn __webpack_module_cache__[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_139193__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_139193__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_139193__.o(definition, key) && !__nested_webpack_require_139193__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_139193__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_139193__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\n/******/ \t// module exports must be returned from runtime so entry inlining is disabled\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_139193__(311);\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNwbGlkZWpzL3NwbGlkZS9kaXN0L2pzL3NwbGlkZS5lc20uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUt1QjtBQUM3QixDQUFDO0FBQ0QseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsMEJBQW1CLEVBQUUsOEJBQW1COztBQUV6RTtBQUNBLDhCQUFtQixHQUFHLDBCQUFtQjs7QUFFekM7QUFDQSw4QkFBbUIsR0FBRywwQkFBbUI7QUFDekM7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSw4QkFBbUI7QUFDbkIsOEJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLHdGQUF3RixVQUFVO0FBQ2xHLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFD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O0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9CQUFvQjtBQUM3QixTQUFTLG9CQUFvQjtBQUM3QjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztB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YztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQzs7O0FBR0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjLFNBQVM7QUFDdkI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsaUNBQW1CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQW1CO0FBQzlCO0FBQ0EsZ0JBQWdCLGlDQUFtQix3QkFBd0IsaUNBQW1CO0FBQzlFLG9EQUFvRCx3Q0FBd0M7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQW1CO0FBQzlCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQW1CO0FBQzlCO0FBQ0Esa0VBQWtFLGlCQUFpQjtBQUNuRjtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUNBQW1CO0FBQ3BDLFVBQVU7QUFDVjtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92b2dsLy4vbm9kZV9tb2R1bGVzL0BzcGxpZGVqcy9zcGxpZGUvZGlzdC9qcy9zcGxpZGUuZXNtLmpzPzU4NzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBTcGxpZGUuanNcbiAqIFZlcnNpb24gIDogMi40LjIwXG4gKiBMaWNlbnNlICA6IE1JVFxuICogQ29weXJpZ2h0OiAyMDIwIE5hb3Rvc2hpIEZ1aml0YVxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJTcGxpZGVcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiU3BsaWRlXCJdID0gZmFjdG9yeSgpO1xufSkoc2VsZiwgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyAzMTE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIEVTTSBDT01QQVQgRkxBR1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuICBcImRlZmF1bHRcIjogKCkgPT4gLyogYmluZGluZyAqLyBtb2R1bGVfU3BsaWRlXG59KTtcblxuLy8gTkFNRVNQQUNFIE9CSkVDVDogLi9zcmMvanMvY29uc3RhbnRzL3N0YXRlcy5qc1xudmFyIHN0YXRlc19uYW1lc3BhY2VPYmplY3QgPSB7fTtcbl9fd2VicGFja19yZXF1aXJlX18ucihzdGF0ZXNfbmFtZXNwYWNlT2JqZWN0KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChzdGF0ZXNfbmFtZXNwYWNlT2JqZWN0LCB7XG4gIFwiQ1JFQVRFRFwiOiAoKSA9PiBDUkVBVEVELFxuICBcIkRFU1RST1lFRFwiOiAoKSA9PiBERVNUUk9ZRUQsXG4gIFwiSURMRVwiOiAoKSA9PiBJRExFLFxuICBcIk1PVU5URURcIjogKCkgPT4gTU9VTlRFRCxcbiAgXCJNT1ZJTkdcIjogKCkgPT4gTU9WSU5HXG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvcmUvZXZlbnQuanNcbi8qKlxyXG4gKiBUaGUgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhbiBFdmVudCBvYmplY3Qgc2ltcGx5IG1hbmFnaW5nIGV2ZW50cy5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG4vKipcclxuICogVGhlIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYW4gRXZlbnQgb2JqZWN0IHNpbXBseSBtYW5hZ2luZyBldmVudHMuXHJcbiAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb3JlX2V2ZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogU3RvcmUgYWxsIGV2ZW50IGRhdGEuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICovXG4gIHZhciBkYXRhID0gW107XG4gIHZhciBFdmVudCA9IHtcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSB0aGUgZ2l2ZW4gZXZlbnQocykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgZXZlbnRzICAtIEFuIGV2ZW50IG5hbWUuIFVzZSBzcGFjZSB0byBzZXBhcmF0ZSBtdWx0aXBsZSBldmVudHMuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxzbywgbmFtZXNwYWNlIGlzIGFjY2VwdGVkIGJ5IGRvdCwgc3VjaCBhcyAncmVzaXplLntuYW1lc3BhY2V9Jy5cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSBBIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSAgZWxtICAgICAtIE9wdGlvbmFsLiBOYXRpdmUgZXZlbnQgd2lsbCBiZSBsaXN0ZW5lZCB0byB3aGVuIHRoaXMgYXJnIGlzIHByb3ZpZGVkLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucyAtIE9wdGlvbmFsLiBPcHRpb25zIGZvciBhZGRFdmVudExpc3RlbmVyLlxyXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uIG9uKGV2ZW50cywgaGFuZGxlciwgZWxtLCBvcHRpb25zKSB7XG4gICAgICBpZiAoZWxtID09PSB2b2lkIDApIHtcbiAgICAgICAgZWxtID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG5cbiAgICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChlbG0pIHtcbiAgICAgICAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgIGVsbTogZWxtLFxuICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBVbnN1YnNjcmliZSB0aGUgZ2l2ZW4gZXZlbnQocykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICBldmVudHMgLSBBIGV2ZW50IG5hbWUgb3IgbmFtZXMgc3BsaXQgYnkgc3BhY2UuXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsbSAgICAtIE9wdGlvbmFsLiByZW1vdmVFdmVudExpc3RlbmVyKCkgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGlzIGFyZyBpcyBwcm92aWRlZC5cclxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24gb2ZmKGV2ZW50cywgZWxtKSB7XG4gICAgICBpZiAoZWxtID09PSB2b2lkIDApIHtcbiAgICAgICAgZWxtID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5ldmVudCA9PT0gZXZlbnQgJiYgaXRlbS5lbG0gPT09IGVsbSkge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoaXRlbSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogRW1pdCBhbiBldmVudC5cclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG9ubHkgZm9yIGN1c3RvbSBldmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICBldmVudCAtIEFuIGV2ZW50IG5hbWUuXHJcbiAgICAgKiBAcGFyYW0geyp9ICAgICAgIGFyZ3MgIC0gQW55IG51bWJlciBvZiBhcmd1bWVudHMgcGFzc2VkIHRvIGhhbmRsZXJzLlxyXG4gICAgICovXG4gICAgZW1pdDogZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbS5lbG0gJiYgaXRlbS5ldmVudC5zcGxpdCgnLicpWzBdID09PSBldmVudCkge1xuICAgICAgICAgIGl0ZW0uaGFuZGxlci5hcHBseShpdGVtLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogQ2xlYXIgZXZlbnQgZGF0YS5cclxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBkYXRhLmZvckVhY2godW5zdWJzY3JpYmUpO1xuICAgICAgZGF0YSA9IFtdO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogUmVtb3ZlIHRoZSByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gLSBBbiBvYmplY3QgY29udGFpbmluZyBldmVudCBkYXRhLlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGl0ZW0pIHtcbiAgICBpZiAoaXRlbS5lbG0pIHtcbiAgICAgIGl0ZW0uZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIoaXRlbS5ldmVudCwgaXRlbS5oYW5kbGVyLCBpdGVtLm9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBFdmVudDtcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvcmUvc3RhdGUuanNcbi8qKlxyXG4gKiBUaGUgZnVuY3Rpb24gcHJvdmlkaW5nIGEgc3VwZXIgc2ltcGxlIHN0YXRlIHN5c3RlbS5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG4vKipcclxuICogVGhlIGZ1bmN0aW9uIHByb3ZpZGluZyBhIHN1cGVyIHNpbXBsZSBzdGF0ZSBzeXN0ZW0uXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gaW5pdGlhbFN0YXRlIC0gUHJvdmlkZSB0aGUgaW5pdGlhbCBzdGF0ZSB2YWx1ZS5cclxuICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHN0YXRlID0gKGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgLyoqXHJcbiAgICogU3RvcmUgdGhlIGN1cnJlbnQgc3RhdGUuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7c3RyaW5nfG51bWJlcn1cclxuICAgKi9cbiAgdmFyIGN1cnIgPSBpbml0aWFsU3RhdGU7XG4gIHJldHVybiB7XG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2Ugc3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBzdGF0ZSAtIEEgbmV3IHN0YXRlLlxyXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICAgIGN1cnIgPSBzdGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZnkgaWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgZ2l2ZW4gb25lIG9yIG5vdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHN0YXRlIC0gQSBzdGF0ZSBuYW1lIHRvIGJlIHZlcmlmaWVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB0aGUgZ2l2ZW4gb25lLlxyXG4gICAgICovXG4gICAgaXM6IGZ1bmN0aW9uIGlzKHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGUgPT09IGN1cnI7XG4gICAgfVxuICB9O1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvdXRpbHMvb2JqZWN0LmpzXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG4vKipcclxuICogU29tZSB1dGlsaXR5IGZ1bmN0aW9ucyByZWxhdGVkIHdpdGggT2JqZWN0LCBzdXBwb3J0aW5nIElFLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG52YXIga2V5cyA9IE9iamVjdC5rZXlzO1xuLyoqXHJcbiAqIEl0ZXJhdGUgYW4gb2JqZWN0IGxpa2UgQXJyYXkuZm9yRWFjaC5cclxuICogSUUgZG9lc24ndCBzdXBwb3J0IGZvckVhY2ggb2YgSFRNTENvbGxlY3Rpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICBvYmogICAgICAgLSBBbiBvYmplY3QuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259ICBjYWxsYmFjayAgLSBBIGZ1bmN0aW9uIGhhbmRsaW5nIGVhY2ggdmFsdWUuIEFyZ3VtZW50cyBhcmUgdmFsdWUsIHByb3BlcnR5IGFuZCBpbmRleC5cclxuICovXG5cbmZ1bmN0aW9uIGVhY2gob2JqLCBjYWxsYmFjaykge1xuICBrZXlzKG9iaikuc29tZShmdW5jdGlvbiAoa2V5LCBpbmRleCkge1xuICAgIHJldHVybiBjYWxsYmFjayhvYmpba2V5XSwga2V5LCBpbmRleCk7XG4gIH0pO1xufVxuLyoqXHJcbiAqIFJldHVybiB2YWx1ZXMgb2YgdGhlIGdpdmVuIG9iamVjdCBhcyBhbiBhcnJheS5cclxuICogSUUgZG9lc24ndCBzdXBwb3J0IE9iamVjdC52YWx1ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBBbiBvYmplY3QuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0FycmF5fSAtIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxyXG4gKi9cblxuZnVuY3Rpb24gdmFsdWVzKG9iaikge1xuICByZXR1cm4ga2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9KTtcbn1cbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gc3ViamVjdCBpcyBvYmplY3Qgb3Igbm90LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHN1YmplY3QgLSBBIHN1YmplY3QgdG8gYmUgdmVyaWZpZWQuXHJcbiAqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0Jztcbn1cbi8qKlxyXG4gKiBNZXJnZSB0d28gb2JqZWN0cyBkZWVwbHkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0byAgIC0gQW4gb2JqZWN0IHdoZXJlIFwiZnJvbVwiIGlzIG1lcmdlZC5cclxuICogQHBhcmFtIHtPYmplY3R9IGZyb20gLSBBbiBvYmplY3QgbWVyZ2VkIHRvIFwidG9cIi5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIEEgbWVyZ2VkIG9iamVjdC5cclxuICovXG5cbmZ1bmN0aW9uIG1lcmdlKF9yZWYsIGZyb20pIHtcbiAgdmFyIHRvID0gX2V4dGVuZHMoe30sIF9yZWYpO1xuXG4gIGVhY2goZnJvbSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHRvW2tleV0pKSB7XG4gICAgICAgIHRvW2tleV0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgdG9ba2V5XSA9IG1lcmdlKHRvW2tleV0sIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9ba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0bztcbn1cbi8qKlxyXG4gKiBBc3NpZ24gYWxsIHByb3BlcnRpZXMgXCJmcm9tXCIgdG8gXCJ0b1wiIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRvICAgLSBBbiBvYmplY3Qgd2hlcmUgcHJvcGVydGllcyBhcmUgYXNzaWduZWQuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tIC0gQW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGFzc2lnbmVkIHRvIFwidG9cIi5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIEFuIGFzc2lnbmVkIG9iamVjdC5cclxuICovXG5cbmZ1bmN0aW9uIG9iamVjdF9hc3NpZ24odG8sIGZyb20pIHtcbiAga2V5cyhmcm9tKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIXRvW2tleV0pIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0bywga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZyb20sIGtleSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0bztcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy91dGlscy91dGlscy5qc1xuLyoqXHJcbiAqIEEgcGFja2FnZSBvZiBzb21lIG1pc2NlbGxhbmVvdXMgdXRpbGl0eSBmdW5jdGlvbnMuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuLyoqXHJcbiAqIENvbnZlcnQgdGhlIGdpdmVuIHZhbHVlIHRvIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gQW55IHZhbHVlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHsqW119IC0gQXJyYXkgY29udGFpbmluZyB0aGUgZ2l2ZW4gdmFsdWUuXHJcbiAqL1xuXG5mdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn1cbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYmV0d2VlbiBtaW4gYW5kIG1heC5cclxuICogTWluIHdpbGwgYmUgcmV0dXJuZWQgd2hlbiB0aGUgdmFsdWUgaXMgbGVzcyB0aGFuIG1pbiBvciBtYXggd2lsbCBkbyB3aGVuIGdyZWF0ZXIgdGhhbiBtYXguXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIEEgbnVtYmVyIHRvIGJlIGNoZWNrZWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtMSAgICAtIE1pbmltdW0gb3IgbWF4aW11bSBudW1iZXIuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtMiAgICAtIE1heGltdW0gb3IgbWluaW11bSBudW1iZXIuXHJcbiAqXHJcbiAqIEByZXR1cm4ge251bWJlcn0gLSBBIHZhbHVlIGl0c2VsZiwgbWluIG9yIG1heC5cclxuICovXG5cbmZ1bmN0aW9uIGJldHdlZW4odmFsdWUsIG0xLCBtMikge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG0xID4gbTIgPyBtMiA6IG0xKSwgbTEgPiBtMiA/IG0xIDogbTIpO1xufVxuLyoqXHJcbiAqIFRoZSBzcHJpbnRmIG1ldGhvZCB3aXRoIG1pbmltdW0gZnVuY3Rpb25hbGl0eS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgIGZvcm1hdCAgICAgICAtIFRoZSBzdHJpbmcgZm9ybWF0LlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gcmVwbGFjZW1lbnRzIC0gUmVwbGFjZW1lbnRzIGFjY2VwdGluZyBtdWx0aXBsZSBhcmd1bWVudHMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gQ29udmVydGVkIHN0cmluZy5cclxuICovXG5cbmZ1bmN0aW9uIHNwcmludGYoZm9ybWF0LCByZXBsYWNlbWVudHMpIHtcbiAgdmFyIGkgPSAwO1xuICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdG9BcnJheShyZXBsYWNlbWVudHMpW2krK107XG4gIH0pO1xufVxuLyoqXHJcbiAqIEFwcGVuZCBweCB1bml0IHRvIHRoZSBnaXZlbiBzdWJqZWN0IGlmIG5lY2Vzc2FyeS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZSAtIEEgdmFsdWUgdGhhdCBtYXkgbm90IGluY2x1ZGUgYW4gdW5pdC5cclxuICpcclxuICogQHJldHVybiB7c3RyaW5nfSAtIElmIHRoZSB2YWx1ZSBpcyBzdHJpbmcsIHJldHVybiBpdHNlbGYuXHJcbiAqICAgICAgICAgICAgICAgICAgICBJZiBudW1iZXIsIGRvIHZhbHVlICsgXCJweFwiLiBBbiBlbXB0eSBzdHJpbmcsIG90aGVyd2lzZS5cclxuICovXG5cbmZ1bmN0aW9uIHVuaXQodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIHZhbHVlID4gMCkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSArICdweCc7XG4gIH1cblxuICByZXR1cm4gdHlwZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6ICcnO1xufVxuLyoqXHJcbiAqIFBhZCBzdGFydCB3aXRoIDAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgLSBBIG51bWJlciB0byBiZSBmaWxsZWQgd2l0aCAwLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVtYmVyfSAtIFBhZGRlZCBudW1iZXIuXHJcbiAqL1xuXG5mdW5jdGlvbiBwYWQobnVtYmVyKSB7XG4gIHJldHVybiBudW1iZXIgPCAxMCA/ICcwJyArIG51bWJlciA6IG51bWJlcjtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiB2YWx1ZSB0byBwaXhlbC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSAgICAgICByb290ICAtIFJvb3QgZWxlbWVudCB3aGVyZSBhIGR1bW15IGRpdiBpcyBhcHBlbmRlZC5cclxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZSAtIENTUyB2YWx1ZSB0byBiZSBjb252ZXJ0ZWQsIHN1Y2ggYXMgMTByZW0uXHJcbiAqXHJcbiAqIEByZXR1cm4ge251bWJlcn0gLSBQaXhlbC5cclxuICovXG5cbmZ1bmN0aW9uIHRvUGl4ZWwocm9vdCwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgZGl2ID0gY3JlYXRlKCdkaXYnLCB7fSk7XG4gICAgYXBwbHlTdHlsZShkaXYsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6IHZhbHVlXG4gICAgfSk7XG4gICAgYXBwZW5kKHJvb3QsIGRpdik7XG4gICAgdmFsdWUgPSBkaXYuY2xpZW50V2lkdGg7XG4gICAgZG9tX3JlbW92ZShkaXYpO1xuICB9XG5cbiAgcmV0dXJuICt2YWx1ZSB8fCAwO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL3V0aWxzL2RvbS5qc1xuLyoqXHJcbiAqIFNvbWUgdXRpbGl0eSBmdW5jdGlvbnMgcmVsYXRlZCB3aXRoIERPTS5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cbi8qKlxyXG4gKiBGaW5kIHRoZSBmaXJzdCBlbGVtZW50IG1hdGNoaW5nIHRoZSBnaXZlbiBzZWxlY3Rvci5cclxuICogQmUgYXdhcmUgdGhhdCBhbGwgc2VsZWN0b3JzIGFmdGVyIGEgc3BhY2UgYXJlIGlnbm9yZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudHxOb2RlfSAgZWxtICAgICAgIC0gQW4gYW5jZXN0b3IgZWxlbWVudC5cclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICBzZWxlY3RvciAgLSBET01TdHJpbmcuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0VsZW1lbnR8bnVsbH0gLSBBIGZvdW5kIGVsZW1lbnQgb3IgbnVsbC5cclxuICovXG5cbmZ1bmN0aW9uIGZpbmQoZWxtLCBzZWxlY3Rvcikge1xuICByZXR1cm4gZWxtID8gZWxtLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3Iuc3BsaXQoJyAnKVswXSkgOiBudWxsO1xufVxuLyoqXHJcbiAqIEZpbmQgYSBmaXJzdCBjaGlsZCBoYXZpbmcgdGhlIGdpdmVuIHRhZyBvciBjbGFzcyBuYW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudCAgICAgICAgIC0gQSBwYXJlbnQgZWxlbWVudC5cclxuICogQHBhcmFtIHtzdHJpbmd9ICB0YWdPckNsYXNzTmFtZSAtIEEgdGFnIG9yIGNsYXNzIG5hbWUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0VsZW1lbnR8dW5kZWZpbmVkfSAtIEEgZm91bmQgZWxlbWVudCBvbiBzdWNjZXNzIG9yIHVuZGVmaW5lZCBvbiBmYWlsdXJlLlxyXG4gKi9cblxuZnVuY3Rpb24gY2hpbGQocGFyZW50LCB0YWdPckNsYXNzTmFtZSkge1xuICByZXR1cm4gY2hpbGRyZW4ocGFyZW50LCB0YWdPckNsYXNzTmFtZSlbMF07XG59XG4vKipcclxuICogUmV0dXJuIGNoaWxlIGVsZW1lbnRzIHRoYXQgbWF0Y2hlcyB0aGUgcHJvdmlkZWQgdGFnIG9yIGNsYXNzIG5hbWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50ICAgICAgICAgLSBBIHBhcmVudCBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gIHRhZ09yQ2xhc3NOYW1lIC0gQSB0YWcgb3IgY2xhc3MgbmFtZS5cclxuICpcclxuICogQHJldHVybiB7RWxlbWVudFtdfSAtIEZvdW5kIGVsZW1lbnRzLlxyXG4gKi9cblxuZnVuY3Rpb24gY2hpbGRyZW4ocGFyZW50LCB0YWdPckNsYXNzTmFtZSkge1xuICBpZiAocGFyZW50KSB7XG4gICAgcmV0dXJuIHZhbHVlcyhwYXJlbnQuY2hpbGRyZW4pLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBoYXNDbGFzcyhjaGlsZCwgdGFnT3JDbGFzc05hbWUuc3BsaXQoJyAnKVswXSkgfHwgY2hpbGQudGFnTmFtZSA9PT0gdGFnT3JDbGFzc05hbWU7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gW107XG59XG4vKipcclxuICogQ3JlYXRlIGFuIGVsZW1lbnQgd2l0aCBzb21lIG9wdGlvbmFsIGF0dHJpYnV0ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgICAtIEEgdGFnIG5hbWUuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRycyAtIEFuIG9iamVjdCBhbnkgYXR0cmlidXRlIHBhaXJzIG9mIG5hbWUgYW5kIHZhbHVlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtFbGVtZW50fSAtIEEgY3JlYXRlZCBlbGVtZW50LlxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlKHRhZywgYXR0cnMpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgZWFjaChhdHRycywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gc2V0QXR0cmlidXRlKGVsbSwga2V5LCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gZWxtO1xufVxuLyoqXHJcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gRE9NIG5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIC0gSFRNTCBzdHJpbmcuXHJcbiAqXHJcbiAqIEByZXR1cm4ge05vZGV9IC0gQSBjcmVhdGVkIG5vZGUuXHJcbiAqL1xuXG5mdW5jdGlvbiBkb21pZnkoaHRtbCkge1xuICB2YXIgZGl2ID0gY3JlYXRlKCdkaXYnLCB7fSk7XG4gIGRpdi5pbm5lckhUTUwgPSBodG1sO1xuICByZXR1cm4gZGl2LmZpcnN0Q2hpbGQ7XG59XG4vKipcclxuICogUmVtb3ZlIGEgZ2l2ZW4gZWxlbWVudCBmcm9tIGEgRE9NIHRyZWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudHxFbGVtZW50W119IGVsbXMgLSBFbGVtZW50KHMpIHRvIGJlIHJlbW92ZWQuXHJcbiAqL1xuXG5mdW5jdGlvbiBkb21fcmVtb3ZlKGVsbXMpIHtcbiAgdG9BcnJheShlbG1zKS5mb3JFYWNoKGZ1bmN0aW9uIChlbG0pIHtcbiAgICBpZiAoZWxtKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWxtLnBhcmVudEVsZW1lbnQ7XG4gICAgICBwYXJlbnQgJiYgcGFyZW50LnJlbW92ZUNoaWxkKGVsbSk7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxyXG4gKiBBcHBlbmQgYSBjaGlsZCB0byBhIGdpdmVuIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50IC0gQSBwYXJlbnQgZWxlbWVudC5cclxuICogQHBhcmFtIHtFbGVtZW50fSBjaGlsZCAgLSBBbiBlbGVtZW50IHRvIGJlIGFwcGVuZGVkLlxyXG4gKi9cblxuZnVuY3Rpb24gYXBwZW5kKHBhcmVudCwgY2hpbGQpIHtcbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH1cbn1cbi8qKlxyXG4gKiBJbnNlcnQgYW4gZWxlbWVudCBiZWZvcmUgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR8Tm9kZX0gcmVmIC0gQSByZWZlcmVuY2UgZWxlbWVudC5cclxuICogQHBhcmFtIHtFbGVtZW50fSAgICAgIGVsbSAtIEFuIGVsZW1lbnQgdG8gYmUgaW5zZXJ0ZWQuXHJcbiAqL1xuXG5mdW5jdGlvbiBiZWZvcmUoZWxtLCByZWYpIHtcbiAgaWYgKGVsbSAmJiByZWYpIHtcbiAgICB2YXIgcGFyZW50ID0gcmVmLnBhcmVudEVsZW1lbnQ7XG4gICAgcGFyZW50ICYmIHBhcmVudC5pbnNlcnRCZWZvcmUoZWxtLCByZWYpO1xuICB9XG59XG4vKipcclxuICogQXBwbHkgc3R5bGVzIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsbSAgICAgLSBBbiBlbGVtZW50IHdoZXJlIHN0eWxlcyBhcmUgYXBwbGllZC5cclxuICogQHBhcmFtIHtPYmplY3R9ICBzdHlsZXMgIC0gT2JqZWN0IGNvbnRhaW5pbmcgc3R5bGVzLlxyXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlTdHlsZShlbG0sIHN0eWxlcykge1xuICBpZiAoZWxtKSB7XG4gICAgZWFjaChzdHlsZXMsIGZ1bmN0aW9uICh2YWx1ZSwgcHJvcCkge1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGVsbS5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4vKipcclxuICogQWRkIG9yIHJlbW92ZSBjbGFzc2VzIHRvL2Zyb20gdGhlIGVsZW1lbnQuXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZm9yIGludGVybmFsIHVzYWdlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9ICAgICAgICAgZWxtICAgICAtIEFuIGVsZW1lbnQgd2hlcmUgY2xhc3NlcyBhcmUgYWRkZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBjbGFzc2VzIC0gQ2xhc3MgbmFtZXMgYmVpbmcgYWRkZWQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICByZW1vdmUgIC0gV2hldGhlciB0byByZW1vdmUgb3IgYWRkIGNsYXNzZXMuXHJcbiAqL1xuXG5mdW5jdGlvbiBhZGRPclJlbW92ZUNsYXNzZXMoZWxtLCBjbGFzc2VzLCByZW1vdmUpIHtcbiAgaWYgKGVsbSkge1xuICAgIHRvQXJyYXkoY2xhc3NlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgZWxtLmNsYXNzTGlzdFtyZW1vdmUgPyAncmVtb3ZlJyA6ICdhZGQnXShuYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuLyoqXHJcbiAqIEFkZCBjbGFzc2VzIHRvIHRoZSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9ICAgICAgICAgIGVsbSAgICAgLSBBbiBlbGVtZW50IHdoZXJlIGNsYXNzZXMgYXJlIGFkZGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gIGNsYXNzZXMgLSBDbGFzcyBuYW1lcyBiZWluZyBhZGRlZC5cclxuICovXG5cblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWxtLCBjbGFzc2VzKSB7XG4gIGFkZE9yUmVtb3ZlQ2xhc3NlcyhlbG0sIGNsYXNzZXMsIGZhbHNlKTtcbn1cbi8qKlxyXG4gKiBSZW1vdmUgYSBjbGFzcyBmcm9tIHRoZSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9ICAgICAgICAgZWxtICAgICAtIEFuIGVsZW1lbnQgd2hlcmUgY2xhc3NlcyBhcmUgcmVtb3ZlZC5cclxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGNsYXNzZXMgLSBBIGNsYXNzIG5hbWUgYmVpbmcgcmVtb3ZlZC5cclxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsbSwgY2xhc3Nlcykge1xuICBhZGRPclJlbW92ZUNsYXNzZXMoZWxtLCBjbGFzc2VzLCB0cnVlKTtcbn1cbi8qKlxyXG4gKiBWZXJpZnkgaWYgdGhlIHByb3ZpZGVkIGVsZW1lbnQgaGFzIHRoZSBjbGFzcyBvciBub3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxtICAgICAgIC0gQW4gZWxlbWVudC5cclxuICogQHBhcmFtIHtzdHJpbmd9ICBjbGFzc05hbWUgLSBBIGNsYXNzIG5hbWUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgZWxlbWVudCBoYXMgdGhlIGNsYXNzIG9yIGZhbHNlIGlmIG5vdC5cclxuICovXG5cbmZ1bmN0aW9uIGhhc0NsYXNzKGVsbSwgY2xhc3NOYW1lKSB7XG4gIHJldHVybiAhIWVsbSAmJiBlbG0uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG59XG4vKipcclxuICogU2V0IGF0dHJpYnV0ZSB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSAgICAgICAgICAgICAgICAgZWxtICAgLSBBbiBlbGVtZW50IHdoZXJlIGFuIGF0dHJpYnV0ZSBpcyBhc3NpZ25lZC5cclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgbmFtZSAgLSBBdHRyaWJ1dGUgbmFtZS5cclxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfGJvb2xlYW59ICAgdmFsdWUgLSBBdHRyaWJ1dGUgdmFsdWUuXHJcbiAqL1xuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUoZWxtLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoZWxtKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH1cbn1cbi8qKlxyXG4gKiBHZXQgYXR0cmlidXRlIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxtICAtIEFuIGVsZW1lbnQgd2hlcmUgYW4gYXR0cmlidXRlIGlzIGFzc2lnbmVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gIG5hbWUgLSBBdHRyaWJ1dGUgbmFtZS5cclxuICpcclxuICogQHJldHVybiB7c3RyaW5nfSAtIFRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gYXR0cmlidXRlIGlmIGF2YWlsYWJsZS4gQW4gZW1wdHkgc3RyaW5nIGlmIG5vdC5cclxuICovXG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZShlbG0sIG5hbWUpIHtcbiAgcmV0dXJuIGVsbSA/IGVsbS5nZXRBdHRyaWJ1dGUobmFtZSkgOiAnJztcbn1cbi8qKlxyXG4gKiBSZW1vdmUgYXR0cmlidXRlIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudHxFbGVtZW50W119IGVsbXMgIC0gQW4gZWxlbWVudCB3aGVyZSBhbiBhdHRyaWJ1dGUgaXMgcmVtb3ZlZC5cclxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119ICAgICAgbmFtZXMgLSBBdHRyaWJ1dGUgbmFtZS5cclxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZShlbG1zLCBuYW1lcykge1xuICB0b0FycmF5KG5hbWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdG9BcnJheShlbG1zKS5mb3JFYWNoKGZ1bmN0aW9uIChlbG0pIHtcbiAgICAgIHJldHVybiBlbG0gJiYgZWxtLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9KTtcbiAgfSk7XG59XG4vKipcclxuICogUmV0dXJuIHRoZSBSZWN0IG9iamVjdCBvZiB0aGUgcHJvdmlkZWQgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsbSAtIEFuIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0NsaWVudFJlY3R8RE9NUmVjdH0gLSBBIHJlY3Qgb2JqZWN0LlxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0UmVjdChlbG0pIHtcbiAgcmV0dXJuIGVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cbi8qKlxyXG4gKiBUcmlnZ2VyIHRoZSBnaXZlbiBjYWxsYmFjayBhZnRlciBhbGwgaW1hZ2VzIGNvbnRhaW5lZCBieSB0aGUgZWxlbWVudCBhcmUgbG9hZGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9ICBlbG0gICAgICAtIEVsZW1lbnQgdGhhdCBtYXkgY29udGFpbiBpbWFnZXMuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24gZmlyZWQgcmlnaHQgYWZ0ZXIgYWxsIGltYWdlcyBhcmUgbG9hZGVkLlxyXG4gKi9cblxuZnVuY3Rpb24gbG9hZGVkKGVsbSwgY2FsbGJhY2spIHtcbiAgdmFyIGltYWdlcyA9IGVsbS5xdWVyeVNlbGVjdG9yQWxsKCdpbWcnKTtcbiAgdmFyIGxlbmd0aCA9IGltYWdlcy5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCkge1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgZWFjaChpbWFnZXMsIGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgIGltZy5vbmxvYWQgPSBpbWcub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCsrY291bnQgPT09IGxlbmd0aCkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVHJpZ2dlciB0aGUgY2FsbGJhY2sgaW1tZWRpYXRlbHkgaWYgdGhlcmUgaXMgbm8gaW1hZ2UuXG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbnN0YW50cy90eXBlcy5qc1xuLyoqXHJcbiAqIEV4cG9ydCBzbGlkZXIgdHlwZXMuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuLyoqXHJcbiAqIE5vcm1hbCBzbGlkZXIuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xudmFyIFNMSURFID0gJ3NsaWRlJztcbi8qKlxyXG4gKiBMb29wIGFmdGVyIHRoZSBsYXN0IHNsaWRlIGFuZCBiZWZvcmUgdGhlIGZpcnN0IG9uZS5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG5cbnZhciBMT09QID0gJ2xvb3AnO1xuLyoqXHJcbiAqIFRoZSB0cmFjayBkb2Vzbid0IG1vdmUuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG52YXIgRkFERSA9ICdmYWRlJztcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy90cmFuc2l0aW9ucy9zbGlkZS9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGdlbmVyYWwgc2xpZGUgZWZmZWN0IHRyYW5zaXRpb24uXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgZ2VuZXJhbCBzbGlkZSBlZmZlY3QgdHJhbnNpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9IENvbXBvbmVudHMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHNsaWRlID0gKGZ1bmN0aW9uIChTcGxpZGUsIENvbXBvbmVudHMpIHtcbiAgLyoqXHJcbiAgICogSG9sZCB0aGUgbGlzdCBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge0VsZW1lbnR9XHJcbiAgICovXG4gIHZhciBsaXN0O1xuICAvKipcclxuICAgKiBIb2xkIHRoZSBvbkVuZCBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICAgKi9cblxuICB2YXIgZW5kQ2FsbGJhY2s7XG4gIHJldHVybiB7XG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICBsaXN0ID0gQ29tcG9uZW50cy5FbGVtZW50cy5saXN0O1xuICAgICAgU3BsaWRlLm9uKCd0cmFuc2l0aW9uZW5kJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBsaXN0ICYmIGVuZENhbGxiYWNrKSB7XG4gICAgICAgICAgZW5kQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfSwgbGlzdCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogU3RhcnQgdHJhbnNpdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gICBkZXN0SW5kZXggLSBEZXN0aW5hdGlvbiBzbGlkZSBpbmRleCB0aGF0IG1pZ2h0IGJlIGNsb25lJ3MuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gICBuZXdJbmRleCAgLSBOZXcgaW5kZXguXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gICBwcmV2SW5kZXggLSBQcmV2aW91cyBpbmRleC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgIGNvb3JkICAgICAtIERlc3RpbmF0aW9uIGNvb3JkaW5hdGVzLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZG9uZSAgICAgIC0gQ2FsbGJhY2sgZnVuY3Rpb24gbXVzdCBiZSBpbnZva2VkIHdoZW4gdHJhbnNpdGlvbiBpcyBjb21wbGV0ZWQuXHJcbiAgICAgKi9cbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoZGVzdEluZGV4LCBuZXdJbmRleCwgcHJldkluZGV4LCBjb29yZCwgZG9uZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcbiAgICAgIHZhciBlZGdlSW5kZXggPSBDb21wb25lbnRzLkNvbnRyb2xsZXIuZWRnZUluZGV4O1xuICAgICAgdmFyIHNwZWVkID0gb3B0aW9ucy5zcGVlZDtcbiAgICAgIGVuZENhbGxiYWNrID0gZG9uZTtcblxuICAgICAgaWYgKFNwbGlkZS5pcyhTTElERSkpIHtcbiAgICAgICAgaWYgKHByZXZJbmRleCA9PT0gMCAmJiBuZXdJbmRleCA+PSBlZGdlSW5kZXggfHwgcHJldkluZGV4ID49IGVkZ2VJbmRleCAmJiBuZXdJbmRleCA9PT0gMCkge1xuICAgICAgICAgIHNwZWVkID0gb3B0aW9ucy5yZXdpbmRTcGVlZCB8fCBzcGVlZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhcHBseVN0eWxlKGxpc3QsIHtcbiAgICAgICAgdHJhbnNpdGlvbjogXCJ0cmFuc2Zvcm0gXCIgKyBzcGVlZCArIFwibXMgXCIgKyBvcHRpb25zLmVhc2luZyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIGNvb3JkLnggKyBcInB4LFwiICsgY29vcmQueSArIFwicHgpXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL3RyYW5zaXRpb25zL2ZhZGUvaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBmYWRlIHRyYW5zaXRpb24uXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgZmFkZSB0cmFuc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlICAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gQ29tcG9uZW50cyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgZmFkZSA9IChmdW5jdGlvbiAoU3BsaWRlLCBDb21wb25lbnRzKSB7XG4gIHZhciBGYWRlID0ge1xuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICogQXBwbHkgdHJhbnNpdGlvbiBzdHlsZSB0byB0aGUgZmlyc3Qgc2xpZGUuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICBhcHBseShTcGxpZGUuaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFN0YXJ0IHRyYW5zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICAgIGRlc3RJbmRleCAtIERlc3RpbmF0aW9uIHNsaWRlIGluZGV4IHRoYXQgbWlnaHQgYmUgY2xvbmUncy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgICBuZXdJbmRleCAgLSBOZXcgaW5kZXguXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gICAgcHJldkluZGV4IC0gUHJldmlvdXMgaW5kZXguXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgY29vcmQgICAgIC0gRGVzdGluYXRpb24gY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSAgZG9uZSAgICAgIC0gQ2FsbGJhY2sgZnVuY3Rpb24gbXVzdCBiZSBpbnZva2VkIHdoZW4gdHJhbnNpdGlvbiBpcyBjb21wbGV0ZWQuXHJcbiAgICAgKi9cbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoZGVzdEluZGV4LCBuZXdJbmRleCwgcHJldkluZGV4LCBjb29yZCwgZG9uZSkge1xuICAgICAgdmFyIHRyYWNrID0gQ29tcG9uZW50cy5FbGVtZW50cy50cmFjaztcbiAgICAgIGFwcGx5U3R5bGUodHJhY2ssIHtcbiAgICAgICAgaGVpZ2h0OiB1bml0KHRyYWNrLmNsaWVudEhlaWdodClcbiAgICAgIH0pO1xuICAgICAgYXBwbHkobmV3SW5kZXgpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgYXBwbHlTdHlsZSh0cmFjaywge1xuICAgICAgICAgIGhlaWdodDogJydcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEFwcGx5IHRyYW5zaXRpb24gc3R5bGUgdG8gdGhlIHNsaWRlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gaW5kZXguXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBBIHNsaWRlIGluZGV4LlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFwcGx5KGluZGV4KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcbiAgICBhcHBseVN0eWxlKENvbXBvbmVudHMuRWxlbWVudHMuc2xpZGVzW2luZGV4XSwge1xuICAgICAgdHJhbnNpdGlvbjogXCJvcGFjaXR5IFwiICsgb3B0aW9ucy5zcGVlZCArIFwibXMgXCIgKyBvcHRpb25zLmVhc2luZ1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIEZhZGU7XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy90cmFuc2l0aW9ucy9pbmRleC5qc1xuLyoqXHJcbiAqIEV4cG9ydCB0cmFuc2l0aW9uIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29yZS9jb21wb3Nlci5qc1xuLyoqXHJcbiAqIFByb3ZpZGUgYSBmdW5jdGlvbiBmb3IgY29tcG9zaW5nIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG5cbi8qKlxyXG4gKiBDb21wb3NlIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSAgIFNwbGlkZSAgICAgLSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIENvbXBvbmVudHMgLSBBZGRpdGlvbmFsIGNvbXBvbmVudHMuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFRyYW5zaXRpb24gLSBDaGFuZ2UgY29tcG9uZW50IGZvciB0cmFuc2l0aW9uLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGNvbXBvbmVudHMuXHJcbiAqL1xuXG5mdW5jdGlvbiBjb21wb3NlKFNwbGlkZSwgQ29tcG9uZW50cywgVHJhbnNpdGlvbikge1xuICB2YXIgY29tcG9uZW50cyA9IHt9O1xuICBlYWNoKENvbXBvbmVudHMsIGZ1bmN0aW9uIChDb21wb25lbnQsIG5hbWUpIHtcbiAgICBjb21wb25lbnRzW25hbWVdID0gQ29tcG9uZW50KFNwbGlkZSwgY29tcG9uZW50cywgbmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfSk7XG5cbiAgaWYgKCFUcmFuc2l0aW9uKSB7XG4gICAgVHJhbnNpdGlvbiA9IFNwbGlkZS5pcyhGQURFKSA/IGZhZGUgOiBzbGlkZTtcbiAgfVxuXG4gIGNvbXBvbmVudHMuVHJhbnNpdGlvbiA9IFRyYW5zaXRpb24oU3BsaWRlLCBjb21wb25lbnRzKTtcbiAgcmV0dXJuIGNvbXBvbmVudHM7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvdXRpbHMvZXJyb3IuanNcbi8qKlxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igb3V0cHV0dGluZyBsb2dzLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cbi8qKlxyXG4gKiBQcmVmaXggb2YgYW4gZXJyb3IgbWFzc2FnZS5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG52YXIgTUVTU0FHRV9QUkVGSVggPSAnW1NQTElERV0nO1xuLyoqXHJcbiAqIERpc3BsYXkgYW4gZXJyb3IgbWVzc2FnZSBvbiB0aGUgYnJvd3NlciBjb25zb2xlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEFuIGVycm9yIG1lc3NhZ2UuXHJcbiAqL1xuXG5mdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gIGNvbnNvbGUuZXJyb3IoTUVTU0FHRV9QUkVGSVggKyBcIiBcIiArIG1lc3NhZ2UpO1xufVxuLyoqXHJcbiAqIENoZWNrIGV4aXN0ZW5jZSBvZiB0aGUgZ2l2ZW4gb2JqZWN0IGFuZCB0aHJvdyBhbiBlcnJvciBpZiBpdCBkb2Vzbid0LlxyXG4gKlxyXG4gKiBAdGhyb3dzIHtFcnJvcn1cclxuICpcclxuICogQHBhcmFtIHsqfSAgICAgIHN1YmplY3QgLSBBIHN1YmplY3QgdG8gYmUgY29uZmlybWVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEFuIGVycm9yIG1lc3NhZ2UuXHJcbiAqL1xuXG5mdW5jdGlvbiBleGlzdChzdWJqZWN0LCBtZXNzYWdlKSB7XG4gIGlmICghc3ViamVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbnN0YW50cy9jbGFzc2VzLmpzXG4vKipcclxuICogRXhwb3J0IGNsYXNzIG5hbWVzLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cbi8qKlxyXG4gKiBBIHJvb3QgY2xhc3MgbmFtZS5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG52YXIgUk9PVCA9ICdzcGxpZGUnO1xuLyoqXHJcbiAqIFRoZSBkZWZpbml0aW9uIHRhYmxlIG9mIGFsbCBjbGFzc2VzIGZvciBlbGVtZW50cy5cclxuICogVGhleSBtaWdodCBiZSBtb2RpZmllZCBieSBvcHRpb25zLlxyXG4gKlxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cblxudmFyIEVMRU1FTlRfQ0xBU1NFUyA9IHtcbiAgcm9vdDogUk9PVCxcbiAgc2xpZGVyOiBST09UICsgXCJfX3NsaWRlclwiLFxuICB0cmFjazogUk9PVCArIFwiX190cmFja1wiLFxuICBsaXN0OiBST09UICsgXCJfX2xpc3RcIixcbiAgc2xpZGU6IFJPT1QgKyBcIl9fc2xpZGVcIixcbiAgY29udGFpbmVyOiBST09UICsgXCJfX3NsaWRlX19jb250YWluZXJcIixcbiAgYXJyb3dzOiBST09UICsgXCJfX2Fycm93c1wiLFxuICBhcnJvdzogUk9PVCArIFwiX19hcnJvd1wiLFxuICBwcmV2OiBST09UICsgXCJfX2Fycm93LS1wcmV2XCIsXG4gIG5leHQ6IFJPT1QgKyBcIl9fYXJyb3ctLW5leHRcIixcbiAgcGFnaW5hdGlvbjogUk9PVCArIFwiX19wYWdpbmF0aW9uXCIsXG4gIHBhZ2U6IFJPT1QgKyBcIl9fcGFnaW5hdGlvbl9fcGFnZVwiLFxuICBjbG9uZTogUk9PVCArIFwiX19zbGlkZS0tY2xvbmVcIixcbiAgcHJvZ3Jlc3M6IFJPT1QgKyBcIl9fcHJvZ3Jlc3NcIixcbiAgYmFyOiBST09UICsgXCJfX3Byb2dyZXNzX19iYXJcIixcbiAgYXV0b3BsYXk6IFJPT1QgKyBcIl9fYXV0b3BsYXlcIixcbiAgcGxheTogUk9PVCArIFwiX19wbGF5XCIsXG4gIHBhdXNlOiBST09UICsgXCJfX3BhdXNlXCIsXG4gIHNwaW5uZXI6IFJPT1QgKyBcIl9fc3Bpbm5lclwiLFxuICBzcjogUk9PVCArIFwiX19zclwiXG59O1xuLyoqXHJcbiAqIERlZmluaXRpb25zIG9mIHN0YXR1cyBjbGFzc2VzLlxyXG4gKlxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cblxudmFyIFNUQVRVU19DTEFTU0VTID0ge1xuICBhY3RpdmU6ICdpcy1hY3RpdmUnLFxuICB2aXNpYmxlOiAnaXMtdmlzaWJsZScsXG4gIGxvYWRpbmc6ICdpcy1sb2FkaW5nJ1xufTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb25zdGFudHMvaTE4bi5qc1xuLyoqXHJcbiAqIEV4cG9ydCBpMThuIHRleHRzIGFzIG9iamVjdC5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG4vKipcclxuICogVGV4dHMgZm9yIGkxOG4uXHJcbiAqXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xudmFyIEkxOE4gPSB7XG4gIHByZXY6ICdQcmV2aW91cyBzbGlkZScsXG4gIG5leHQ6ICdOZXh0IHNsaWRlJyxcbiAgZmlyc3Q6ICdHbyB0byBmaXJzdCBzbGlkZScsXG4gIGxhc3Q6ICdHbyB0byBsYXN0IHNsaWRlJyxcbiAgc2xpZGVYOiAnR28gdG8gc2xpZGUgJXMnLFxuICBwYWdlWDogJ0dvIHRvIHBhZ2UgJXMnLFxuICBwbGF5OiAnU3RhcnQgYXV0b3BsYXknLFxuICBwYXVzZTogJ1BhdXNlIGF1dG9wbGF5J1xufTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb25zdGFudHMvZGVmYXVsdHMuanNcbi8qKlxyXG4gKiBFeHBvcnQgZGVmYXVsdCBvcHRpb25zLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxudmFyIERFRkFVTFRTID0ge1xuICAvKipcclxuICAgKiBEZXRlcm1pbmUgYSBzbGlkZXIgdHlwZS5cclxuICAgKiAtICdzbGlkZSc6IFJlZ3VsYXIgc2xpZGVyLlxyXG4gICAqIC0gJ2xvb3AnIDogQ2Fyb3VzZWwgc2xpZGVyLlxyXG4gICAqIC0gJ2ZhZGUnIDogQ2hhbmdlIHNsaWRlcyB3aXRoIGZhZGUgdHJhbnNpdGlvbi4gcGVyUGFnZSwgZHJhZyBvcHRpb25zIGFyZSBpZ25vcmVkLlxyXG4gICAqXHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKi9cbiAgdHlwZTogJ3NsaWRlJyxcblxuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIHJld2luZCBhIHNsaWRlciBiZWZvcmUgdGhlIGZpcnN0IHNsaWRlIG9yIGFmdGVyIHRoZSBsYXN0IG9uZS5cclxuICAgKiBJbiBcImxvb3BcIiBtb2RlLCB0aGlzIG9wdGlvbiBpcyBpZ25vcmVkLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIHJld2luZDogZmFsc2UsXG5cbiAgLyoqXHJcbiAgICogVHJhbnNpdGlvbiBzcGVlZCBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICBzcGVlZDogNDAwLFxuXG4gIC8qKlxyXG4gICAqIFRyYW5zaXRpb24gc3BlZWQgb24gcmV3aW5kIGluIG1pbGxpc2Vjb25kcy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIHJld2luZFNwZWVkOiAwLFxuXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gcHJldmVudCBhbnkgYWN0aW9ucyB3aGlsZSBhIHNsaWRlciBpcyB0cmFuc2l0aW9uaW5nLlxyXG4gICAqIElmIGZhbHNlLCBuYXZpZ2F0aW9uLCBkcmFnIGFuZCBzd2lwZSB3b3JrIHdoaWxlIHRoZSBzbGlkZXIgaXMgcnVubmluZy5cclxuICAgKiBFdmVuIHNvLCBpdCB3aWxsIGJlIGZvcmNlZCB0byB3YWl0IGZvciB0cmFuc2l0aW9uIGluIHNvbWUgY2FzZXMgaW4gdGhlIGxvb3AgbW9kZSB0byBzaGlmdCBhIHNsaWRlci5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICB3YWl0Rm9yVHJhbnNpdGlvbjogdHJ1ZSxcblxuICAvKipcclxuICAgKiBEZWZpbmUgc2xpZGVyIG1heCB3aWR0aC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIHdpZHRoOiAwLFxuXG4gIC8qKlxyXG4gICAqIERlZmluZSBzbGlkZXIgaGVpZ2h0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgaGVpZ2h0OiAwLFxuXG4gIC8qKlxyXG4gICAqIEZpeCB3aWR0aCBvZiBzbGlkZXMuIENTUyBmb3JtYXQgaXMgYWxsb3dlZCBzdWNoIGFzIDEwZW0sIDgwJSBvciA4MHZ3LlxyXG4gICAqIHBlclBhZ2UgbnVtYmVyIHdpbGwgYmUgaWdub3JlZCB3aGVuIHRoaXMgb3B0aW9uIGlzIGZhbHN5LlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcnxzdHJpbmd9XHJcbiAgICovXG4gIGZpeGVkV2lkdGg6IDAsXG5cbiAgLyoqXHJcbiAgICogRml4IGhlaWdodCBvZiBzbGlkZXMuIENTUyBmb3JtYXQgaXMgYWxsb3dlZCBzdWNoIGFzIDEwZW0sIDgwdmggYnV0ICUgdW5pdCBpcyBub3QgYWNjZXB0ZWQuXHJcbiAgICogaGVpZ2h0UmF0aW8gb3B0aW9uIHdpbGwgYmUgaWdub3JlZCB3aGVuIHRoaXMgb3B0aW9uIGlzIGZhbHN5LlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcnxzdHJpbmd9XHJcbiAgICovXG4gIGZpeGVkSGVpZ2h0OiAwLFxuXG4gIC8qKlxyXG4gICAqIERldGVybWluZSBoZWlnaHQgb2Ygc2xpZGVzIGJ5IHJhdGlvIHRvIGEgc2xpZGVyIHdpZHRoLlxyXG4gICAqIFRoaXMgd2lsbCBiZSBpZ25vcmVkIHdoZW4gdGhlIGZpeGVkSGVpZ2h0IGlzIHByb3ZpZGVkLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgaGVpZ2h0UmF0aW86IDAsXG5cbiAgLyoqXHJcbiAgICogSWYgdHJ1ZSwgc2xpZGUgd2lkdGggd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IHRoZSBlbGVtZW50IHdpZHRoIGl0c2VsZi5cclxuICAgKiAtIHBlclBhZ2UvcGVyTW92ZSBzaG91bGQgYmUgMS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICBhdXRvV2lkdGg6IGZhbHNlLFxuXG4gIC8qKlxyXG4gICAqIElmIHRydWUsIHNsaWRlIGhlaWdodCB3aWxsIGJlIGRldGVybWluZWQgYnkgdGhlIGVsZW1lbnQgd2lkdGggaXRzZWxmLlxyXG4gICAqIC0gcGVyUGFnZS9wZXJNb3ZlIHNob3VsZCBiZSAxLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIGF1dG9IZWlnaHQ6IGZhbHNlLFxuXG4gIC8qKlxyXG4gICAqIERldGVybWluZSBob3cgbWFueSBzbGlkZXMgc2hvdWxkIGJlIGRpc3BsYXllZCBwZXIgcGFnZS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIHBlclBhZ2U6IDEsXG5cbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lIGhvdyBtYW55IHNsaWRlcyBzaG91bGQgYmUgbW92ZWQgd2hlbiBhIHNsaWRlciBnb2VzIHRvIG5leHQgb3IgcGVydi5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIHBlck1vdmU6IDAsXG5cbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lIG1hbnVhbGx5IGhvdyBtYW55IGNsb25lcyBzaG91bGQgYmUgZ2VuZXJhdGVkIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlLlxyXG4gICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgY2xvbmVzIHdpbGwgYmUgdHdpY2Ugb2YgdGhpcyBudW1iZXIuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICBjbG9uZXM6IDAsXG5cbiAgLyoqXHJcbiAgICogU3RhcnQgaW5kZXguXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICBzdGFydDogMCxcblxuICAvKipcclxuICAgKiBEZXRlcm1pbmUgd2hpY2ggc2xpZGUgc2hvdWxkIGJlIGZvY3VzZWQgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHNsaWRlcyBpbiBhIHBhZ2UuXHJcbiAgICogQSBzdHJpbmcgXCJjZW50ZXJcIiBpcyBhY2NlcHRhYmxlIGZvciBjZW50ZXJpbmcgc2xpZGVzLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW58bnVtYmVyfHN0cmluZ31cclxuICAgKi9cbiAgZm9jdXM6IGZhbHNlLFxuXG4gIC8qKlxyXG4gICAqIEdhcCBiZXR3ZWVuIHNsaWRlcy4gQ1NTIGZvcm1hdCBpcyBhbGxvd2VkIHN1Y2ggYXMgMWVtLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcnxzdHJpbmd9XHJcbiAgICovXG4gIGdhcDogMCxcblxuICAvKipcclxuICAgKiBTZXQgcGFkZGluZy1sZWZ0L3JpZ2h0IGluIGhvcml6b250YWwgbW9kZSBvciBwYWRkaW5nLXRvcC9ib3R0b20gaW4gdmVydGljYWwgb25lLlxyXG4gICAqIEdpdmUgYSBzaW5nbGUgdmFsdWUgdG8gc2V0IGEgc2FtZSBzaXplIGZvciBib3RoIHNpZGVzIG9yXHJcbiAgICogZG8gYW4gb2JqZWN0IGZvciBkaWZmZXJlbnQgc2l6ZXMuXHJcbiAgICogQWxzbywgQ1NTIGZvcm1hdCBpcyBhbGxvd2VkIHN1Y2ggYXMgMWVtLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiAtIDEwOiBOdW1iZXJcclxuICAgKiAtICcxZW0nOiBDU1MgZm9ybWF0LlxyXG4gICAqIC0geyBsZWZ0OiAwLCByaWdodDogMjAgfTogT2JqZWN0IGZvciBkaWZmZXJlbnQgc2l6ZXMgaW4gaG9yaXpvbnRhbCBtb2RlLlxyXG4gICAqIC0geyB0b3A6IDAsIGJvdHRvbTogMjAgfTogT2JqZWN0IGZvciBkaWZmZXJlbnQgc2l6ZXMgaW4gdmVydGljYWwgbW9kZS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ8c3RyaW5nfE9iamVjdH1cclxuICAgKi9cbiAgcGFkZGluZzogMCxcblxuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIGFwcGVuZCBhcnJvd3MuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgYXJyb3dzOiB0cnVlLFxuXG4gIC8qKlxyXG4gICAqIENoYW5nZSB0aGUgYXJyb3cgU1ZHIHBhdGggbGlrZSAnbTcuNjEgMC44MDctMi4xMi4uLicuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xuICBhcnJvd1BhdGg6ICcnLFxuXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gYXBwZW5kIHBhZ2luYXRpb24oaW5kaWNhdG9yIGRvdHMpIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICBwYWdpbmF0aW9uOiB0cnVlLFxuXG4gIC8qKlxyXG4gICAqIEFjdGl2YXRlIGF1dG9wbGF5LlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIGF1dG9wbGF5OiBmYWxzZSxcblxuICAvKipcclxuICAgKiBBdXRvcGxheSBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICBpbnRlcnZhbDogNTAwMCxcblxuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIHN0b3AgYXV0b3BsYXkgd2hlbiBhIHNsaWRlciBpcyBob3ZlcmVkLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIHBhdXNlT25Ib3ZlcjogdHJ1ZSxcblxuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIHN0b3AgYXV0b3BsYXkgd2hlbiBhIHNsaWRlciBlbGVtZW50cyBhcmUgZm9jdXNlZC5cclxuICAgKiBUcnVlIGlzIHJlY29tbWVuZGVkIGZvciBhY2Nlc3NpYmlsaXR5LlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIHBhdXNlT25Gb2N1czogdHJ1ZSxcblxuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIHJlc2V0IHByb2dyZXNzIG9mIHRoZSBhdXRvcGxheSB0aW1lciB3aGVuIHJlc3VtZWQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgcmVzZXRQcm9ncmVzczogdHJ1ZSxcblxuICAvKipcclxuICAgKiBMb2FkaW5nIGltYWdlcyBsYXppbHkuXHJcbiAgICogSW1hZ2Ugc3JjIG11c3QgYmUgcHJvdmlkZWQgYnkgYSBkYXRhLXNwbGlkZS1sYXp5IGF0dHJpYnV0ZS5cclxuICAgKlxyXG4gICAqIC0gZmFsc2U6IERvIG5vdGhpbmcuXHJcbiAgICogLSAnbmVhcmJ5JzogT25seSBpbWFnZXMgYXJvdW5kIGFuIGFjdGl2ZSBzbGlkZSB3aWxsIGJlIGxvYWRlZC5cclxuICAgKiAtICdzZXF1ZW50aWFsJzogQWxsIGltYWdlcyB3aWxsIGJlIHNlcXVlbnRpYWxseSBsb2FkZWQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbnxzdHJpbmd9XHJcbiAgICovXG4gIGxhenlMb2FkOiBmYWxzZSxcblxuICAvKipcclxuICAgKiBUaGlzIG9wdGlvbiB3b3JrcyBvbmx5IHdoZW4gYSBsYXp5TG9hZCBvcHRpb24gaXMgXCJuZWFyYnlcIi5cclxuICAgKiBEZXRlcm1pbmUgaG93IG1hbnkgcGFnZXMobm90IHNsaWRlcykgYXJvdW5kIGFuIGFjdGl2ZSBzbGlkZSBzaG91bGQgYmUgbG9hZGVkIGJlZm9yZWhhbmQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICBwcmVsb2FkUGFnZXM6IDEsXG5cbiAgLyoqXHJcbiAgICogRWFzaW5nIGZvciBDU1MgdHJhbnNpdGlvbi4gRm9yIGV4YW1wbGUsIGxpbmVhciwgZWFzZSBvciBjdWJpYy1iZXppZXIoKS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICovXG4gIGVhc2luZzogJ2N1YmljLWJlemllciguNDIsLjY1LC4yNywuOTkpJyxcblxuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBrZXlib2FyZCBzaG9ydGN1dHNcclxuICAgKiAtIHRydWUgb3IgJ2dsb2JhbCc6IExpc3RlbiB0byBrZXlkb3duIGV2ZW50IG9mIHRoZSBkb2N1bWVudC5cclxuICAgKiAtICdmb2N1c2VkJzogTGlzdGVuIHRvIHRoZSBrZXlkb3duIGV2ZW50IG9mIHRoZSBzbGlkZXIgcm9vdCBlbGVtZW50LiB0YWJpbmRleD1cIjBcIiB3aWxsIGJlIGFkZGVkIHRvIHRoZSBlbGVtZW50LlxyXG4gICAqIC0gZmFsc2U6IERpc2FibGUga2V5Ym9hcmQgc2hvcnRjdXRzLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW58c3RyaW5nfVxyXG4gICAqL1xuICBrZXlib2FyZDogJ2dsb2JhbCcsXG5cbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBhbGxvdyBtb3VzZSBkcmFnIGFuZCB0b3VjaCBzd2lwZS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICBkcmFnOiB0cnVlLFxuXG4gIC8qKlxyXG4gICAqIFRoZSBhbmdsZSB0aHJlc2hvbGQgZm9yIGRyYWcuXHJcbiAgICogVGhlIHNsaWRlciBzdGFydHMgbW92aW5nIG9ubHkgd2hlbiB0aGUgZHJhZyBhbmdsZSBpcyBsZXNzIHRoYW4gdGhpcyB0aHJlc2hvbGQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICBkcmFnQW5nbGVUaHJlc2hvbGQ6IDMwLFxuXG4gIC8qKlxyXG4gICAqIERpc3RhbmNlIHRocmVzaG9sZCBmb3IgZGV0ZXJtaW5pbmcgaWYgdGhlIGFjdGlvbiBpcyBcImZsaWNrXCIgb3IgXCJzd2lwZVwiLlxyXG4gICAqIFdoZW4gYSBkcmFnIGRpc3RhbmNlIGlzIG92ZXIgdGhpcyB2YWx1ZSwgdGhlIGFjdGlvbiB3aWxsIGJlIHRyZWF0ZWQgYXMgXCJzd2lwZVwiLCBub3QgXCJmbGlja1wiLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgc3dpcGVEaXN0YW5jZVRocmVzaG9sZDogMTUwLFxuXG4gIC8qKlxyXG4gICAqIFZlbG9jaXR5IHRocmVzaG9sZCBmb3IgZGV0ZXJtaW5pbmcgaWYgdGhlIGFjdGlvbiBpcyBcImZsaWNrXCIgb3IgXCJzd2lwZVwiLlxyXG4gICAqIEFyb3VuZCAwLjUgaXMgcmVjb21tZW5kZWQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICBmbGlja1ZlbG9jaXR5VGhyZXNob2xkOiAuNixcblxuICAvKipcclxuICAgKiBEZXRlcm1pbmUgcG93ZXIgb2YgZmxpY2suIFRoZSBsYXJnZXIgbnVtYmVyIHRoaXMgaXMsIHRoZSBmYXJ0aGVyIGEgc2xpZGVyIHJ1bnMgYnkgZmxpY2suXHJcbiAgICogQXJvdW5kIDUwMCBpcyByZWNvbW1lbmRlZC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIGZsaWNrUG93ZXI6IDYwMCxcblxuICAvKipcclxuICAgKiBMaW1pdCBhIG51bWJlciBvZiBwYWdlcyB0byBtb3ZlIGJ5IGZsaWNrLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgZmxpY2tNYXhQYWdlczogMSxcblxuICAvKipcclxuICAgKiBTbGlkZXIgZGlyZWN0aW9uLlxyXG4gICAqIC0gJ2x0cic6IExlZnQgdG8gcmlnaHQuXHJcbiAgICogLSAncnRsJzogUmlnaHQgdG8gbGVmdC5cclxuICAgKiAtICd0dGInOiBUb3AgdG8gYm90dG9tLlxyXG4gICAqXHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKi9cbiAgZGlyZWN0aW9uOiAnbHRyJyxcblxuICAvKipcclxuICAgKiBTZXQgaW1nIHNyYyB0byBiYWNrZ3JvdW5kLWltYWdlIG9mIGl0cyBwYXJlbnQgZWxlbWVudC5cclxuICAgKiBJbWFnZXMgd2l0aCB2YXJpb3VzIHNpemVzIGNhbiBiZSBkaXNwbGF5ZWQgYXMgc2FtZSBkaW1lbnNpb24gd2l0aG91dCBjcm9wcGluZyB3b3JrLlxyXG4gICAqIGZpeGVkSGVpZ2h0IG9yIGhlaWdodFJhdGlvIGlzIHJlcXVpcmVkLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIGNvdmVyOiBmYWxzZSxcblxuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBhY2Nlc3NpYmlsaXR5KGFyaWEgYW5kIHNjcmVlbiByZWFkZXIgdGV4dHMpIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICBhY2Nlc3NpYmlsaXR5OiB0cnVlLFxuXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gYWRkIHRhYmluZGV4PVwiMFwiIHRvIHZpc2libGUgc2xpZGVzIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICBzbGlkZUZvY3VzOiB0cnVlLFxuXG4gIC8qKlxyXG4gICAqIERldGVybWluZSBpZiBhIHNsaWRlciBpcyBuYXZpZ2F0aW9uIGZvciBhbm90aGVyLlxyXG4gICAqIFVzZSBcInN5bmNcIiBBUEkgdG8gc3luY2hyb25pemUgdHdvIHNsaWRlcnMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgaXNOYXZpZ2F0aW9uOiBmYWxzZSxcblxuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIHRyaW0gc3BhY2VzIGJlZm9yZSB0aGUgZmlzdCBzbGlkZSBvciBhZnRlciB0aGUgbGFzdCBvbmUgd2hlbiBcImZvY3VzXCIgaXMgbm90IDAuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgdHJpbVNwYWNlOiB0cnVlLFxuXG4gIC8qKlxyXG4gICAqIFRoZSBcImlzLWFjdGl2ZVwiIGNsYXNzIGlzIGFkZGVkIGFmdGVyIHRyYW5zaXRpb24gYXMgZGVmYXVsdC5cclxuICAgKiBJZiB0cnVlLCBpdCB3aWxsIGJlIGFkZGVkIGJlZm9yZSBtb3ZlLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIHVwZGF0ZU9uTW92ZTogZmFsc2UsXG5cbiAgLyoqXHJcbiAgICogVGhyb3R0bGUgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgcmVzaXplIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgdGhyb3R0bGU6IDEwMCxcblxuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIGRlc3Ryb3kgYSBzbGlkZXIgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIGRlc3Ryb3k6IGZhbHNlLFxuXG4gIC8qKlxyXG4gICAqIE9wdGlvbnMgZm9yIHNwZWNpZmljIGJyZWFrcG9pbnRzLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiB7XHJcbiAgICogICAxMDAwOiB7XHJcbiAgICogICAgIHBlclBhZ2U6IDMsXHJcbiAgICogICAgIGdhcDogMjBcclxuICAgKiAgIH0sXHJcbiAgICogICA2MDA6IHtcclxuICAgKiAgICAgcGVyUGFnZTogMSxcclxuICAgKiAgICAgZ2FwOiA1LFxyXG4gICAqICAgfVxyXG4gICAqIH1cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufE9iamVjdH1cclxuICAgKi9cbiAgYnJlYWtwb2ludHM6IGZhbHNlLFxuXG4gIC8qKlxyXG4gICAqIENvbGxlY3Rpb24gb2YgY2xhc3MgbmFtZXMuXHJcbiAgICpcclxuICAgKiBAc2VlIC4vY2xhc3Nlcy5qc1xyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cbiAgY2xhc3NlczogRUxFTUVOVF9DTEFTU0VTLFxuXG4gIC8qKlxyXG4gICAqIENvbGxlY3Rpb24gb2YgaTE4biB0ZXh0cy5cclxuICAgKlxyXG4gICAqIEBzZWUgLi9pMThuLmpzXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuICBpMThuOiBJMThOXG59O1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbnN0YW50cy9zdGF0ZXMuanNcbi8qKlxyXG4gKiBFeHBvcnQgc3RhdGUgY29uc3RhbnRzLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cbi8qKlxyXG4gKiBTcGxpZGUgaGFzIGJlZW4ganVzdCBjcmVhdGVkLlxyXG4gKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKi9cbnZhciBDUkVBVEVEID0gMTtcbi8qKlxyXG4gKiBBbGwgY29tcG9uZW50cyBoYXZlIGJlZW4gbW91bnRlZCBhbmQgaW5pdGlhbGl6ZWQuXHJcbiAqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqL1xuXG52YXIgTU9VTlRFRCA9IDI7XG4vKipcclxuICogU3BsaWRlIGlzIHJlYWR5IGZvciB0cmFuc2l0aW9uLlxyXG4gKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKi9cblxudmFyIElETEUgPSAzO1xuLyoqXHJcbiAqIFNwbGlkZSBpcyBtb3ZpbmcuXHJcbiAqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqL1xuXG52YXIgTU9WSU5HID0gNDtcbi8qKlxyXG4gKiBTcGxpZGUgaXMgbW92aW5nLlxyXG4gKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKi9cblxudmFyIERFU1RST1lFRCA9IDU7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvc3BsaWRlLmpzXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8qKlxyXG4gKiBUaGUgbWFpbiBjbGFzcyBmb3IgYXBwbHlpbmcgU3BsaWRlIHRvIGFuIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG5cblxuXG5cblxuXG4vKipcclxuICogVGhlIG1haW4gY2xhc3MgZm9yIGFwcGx5aW5nIFNwbGlkZSB0byBhbiBlbGVtZW50LFxyXG4gKiBwcm92aWRpbmcgc29tZSBBUElzIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yLlxyXG4gKi9cblxudmFyIFNwbGlkZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIFNwbGlkZSBjb25zdHJ1Y3Rvci5cclxuICAgKlxyXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBXaGVuIHRoZSBnaXZlbiByb290IGVsZW1lbnQgb3Igc2VsZWN0b3IgaXMgaW52YWxpZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9ICByb290ICAgICAgIC0gQSBzZWxlY3RvciBmb3IgYSByb290IGVsZW1lbnQgb3IgYW4gZWxlbWVudCBpdHNlbGYuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgIG9wdGlvbnMgICAgLSBPcHRpb25hbC4gT3B0aW9ucyB0byBjaGFuZ2UgZGVmYXVsdCBiZWhhdmlvdXIuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgIENvbXBvbmVudHMgLSBPcHRpb25hbC4gQ29tcG9uZW50cy5cclxuICAgKi9cbiAgZnVuY3Rpb24gU3BsaWRlKHJvb3QsIG9wdGlvbnMsIENvbXBvbmVudHMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKENvbXBvbmVudHMgPT09IHZvaWQgMCkge1xuICAgICAgQ29tcG9uZW50cyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMucm9vdCA9IHJvb3QgaW5zdGFuY2VvZiBFbGVtZW50ID8gcm9vdCA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iocm9vdCk7XG4gICAgZXhpc3QodGhpcy5yb290LCAnQW4gaW52YWxpZCBlbGVtZW50L3NlbGVjdG9yIHdhcyBnaXZlbi4nKTtcbiAgICB0aGlzLkNvbXBvbmVudHMgPSBudWxsO1xuICAgIHRoaXMuRXZlbnQgPSBjb3JlX2V2ZW50KCk7XG4gICAgdGhpcy5TdGF0ZSA9IHN0YXRlKENSRUFURUQpO1xuICAgIHRoaXMuU1RBVEVTID0gc3RhdGVzX25hbWVzcGFjZU9iamVjdDtcbiAgICB0aGlzLl9vID0gbWVyZ2UoREVGQVVMVFMsIG9wdGlvbnMpO1xuICAgIHRoaXMuX2kgPSAwO1xuICAgIHRoaXMuX2MgPSBDb21wb25lbnRzO1xuICAgIHRoaXMuX2UgPSB7fTsgLy8gRXh0ZW5zaW9uc1xuXG4gICAgdGhpcy5fdCA9IG51bGw7IC8vIFRyYW5zaXRpb25cbiAgfVxuICAvKipcclxuICAgKiBDb21wb3NlIGFuZCBtb3VudCBjb21wb25lbnRzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9ICAgRXh0ZW5zaW9ucyAtIE9wdGlvbmFsLiBBZGRpdGlvbmFsIGNvbXBvbmVudHMuXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gVHJhbnNpdGlvbiAtIE9wdGlvbmFsLiBTZXQgYSBjdXN0b20gdHJhbnNpdGlvbiBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtTcGxpZGV8dW5kZWZpbmVkfSAtIFRoaXMgaW5zdGFuY2Ugb3IgdW5kZWZpbmVkIGlmIGFuIGV4Y2VwdGlvbiBvY2N1cnJlZC5cclxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBTcGxpZGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5tb3VudCA9IGZ1bmN0aW9uIG1vdW50KEV4dGVuc2lvbnMsIFRyYW5zaXRpb24pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKEV4dGVuc2lvbnMgPT09IHZvaWQgMCkge1xuICAgICAgRXh0ZW5zaW9ucyA9IHRoaXMuX2U7XG4gICAgfVxuXG4gICAgaWYgKFRyYW5zaXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgVHJhbnNpdGlvbiA9IHRoaXMuX3Q7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgdGhlIHN0YXRlLlxuICAgIHRoaXMuU3RhdGUuc2V0KENSRUFURUQpO1xuICAgIHRoaXMuX2UgPSBFeHRlbnNpb25zO1xuICAgIHRoaXMuX3QgPSBUcmFuc2l0aW9uO1xuICAgIHRoaXMuQ29tcG9uZW50cyA9IGNvbXBvc2UodGhpcywgbWVyZ2UodGhpcy5fYywgRXh0ZW5zaW9ucyksIFRyYW5zaXRpb24pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGVhY2godGhpcy5Db21wb25lbnRzLCBmdW5jdGlvbiAoY29tcG9uZW50LCBrZXkpIHtcbiAgICAgICAgdmFyIHJlcXVpcmVkID0gY29tcG9uZW50LnJlcXVpcmVkO1xuXG4gICAgICAgIGlmIChyZXF1aXJlZCA9PT0gdW5kZWZpbmVkIHx8IHJlcXVpcmVkKSB7XG4gICAgICAgICAgY29tcG9uZW50Lm1vdW50ICYmIGNvbXBvbmVudC5tb3VudCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBfdGhpcy5Db21wb25lbnRzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yKGUubWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIFN0YXRlID0gdGhpcy5TdGF0ZTtcbiAgICBTdGF0ZS5zZXQoTU9VTlRFRCk7XG4gICAgZWFjaCh0aGlzLkNvbXBvbmVudHMsIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIGNvbXBvbmVudC5tb3VudGVkICYmIGNvbXBvbmVudC5tb3VudGVkKCk7XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KCdtb3VudGVkJyk7XG4gICAgU3RhdGUuc2V0KElETEUpO1xuICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICBhcHBseVN0eWxlKHRoaXMucm9vdCwge1xuICAgICAgdmlzaWJpbGl0eTogJ3Zpc2libGUnXG4gICAgfSk7XG4gICAgdGhpcy5vbignbW92ZSBkcmFnJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFN0YXRlLnNldChNT1ZJTkcpO1xuICAgIH0pLm9uKCdtb3ZlZCBkcmFnZ2VkJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFN0YXRlLnNldChJRExFKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBTZXQgc3luYyB0YXJnZXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1NwbGlkZX0gc3BsaWRlIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtTcGxpZGV9IC0gVGhpcyBpbnN0YW5jZS5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zeW5jID0gZnVuY3Rpb24gc3luYyhzcGxpZGUpIHtcbiAgICB0aGlzLnNpYmxpbmcgPSBzcGxpZGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVnaXN0ZXIgY2FsbGJhY2sgZmlyZWQgb24gdGhlIGdpdmVuIGV2ZW50KHMpLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgZXZlbnRzICAtIEFuIGV2ZW50IG5hbWUuIFVzZSBzcGFjZSB0byBzZXBhcmF0ZSBtdWx0aXBsZSBldmVudHMuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsc28sIG5hbWVzcGFjZSBpcyBhY2NlcHRlZCBieSBkb3QsIHN1Y2ggYXMgJ3Jlc2l6ZS57bmFtZXNwYWNlfScuXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIEEgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSAgZWxtICAgICAtIE9wdGlvbmFsLiBOYXRpdmUgZXZlbnQgd2lsbCBiZSBsaXN0ZW5lZCB0byB3aGVuIHRoaXMgYXJnIGlzIHByb3ZpZGVkLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnMgLSBPcHRpb25hbC4gT3B0aW9ucyBmb3IgYWRkRXZlbnRMaXN0ZW5lci5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1NwbGlkZX0gLSBUaGlzIGluc3RhbmNlLlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uID0gZnVuY3Rpb24gb24oZXZlbnRzLCBoYW5kbGVyLCBlbG0sIG9wdGlvbnMpIHtcbiAgICBpZiAoZWxtID09PSB2b2lkIDApIHtcbiAgICAgIGVsbSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMuRXZlbnQub24oZXZlbnRzLCBoYW5kbGVyLCBlbG0sIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIFVuc3Vic2NyaWJlIHRoZSBnaXZlbiBldmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgZXZlbnRzIC0gQSBldmVudCBuYW1lLlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxtICAgIC0gT3B0aW9uYWwuIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoaXMgYXJnIGlzIHByb3ZpZGVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7U3BsaWRlfSAtIFRoaXMgaW5zdGFuY2UuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ub2ZmID0gZnVuY3Rpb24gb2ZmKGV2ZW50cywgZWxtKSB7XG4gICAgaWYgKGVsbSA9PT0gdm9pZCAwKSB7XG4gICAgICBlbG0gPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuRXZlbnQub2ZmKGV2ZW50cywgZWxtKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBFbWl0IGFuIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gQW4gZXZlbnQgbmFtZS5cclxuICAgKiBAcGFyYW0geyp9ICAgICAgYXJncyAgLSBBbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyBwYXNzZWQgdG8gaGFuZGxlcnMuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMkRXZlbnQ7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICAoX3RoaXMkRXZlbnQgPSB0aGlzLkV2ZW50KS5lbWl0LmFwcGx5KF90aGlzJEV2ZW50LCBbZXZlbnRdLmNvbmNhdChhcmdzKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBHbyB0byB0aGUgc2xpZGUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBjb250cm9sLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBjb250cm9sIC0gQSBjb250cm9sIHBhdHRlcm4uXHJcbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICB3YWl0ICAgIC0gT3B0aW9uYWwuIFdoZXRoZXIgdG8gd2FpdCBmb3IgdHJhbnNpdGlvbi5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nbyA9IGZ1bmN0aW9uIGdvKGNvbnRyb2wsIHdhaXQpIHtcbiAgICBpZiAod2FpdCA9PT0gdm9pZCAwKSB7XG4gICAgICB3YWl0ID0gdGhpcy5vcHRpb25zLndhaXRGb3JUcmFuc2l0aW9uO1xuICAgIH1cblxuICAgIGlmICh0aGlzLlN0YXRlLmlzKElETEUpIHx8IHRoaXMuU3RhdGUuaXMoTU9WSU5HKSAmJiAhd2FpdCkge1xuICAgICAgdGhpcy5Db21wb25lbnRzLkNvbnRyb2xsZXIuZ28oY29udHJvbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIFZlcmlmeSB3aGV0aGVyIHRoZSBzbGlkZXIgdHlwZSBpcyB0aGUgZ2l2ZW4gb25lIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gQSBzbGlkZXIgdHlwZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgc2xpZGVyIHR5cGUgaXMgdGhlIHByb3ZpZGVkIHR5cGUgb3IgZmFsc2UgaWYgbm90LlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmlzID0gZnVuY3Rpb24gaXModHlwZSkge1xuICAgIHJldHVybiB0eXBlID09PSB0aGlzLl9vLnR5cGU7XG4gIH1cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgc2xpZGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBzbGlkZSAtIEEgc2xpZGUgZWxlbWVudCB0byBiZSBhZGRlZC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gICAgICAgICBpbmRleCAtIEEgc2xpZGUgd2lsbCBiZSBhZGRlZCBhdCB0aGUgcG9zaXRpb24uXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKHNsaWRlLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICBpbmRleCA9IC0xO1xuICAgIH1cblxuICAgIHRoaXMuQ29tcG9uZW50cy5FbGVtZW50cy5hZGQoc2xpZGUsIGluZGV4LCB0aGlzLnJlZnJlc2guYmluZCh0aGlzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVtb3ZlIHRoZSBzbGlkZSBkZXNpZ25hdGVkIGJ5IHRoZSBpbmRleC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIEEgc2xpZGUgaW5kZXguXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGluZGV4KSB7XG4gICAgdGhpcy5Db21wb25lbnRzLkVsZW1lbnRzLnJlbW92ZShpbmRleCk7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogRGVzdHJveSBhbGwgU2xpZGUgb2JqZWN0cyBhbmQgY2xvbmVzIGFuZCByZWNyZWF0ZSB0aGVtIGFnYWluLlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlZnJlc2ggPSBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgIHRoaXMuZW1pdCgncmVmcmVzaDpiZWZvcmUnKS5lbWl0KCdyZWZyZXNoJykuZW1pdCgncmVzaXplJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogRGVzdHJveSB0aGUgU3BsaWRlLlxyXG4gICAqIFwiQ29tcGxldGVseVwiIGJvb2xlYW4gaXMgbWFpbmx5IGZvciBicmVha3BvaW50cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcGxldGVseSAtIERlc3Ryb3kgY29tcGxldGVseS5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveShjb21wbGV0ZWx5KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAoY29tcGxldGVseSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb21wbGV0ZWx5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBQb3N0cG9uZSBkZXN0cm95IGJlY2F1c2UgaXQgc2hvdWxkIGJlIGRvbmUgYWZ0ZXIgbW91bnQuXG4gICAgaWYgKHRoaXMuU3RhdGUuaXMoQ1JFQVRFRCkpIHtcbiAgICAgIHRoaXMub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmRlc3Ryb3koY29tcGxldGVseSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YWx1ZXModGhpcy5Db21wb25lbnRzKS5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICBjb21wb25lbnQuZGVzdHJveSAmJiBjb21wb25lbnQuZGVzdHJveShjb21wbGV0ZWx5KTtcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knLCBjb21wbGV0ZWx5KTsgLy8gRGVzdHJveSBhbGwgZXZlbnQgaGFuZGxlcnMsIGluY2x1ZGluZyBvbmVzIGZvciBuYXRpdmUgZXZlbnRzLlxuXG4gICAgdGhpcy5FdmVudC5kZXN0cm95KCk7XG4gICAgdGhpcy5TdGF0ZS5zZXQoREVTVFJPWUVEKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgc2xpZGUgaW5kZXguXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIGN1cnJlbnQgc2xpZGUgaW5kZXguXHJcbiAgIC8vICovXG4gIDtcblxuICBfY3JlYXRlQ2xhc3MoU3BsaWRlLCBbe1xuICAgIGtleTogXCJpbmRleFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2k7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjdXJyZW50IHNsaWRlIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gaW5kZXggLSBBIG5ldyBpbmRleC5cclxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbmRleCkge1xuICAgICAgdGhpcy5faSA9IHBhcnNlSW50KGluZGV4KTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gbGVuZ3RoIG9mIHNsaWRlcy5cclxuICAgICAqIFRoaXMgaXMgYW4gYWxpYXMgb2YgRWxlbWVudHMubGVuZ3RoLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBBIG51bWJlciBvZiBzbGlkZXMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxlbmd0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuQ29tcG9uZW50cy5FbGVtZW50cy5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIG9wdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAtIE9wdGlvbnMgb2JqZWN0LlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvcHRpb25zXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTZXQgb3B0aW9ucyB3aXRoIG1lcmdpbmcgdGhlIGdpdmVuIG9iamVjdCB0byB0aGUgY3VycmVudCBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBOZXcgb3B0aW9ucy5cclxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChvcHRpb25zKSB7XG4gICAgICB2YXIgY3JlYXRlZCA9IHRoaXMuU3RhdGUuaXMoQ1JFQVRFRCk7XG5cbiAgICAgIGlmICghY3JlYXRlZCkge1xuICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vID0gbWVyZ2UodGhpcy5fbywgb3B0aW9ucyk7XG5cbiAgICAgIGlmICghY3JlYXRlZCkge1xuICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZWQnLCB0aGlzLl9vKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGNsYXNzIGxpc3QuXHJcbiAgICAgKiBUaGlzIGlzIGFuIGFsaWFzIG9mIFNwbGlkZS5vcHRpb25zLmNsYXNzTGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGNsYXNzIGxpc3QuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsYXNzZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vLmNsYXNzZXM7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBpMThuIHN0cmluZ3MuXHJcbiAgICAgKiBUaGlzIGlzIGFuIGFsaWFzIG9mIFNwbGlkZS5vcHRpb25zLmkxOG4uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAtIEFuIG9iamVjdCBjb250YWluaW5nIGFsbCBpMThuIHN0cmluZ3MuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImkxOG5cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vLmkxOG47XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNwbGlkZTtcbn0oKTtcblxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9vcHRpb25zL2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgaW5pdGlhbGl6aW5nIG9wdGlvbnMuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG5cbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBpbml0aWFsaXppbmcgb3B0aW9ucy5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG9wdGlvbnMgPSAoZnVuY3Rpb24gKFNwbGlkZSkge1xuICAvKipcclxuICAgKiBSZXRyaWV2ZSBvcHRpb25zIGZyb20gdGhlIGRhdGEgYXR0cmlidXRlLlxyXG4gICAqIE5vdGUgdGhhdCBJRTEwIGRvZXNuJ3Qgc3VwcG9ydCBkYXRhc2V0IHByb3BlcnR5LlxyXG4gICAqXHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKi9cbiAgdmFyIG9wdGlvbnMgPSBnZXRBdHRyaWJ1dGUoU3BsaWRlLnJvb3QsICdkYXRhLXNwbGlkZScpO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIFNwbGlkZS5vcHRpb25zID0gSlNPTi5wYXJzZShvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcihlLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICBpZiAoU3BsaWRlLlN0YXRlLmlzKENSRUFURUQpKSB7XG4gICAgICAgIFNwbGlkZS5pbmRleCA9IFNwbGlkZS5vcHRpb25zLnN0YXJ0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbnN0YW50cy9kaXJlY3Rpb25zLmpzXG4vKipcclxuICogRXhwb3J0IGxheW91dCBtb2Rlcy5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG4vKipcclxuICogRW51bWVyYXRlIHNsaWRlcyBmcm9tIGxlZnQgdG8gcmlnaHQuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xudmFyIExUUiA9ICdsdHInO1xuLyoqXHJcbiAqIEVudW1lcmF0ZSBzbGlkZXMgZnJvbSByaWdodCB0byBsZWZ0LlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxudmFyIFJUTCA9ICdydGwnO1xuLyoqXHJcbiAqIEVudW1lcmF0ZSBzbGlkZXMgaW4gYSBjb2wuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG52YXIgVFRCID0gJ3R0Yic7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9lbGVtZW50cy9zbGlkZS5qc1xuLyoqXHJcbiAqIFRoZSBzdWIgY29tcG9uZW50IGZvciBoYW5kbGluZyBlYWNoIHNsaWRlLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuXG5cblxuXG4vKipcclxuICogRXZlbnRzIGZvciByZXN0b3Jpbmcgb3JpZ2luYWwgc3R5bGVzLlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxudmFyIFNUWUxFX1JFU1RPUkVfRVZFTlRTID0gJ3VwZGF0ZS5zbGlkZSc7XG4vKipcclxuICogVGhlIHN1YiBjb21wb25lbnQgZm9yIGhhbmRsaW5nIGVhY2ggc2xpZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSAgU3BsaWRlICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSAgaW5kZXggICAgIC0gQW4gdW5pcXVlIHNsaWRlIGluZGV4LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gIHJlYWxJbmRleCAtIENsb25lcyBzaG91bGQgcGFzcyBhIHJlYWwgc2xpZGUgaW5kZXguXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gc2xpZGUgICAgIC0gQSBzbGlkZSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIHN1YiBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBlbGVtZW50c19zbGlkZSA9IChmdW5jdGlvbiAoU3BsaWRlLCBpbmRleCwgcmVhbEluZGV4LCBzbGlkZSkge1xuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIHVwZGF0ZSBcImlzLWFjdGl2ZVwiIGNsYXNzIGJlZm9yZSBvciBhZnRlciB0cmFuc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIHZhciB1cGRhdGVPbk1vdmUgPSBTcGxpZGUub3B0aW9ucy51cGRhdGVPbk1vdmU7XG4gIC8qKlxyXG4gICAqIEV2ZW50cyB3aGVuIHRoZSBzbGlkZSBzdGF0dXMgaXMgdXBkYXRlZC5cclxuICAgKiBBcHBlbmQgYSBuYW1lc3BhY2UgdG8gcmVtb3ZlIGxpc3RlbmVycyBsYXRlci5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICovXG5cbiAgdmFyIFNUQVRVU19VUERBVEVfRVZFTlRTID0gJ3JlYWR5LnNsaWRlIHVwZGF0ZWQuc2xpZGUgcmVzaXplZC5zbGlkZSBtb3ZlZC5zbGlkZScgKyAodXBkYXRlT25Nb3ZlID8gJyBtb3ZlLnNsaWRlJyA6ICcnKTtcbiAgLyoqXHJcbiAgICogU2xpZGUgc3ViIGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBTbGlkZSA9IHtcbiAgICAvKipcclxuICAgICAqIFNsaWRlIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge0VsZW1lbnR9XHJcbiAgICAgKi9cbiAgICBzbGlkZTogc2xpZGUsXG5cbiAgICAvKipcclxuICAgICAqIFNsaWRlIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cbiAgICBpbmRleDogaW5kZXgsXG5cbiAgICAvKipcclxuICAgICAqIFJlYWwgaW5kZXggZm9yIGNsb25lcy5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXG4gICAgcmVhbEluZGV4OiByZWFsSW5kZXgsXG5cbiAgICAvKipcclxuICAgICAqIENvbnRhaW5lciBlbGVtZW50IGlmIGF2YWlsYWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7RWxlbWVudHx1bmRlZmluZWR9XHJcbiAgICAgKi9cbiAgICBjb250YWluZXI6IGNoaWxkKHNsaWRlLCBTcGxpZGUuY2xhc3Nlcy5jb250YWluZXIpLFxuXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgaXMgYSBjbG9uZWQgc2xpZGUgb3Igbm90LlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXG4gICAgaXNDbG9uZTogcmVhbEluZGV4ID4gLTEsXG5cbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5pc0Nsb25lKSB7XG4gICAgICAgIHNsaWRlLmlkID0gU3BsaWRlLnJvb3QuaWQgKyBcIi1zbGlkZVwiICsgcGFkKGluZGV4ICsgMSk7XG4gICAgICB9XG5cbiAgICAgIFNwbGlkZS5vbihTVEFUVVNfVVBEQVRFX0VWRU5UUywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMudXBkYXRlKCk7XG4gICAgICB9KS5vbihTVFlMRV9SRVNUT1JFX0VWRU5UUywgcmVzdG9yZVN0eWxlcykub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gU3BsaWRlLmVtaXQoJ2NsaWNrJywgX3RoaXMpO1xuICAgICAgfSwgc2xpZGUpO1xuICAgICAgLypcclxuICAgICAgICogQWRkIFwiaXMtYWN0aXZlXCIgY2xhc3MgdG8gYSBjbG9uZSBlbGVtZW50IHRlbXBvcmFyaWx5XHJcbiAgICAgICAqIGFuZCBpdCB3aWxsIGJlIHJlbW92ZWQgb24gXCJtb3ZlZFwiIGV2ZW50LlxyXG4gICAgICAgKi9cblxuICAgICAgaWYgKHVwZGF0ZU9uTW92ZSkge1xuICAgICAgICBTcGxpZGUub24oJ21vdmUuc2xpZGUnLCBmdW5jdGlvbiAobmV3SW5kZXgpIHtcbiAgICAgICAgICBpZiAobmV3SW5kZXggPT09IHJlYWxJbmRleCkge1xuICAgICAgICAgICAgX3VwZGF0ZSh0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gTWFrZSBzdXJlIHRoZSBzbGlkZSBpcyBzaG93bi5cblxuXG4gICAgICBhcHBseVN0eWxlKHNsaWRlLCB7XG4gICAgICAgIGRpc3BsYXk6ICcnXG4gICAgICB9KTsgLy8gSG9sZCB0aGUgb3JpZ2luYWwgc3R5bGVzLlxuXG4gICAgICB0aGlzLnN0eWxlcyA9IGdldEF0dHJpYnV0ZShzbGlkZSwgJ3N0eWxlJykgfHwgJyc7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveS5cclxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBTcGxpZGUub2ZmKFNUQVRVU19VUERBVEVfRVZFTlRTKS5vZmYoU1RZTEVfUkVTVE9SRV9FVkVOVFMpLm9mZignY2xpY2snLCBzbGlkZSk7XG4gICAgICByZW1vdmVDbGFzcyhzbGlkZSwgdmFsdWVzKFNUQVRVU19DTEFTU0VTKSk7XG4gICAgICByZXN0b3JlU3R5bGVzKCk7XG4gICAgICByZW1vdmVBdHRyaWJ1dGUodGhpcy5jb250YWluZXIsICdzdHlsZScpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBhY3RpdmUgYW5kIHZpc2libGUgc3RhdHVzLlxyXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICBfdXBkYXRlKHRoaXMuaXNBY3RpdmUoKSwgZmFsc2UpO1xuXG4gICAgICBfdXBkYXRlKHRoaXMuaXNWaXNpYmxlKCksIHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhpcyBzbGlkZSBpcyBhY3RpdmUgb3Igbm90LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgc2xpZGUgaXMgYWN0aXZlIG9yIGZhbHNlIGlmIG5vdC5cclxuICAgICAqL1xuICAgIGlzQWN0aXZlOiBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICAgIHJldHVybiBTcGxpZGUuaW5kZXggPT09IGluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhpcyBzbGlkZSBpcyB2aXNpYmxlIGluIHRoZSB2aWV3cG9ydCBvciBub3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBzbGlkZSBpcyB2aXNpYmxlIG9yIGZhbHNlIGlmIG5vdC5cclxuICAgICAqL1xuICAgIGlzVmlzaWJsZTogZnVuY3Rpb24gaXNWaXNpYmxlKCkge1xuICAgICAgdmFyIGFjdGl2ZSA9IHRoaXMuaXNBY3RpdmUoKTtcblxuICAgICAgaWYgKFNwbGlkZS5pcyhGQURFKSB8fCBhY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNlaWwgPSBNYXRoLmNlaWw7XG4gICAgICB2YXIgdHJhY2tSZWN0ID0gZ2V0UmVjdChTcGxpZGUuQ29tcG9uZW50cy5FbGVtZW50cy50cmFjayk7XG4gICAgICB2YXIgc2xpZGVSZWN0ID0gZ2V0UmVjdChzbGlkZSk7XG5cbiAgICAgIGlmIChTcGxpZGUub3B0aW9ucy5kaXJlY3Rpb24gPT09IFRUQikge1xuICAgICAgICByZXR1cm4gdHJhY2tSZWN0LnRvcCA8PSBzbGlkZVJlY3QudG9wICYmIHNsaWRlUmVjdC5ib3R0b20gPD0gY2VpbCh0cmFja1JlY3QuYm90dG9tKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRyYWNrUmVjdC5sZWZ0IDw9IHNsaWRlUmVjdC5sZWZ0ICYmIHNsaWRlUmVjdC5yaWdodCA8PSBjZWlsKHRyYWNrUmVjdC5yaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIGhvdyBmYXIgdGhpcyBzbGlkZSBpcyBmcm9tIGFub3RoZXIgc2xpZGUgYW5kXHJcbiAgICAgKiByZXR1cm4gdHJ1ZSBpZiB0aGUgZGlzdGFuY2UgaXMgd2l0aGluIHRoZSBnaXZlbiBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZyb20gICAtIEluZGV4IG9mIGEgdGFyZ2V0IHNsaWRlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpdGhpbiAtIFRydWUgaWYgdGhlIHNsaWRlIGlzIHdpdGhpbiB0aGlzIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIHNsaWRlIGlzIHdpdGhpbiB0aGUgbnVtYmVyIG9yIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqL1xuICAgIGlzV2l0aGluOiBmdW5jdGlvbiBpc1dpdGhpbihmcm9tLCB3aXRoaW4pIHtcbiAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoZnJvbSAtIGluZGV4KTtcblxuICAgICAgaWYgKCFTcGxpZGUuaXMoU0xJREUpICYmICF0aGlzLmlzQ2xvbmUpIHtcbiAgICAgICAgZGlmZiA9IE1hdGgubWluKGRpZmYsIFNwbGlkZS5sZW5ndGggLSBkaWZmKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpZmYgPCB3aXRoaW47XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUgY2xhc3NlcyBmb3IgYWN0aXZpdHkgb3IgdmlzaWJpbGl0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWN0aXZlICAgICAgICAtIElzIGFjdGl2ZS92aXNpYmxlIG9yIG5vdC5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvclZpc2liaWxpdHkgLSBUb2dnbGUgY2xhc3NlcyBmb3IgYWN0aXZpdHkgb3IgdmlzaWJpbGl0eS5cclxuICAgKi9cblxuICBmdW5jdGlvbiBfdXBkYXRlKGFjdGl2ZSwgZm9yVmlzaWJpbGl0eSkge1xuICAgIHZhciB0eXBlID0gZm9yVmlzaWJpbGl0eSA/ICd2aXNpYmxlJyA6ICdhY3RpdmUnO1xuICAgIHZhciBjbGFzc05hbWUgPSBTVEFUVVNfQ0xBU1NFU1t0eXBlXTtcblxuICAgIGlmIChhY3RpdmUpIHtcbiAgICAgIGFkZENsYXNzKHNsaWRlLCBjbGFzc05hbWUpO1xuICAgICAgU3BsaWRlLmVtaXQoXCJcIiArIHR5cGUsIFNsaWRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhc0NsYXNzKHNsaWRlLCBjbGFzc05hbWUpKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKHNsaWRlLCBjbGFzc05hbWUpO1xuICAgICAgICBTcGxpZGUuZW1pdChcIlwiICsgKGZvclZpc2liaWxpdHkgPyAnaGlkZGVuJyA6ICdpbmFjdGl2ZScpLCBTbGlkZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHN0eWxlcy5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVTdHlsZXMoKSB7XG4gICAgc2V0QXR0cmlidXRlKHNsaWRlLCAnc3R5bGUnLCBTbGlkZS5zdHlsZXMpO1xuICB9XG5cbiAgcmV0dXJuIFNsaWRlO1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9lbGVtZW50cy9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIG1haW4gZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG5cblxuXG4vKipcclxuICogVGhlIHByb3BlcnR5IG5hbWUgZm9yIFVJRCBzdG9yZWQgaW4gYSB3aW5kb3cgb2JqZWN0LlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxudmFyIFVJRF9OQU1FID0gJ3VpZCc7XG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgbWFpbiBlbGVtZW50cy5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9IENvbXBvbmVudHMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbXBvbmVudHNfZWxlbWVudHMgPSAoZnVuY3Rpb24gKFNwbGlkZSwgQ29tcG9uZW50cykge1xuICAvKipcclxuICAgKiBIb2xkIHRoZSByb290IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7RWxlbWVudH1cclxuICAgKi9cbiAgdmFyIHJvb3QgPSBTcGxpZGUucm9vdDtcbiAgLyoqXHJcbiAgICogSG9sZCB0aGUgY2xhc3MgbGlzdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIGNsYXNzZXMgPSBTcGxpZGUuY2xhc3NlcztcbiAgLyoqXHJcbiAgICogU3RvcmUgU2xpZGUgb2JqZWN0cy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtBcnJheX1cclxuICAgKi9cblxuICB2YXIgU2xpZGVzID0gW107XG4gIC8qXHJcbiAgICogQXNzaWduIHVuaXF1ZSBJRCB0byB0aGUgcm9vdCBlbGVtZW50IGlmIGl0IGRvZXNuJ3QgaGF2ZSB0aGUgb25lLlxyXG4gICAqIE5vdGUgdGhhdCBJRSBkb2Vzbid0IHN1cHBvcnQgcGFkU3RhcnQoKSB0byBmaWxsIHRoZSB1aWQgYnkgMC5cclxuICAgKi9cblxuICBpZiAoIXJvb3QuaWQpIHtcbiAgICB3aW5kb3cuc3BsaWRlID0gd2luZG93LnNwbGlkZSB8fCB7fTtcbiAgICB2YXIgdWlkID0gd2luZG93LnNwbGlkZVtVSURfTkFNRV0gfHwgMDtcbiAgICB3aW5kb3cuc3BsaWRlW1VJRF9OQU1FXSA9ICsrdWlkO1xuICAgIHJvb3QuaWQgPSBcInNwbGlkZVwiICsgcGFkKHVpZCk7XG4gIH1cbiAgLyoqXHJcbiAgICogRWxlbWVudHMgY29tcG9uZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cblxuICB2YXIgRWxlbWVudHMgPSB7XG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKiBDb2xsZWN0IG1haW4gZWxlbWVudHMgYW5kIHN0b3JlIHRoZW0gYXMgbWVtYmVyIHByb3BlcnRpZXMuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmluaXQoKTtcbiAgICAgIFNwbGlkZS5vbigncmVmcmVzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuZGVzdHJveSgpO1xuXG4gICAgICAgIF90aGlzLmluaXQoKTtcbiAgICAgIH0pLm9uKCd1cGRhdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVDbGFzcyhyb290LCBnZXRDbGFzc2VzKCkpO1xuICAgICAgICBhZGRDbGFzcyhyb290LCBnZXRDbGFzc2VzKCkpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveS5cclxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBTbGlkZXMuZm9yRWFjaChmdW5jdGlvbiAoU2xpZGUpIHtcbiAgICAgICAgU2xpZGUuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgICBTbGlkZXMgPSBbXTtcbiAgICAgIHJlbW92ZUNsYXNzKHJvb3QsIGdldENsYXNzZXMoKSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6YXRpb24uXHJcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGNvbGxlY3QoKTtcbiAgICAgIGFkZENsYXNzKHJvb3QsIGdldENsYXNzZXMoKSk7XG4gICAgICB0aGlzLnNsaWRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzbGlkZSwgaW5kZXgpIHtcbiAgICAgICAgX3RoaXMyLnJlZ2lzdGVyKHNsaWRlLCBpbmRleCwgLTEpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXIgYSBzbGlkZSB0byBjcmVhdGUgYSBTbGlkZSBvYmplY3QgYW5kIGhhbmRsZSBpdHMgYmVoYXZpb3IuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBzbGlkZSAgICAgLSBBIHNsaWRlIGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gIGluZGV4ICAgICAtIEEgdW5pcXVlIGluZGV4LiBUaGlzIGNhbiBiZSBuZWdhdGl2ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgcmVhbEluZGV4IC0gQSByZWFsIGluZGV4IGZvciBjbG9uZXMuIFNldCAtMSBmb3IgcmVhbCBzbGlkZXMuXHJcbiAgICAgKi9cbiAgICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoc2xpZGUsIGluZGV4LCByZWFsSW5kZXgpIHtcbiAgICAgIHZhciBTbGlkZU9iamVjdCA9IGVsZW1lbnRzX3NsaWRlKFNwbGlkZSwgaW5kZXgsIHJlYWxJbmRleCwgc2xpZGUpO1xuICAgICAgU2xpZGVPYmplY3QubW91bnQoKTtcbiAgICAgIFNsaWRlcy5wdXNoKFNsaWRlT2JqZWN0KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIFNsaWRlIG9iamVjdCBkZXNpZ25hdGVkIGJ5IHRoZSBpbmRleC5cclxuICAgICAqIE5vdGUgdGhhdCBcImZpbmRcIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IC0gQSBTbGlkZSBvYmplY3QgaWYgYXZhaWxhYmxlLiBVbmRlZmluZWQgaWYgbm90LlxyXG4gICAgICovXG4gICAgZ2V0U2xpZGU6IGZ1bmN0aW9uIGdldFNsaWRlKGluZGV4KSB7XG4gICAgICByZXR1cm4gU2xpZGVzLmZpbHRlcihmdW5jdGlvbiAoU2xpZGUpIHtcbiAgICAgICAgcmV0dXJuIFNsaWRlLmluZGV4ID09PSBpbmRleDtcbiAgICAgIH0pWzBdO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiBhbGwgU2xpZGUgb2JqZWN0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVDbG9uZXMgLSBXaGV0aGVyIHRvIGluY2x1ZGUgY2xvbmVkIHNsaWRlcyBvciBub3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0W119IC0gU2xpZGUgb2JqZWN0cy5cclxuICAgICAqL1xuICAgIGdldFNsaWRlczogZnVuY3Rpb24gZ2V0U2xpZGVzKGluY2x1ZGVDbG9uZXMpIHtcbiAgICAgIHJldHVybiBpbmNsdWRlQ2xvbmVzID8gU2xpZGVzIDogU2xpZGVzLmZpbHRlcihmdW5jdGlvbiAoU2xpZGUpIHtcbiAgICAgICAgcmV0dXJuICFTbGlkZS5pc0Nsb25lO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFNsaWRlIG9iamVjdHMgYmVsb25naW5nIHRvIHRoZSBnaXZlbiBwYWdlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYWdlIC0gQSBwYWdlIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gLSBBbiBhcnJheSBjb250YWluaW5nIFNsaWRlIG9iamVjdHMuXHJcbiAgICAgKi9cbiAgICBnZXRTbGlkZXNCeVBhZ2U6IGZ1bmN0aW9uIGdldFNsaWRlc0J5UGFnZShwYWdlKSB7XG4gICAgICB2YXIgaWR4ID0gQ29tcG9uZW50cy5Db250cm9sbGVyLnRvSW5kZXgocGFnZSk7XG4gICAgICB2YXIgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuICAgICAgdmFyIG1heCA9IG9wdGlvbnMuZm9jdXMgIT09IGZhbHNlID8gMSA6IG9wdGlvbnMucGVyUGFnZTtcbiAgICAgIHJldHVybiBTbGlkZXMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBpbmRleCA9IF9yZWYuaW5kZXg7XG4gICAgICAgIHJldHVybiBpZHggPD0gaW5kZXggJiYgaW5kZXggPCBpZHggKyBtYXg7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnQgYSBzbGlkZSB0byBhIHNsaWRlci5cclxuICAgICAqIE5lZWQgdG8gcmVmcmVzaCBTcGxpZGUgYWZ0ZXIgYWRkaW5nIGEgc2xpZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOb2RlfHN0cmluZ30gc2xpZGUgICAgLSBBIHNsaWRlIGVsZW1lbnQgdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gICAgICBpbmRleCAgICAtIEEgc2xpZGUgd2lsbCBiZSBhZGRlZCBhdCB0aGUgcG9zaXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICBjYWxsYmFjayAtIENhbGxlZCByaWdodCBhZnRlciB0aGUgc2xpZGUgaXMgYWRkZWQgdG8gdGhlIERPTSB0cmVlLlxyXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbiBhZGQoc2xpZGUsIGluZGV4LCBjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBzbGlkZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc2xpZGUgPSBkb21pZnkoc2xpZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2xpZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzLnNsaWRlc1tpbmRleF07IC8vIFRoaXMgd2lsbCBiZSByZW1vdmVkIGluIG1vdW50KCkgb2YgYSBTbGlkZSBjb21wb25lbnQuXG5cbiAgICAgICAgYXBwbHlTdHlsZShzbGlkZSwge1xuICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgYmVmb3JlKHNsaWRlLCByZWYpO1xuICAgICAgICAgIHRoaXMuc2xpZGVzLnNwbGljZShpbmRleCwgMCwgc2xpZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFwcGVuZCh0aGlzLmxpc3QsIHNsaWRlKTtcbiAgICAgICAgICB0aGlzLnNsaWRlcy5wdXNoKHNsaWRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvYWRlZChzbGlkZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHNsaWRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGEgc2xpZGUgZnJvbSBhIHNsaWRlci5cclxuICAgICAqIE5lZWQgdG8gcmVmcmVzaCBTcGxpZGUgYWZ0ZXIgcmVtb3ZpbmcgYSBzbGlkZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBTbGlkZSBpbmRleC5cclxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGluZGV4KSB7XG4gICAgICBkb21fcmVtb3ZlKHRoaXMuc2xpZGVzLnNwbGljZShpbmRleCwgMSlbMF0pO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFRyaWdnZXIgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZvciBlYWNoIFNsaWRlIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24uIFRoZSBmaXJzdCBhcmd1bWVudCB3aWxsIGJlIHRoZSBTbGlkZSBvYmplY3QuXHJcbiAgICAgKi9cbiAgICBlYWNoOiBmdW5jdGlvbiBlYWNoKGNhbGxiYWNrKSB7XG4gICAgICBTbGlkZXMuZm9yRWFjaChjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHNsaWRlcyBsZW5ndGggd2l0aG91dCBjbG9uZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIFNsaWRlIGxlbmd0aC5cclxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zbGlkZXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiBcIlNsaWRlT2JqZWN0c1wiIGxlbmd0aCBpbmNsdWRpbmcgY2xvbmVzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBTbGlkZSBsZW5ndGggaW5jbHVkaW5nIGNsb25lcy5cclxuICAgICAqL1xuICAgIGdldCB0b3RhbCgpIHtcbiAgICAgIHJldHVybiBTbGlkZXMubGVuZ3RoO1xuICAgIH1cblxuICB9O1xuICAvKipcclxuICAgKiBDb2xsZWN0IGVsZW1lbnRzLlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3QoKSB7XG4gICAgRWxlbWVudHMuc2xpZGVyID0gY2hpbGQocm9vdCwgY2xhc3Nlcy5zbGlkZXIpO1xuICAgIEVsZW1lbnRzLnRyYWNrID0gZmluZChyb290LCBcIi5cIiArIGNsYXNzZXMudHJhY2spO1xuICAgIEVsZW1lbnRzLmxpc3QgPSBjaGlsZChFbGVtZW50cy50cmFjaywgY2xhc3Nlcy5saXN0KTtcbiAgICBleGlzdChFbGVtZW50cy50cmFjayAmJiBFbGVtZW50cy5saXN0LCAnVHJhY2sgb3IgbGlzdCB3YXMgbm90IGZvdW5kLicpO1xuICAgIEVsZW1lbnRzLnNsaWRlcyA9IGNoaWxkcmVuKEVsZW1lbnRzLmxpc3QsIGNsYXNzZXMuc2xpZGUpO1xuICAgIHZhciBhcnJvd3MgPSBmaW5kUGFydHMoY2xhc3Nlcy5hcnJvd3MpO1xuICAgIEVsZW1lbnRzLmFycm93cyA9IHtcbiAgICAgIHByZXY6IGZpbmQoYXJyb3dzLCBcIi5cIiArIGNsYXNzZXMucHJldiksXG4gICAgICBuZXh0OiBmaW5kKGFycm93cywgXCIuXCIgKyBjbGFzc2VzLm5leHQpXG4gICAgfTtcbiAgICB2YXIgYXV0b3BsYXkgPSBmaW5kUGFydHMoY2xhc3Nlcy5hdXRvcGxheSk7XG4gICAgRWxlbWVudHMuYmFyID0gZmluZChmaW5kUGFydHMoY2xhc3Nlcy5wcm9ncmVzcyksIFwiLlwiICsgY2xhc3Nlcy5iYXIpO1xuICAgIEVsZW1lbnRzLnBsYXkgPSBmaW5kKGF1dG9wbGF5LCBcIi5cIiArIGNsYXNzZXMucGxheSk7XG4gICAgRWxlbWVudHMucGF1c2UgPSBmaW5kKGF1dG9wbGF5LCBcIi5cIiArIGNsYXNzZXMucGF1c2UpO1xuICAgIEVsZW1lbnRzLnRyYWNrLmlkID0gRWxlbWVudHMudHJhY2suaWQgfHwgcm9vdC5pZCArIFwiLXRyYWNrXCI7XG4gICAgRWxlbWVudHMubGlzdC5pZCA9IEVsZW1lbnRzLmxpc3QuaWQgfHwgcm9vdC5pZCArIFwiLWxpc3RcIjtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm4gY2xhc3MgbmFtZXMgZm9yIHRoZSByb290IGVsZW1lbnQuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRDbGFzc2VzKCkge1xuICAgIHZhciByb290Q2xhc3MgPSBjbGFzc2VzLnJvb3Q7XG4gICAgdmFyIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcbiAgICByZXR1cm4gW3Jvb3RDbGFzcyArIFwiLS1cIiArIG9wdGlvbnMudHlwZSwgcm9vdENsYXNzICsgXCItLVwiICsgb3B0aW9ucy5kaXJlY3Rpb24sIG9wdGlvbnMuZHJhZyA/IHJvb3RDbGFzcyArIFwiLS1kcmFnZ2FibGVcIiA6ICcnLCBvcHRpb25zLmlzTmF2aWdhdGlvbiA/IHJvb3RDbGFzcyArIFwiLS1uYXZcIiA6ICcnLCBTVEFUVVNfQ0xBU1NFUy5hY3RpdmVdO1xuICB9XG4gIC8qKlxyXG4gICAqIEZpbmQgcGFydHMgb25seSBmcm9tIGNoaWxkcmVuIG9mIHRoZSByb290IG9yIHRyYWNrLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RWxlbWVudH0gLSBBIGZvdW5kIGVsZW1lbnQgb3IgdW5kZWZpbmVkLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZmluZFBhcnRzKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiBjaGlsZChyb290LCBjbGFzc05hbWUpIHx8IGNoaWxkKEVsZW1lbnRzLnNsaWRlciwgY2xhc3NOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBFbGVtZW50cztcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvY29udHJvbGxlci9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGNvbnRyb2xsaW5nIHRoZSB0cmFjay5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cblxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBjb250cm9sbGluZyB0aGUgdHJhY2suXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBDb21wb25lbnRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tcG9uZW50cy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb250cm9sbGVyID0gKGZ1bmN0aW9uIChTcGxpZGUsIENvbXBvbmVudHMpIHtcbiAgLyoqXHJcbiAgICogU3RvcmUgY3VycmVudCBvcHRpb25zLlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cbiAgdmFyIG9wdGlvbnM7XG4gIC8qKlxyXG4gICAqIFRydWUgaWYgdGhlIHNsaWRlIGlzIExPT1AgbW9kZS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuXG4gIHZhciBpc0xvb3A7XG4gIC8qKlxyXG4gICAqIENvbnRyb2xsZXIgY29tcG9uZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIENvbnRyb2xsZXIgPSB7XG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG4gICAgICBpc0xvb3AgPSBTcGxpZGUuaXMoTE9PUCk7XG4gICAgICBiaW5kKCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogTWFrZSB0cmFjayBydW4gYnkgdGhlIGdpdmVuIGNvbnRyb2wuXHJcbiAgICAgKiAtIFwiK3tpfVwiIDogSW5jcmVtZW50IHRoZSBzbGlkZSBpbmRleCBieSBpLlxyXG4gICAgICogLSBcIi17aX1cIiA6IERlY3JlbWVudCB0aGUgc2xpZGUgaW5kZXggYnkgaS5cclxuICAgICAqIC0gXCJ7aX1cIiAgOiBHbyB0byB0aGUgc2xpZGUgd2hvc2UgaW5kZXggaXMgaS5cclxuICAgICAqIC0gXCI+XCIgICAgOiBHbyB0byBuZXh0IHBhZ2UuXHJcbiAgICAgKiAtIFwiPFwiICAgIDogR28gdG8gcHJldiBwYWdlLlxyXG4gICAgICogLSBcIj57aX1cIiA6IEdvIHRvIHBhZ2UgaS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGNvbnRyb2wgIC0gQSBjb250cm9sIHBhdHRlcm4uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgIHNpbGVudGx5IC0gR28gdG8gdGhlIGRlc3RpbmF0aW9uIHdpdGhvdXQgZXZlbnQgZW1pc3Npb24uXHJcbiAgICAgKi9cbiAgICBnbzogZnVuY3Rpb24gZ28oY29udHJvbCwgc2lsZW50bHkpIHtcbiAgICAgIHZhciBkZXN0SW5kZXggPSB0aGlzLnRyaW0odGhpcy5wYXJzZShjb250cm9sKSk7XG4gICAgICBDb21wb25lbnRzLlRyYWNrLmdvKGRlc3RJbmRleCwgdGhpcy5yZXdpbmQoZGVzdEluZGV4KSwgc2lsZW50bHkpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFBhcnNlIHRoZSBnaXZlbiBjb250cm9sIGFuZCByZXR1cm4gdGhlIGRlc3RpbmF0aW9uIGluZGV4IGZvciB0aGUgdHJhY2suXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyb2wgLSBBIGNvbnRyb2wgdGFyZ2V0IHBhdHRlcm4uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIEEgcGFyc2VkIHRhcmdldC5cclxuICAgICAqL1xuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShjb250cm9sKSB7XG4gICAgICB2YXIgaW5kZXggPSBTcGxpZGUuaW5kZXg7XG4gICAgICB2YXIgbWF0Y2hlcyA9IFN0cmluZyhjb250cm9sKS5tYXRjaCgvKFsrXFwtPD5dKykoXFxkKyk/Lyk7XG4gICAgICB2YXIgaW5kaWNhdG9yID0gbWF0Y2hlcyA/IG1hdGNoZXNbMV0gOiAnJztcbiAgICAgIHZhciBudW1iZXIgPSBtYXRjaGVzID8gcGFyc2VJbnQobWF0Y2hlc1syXSkgOiAwO1xuXG4gICAgICBzd2l0Y2ggKGluZGljYXRvcikge1xuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICBpbmRleCArPSBudW1iZXIgfHwgMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICBpbmRleCAtPSBudW1iZXIgfHwgMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgaW5kZXggPSBwYXJzZVBhZ2UobnVtYmVyLCBpbmRleCwgaW5kaWNhdG9yID09PSAnPCcpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaW5kZXggPSBwYXJzZUludChjb250cm9sKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIENvbXB1dGUgaW5kZXggZnJvbSB0aGUgZ2l2ZW4gcGFnZSBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhZ2UgLSBQYWdlIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gQSBjb21wdXRlZCBwYWdlIG51bWJlci5cclxuICAgICAqL1xuICAgIHRvSW5kZXg6IGZ1bmN0aW9uIHRvSW5kZXgocGFnZSkge1xuICAgICAgaWYgKGhhc0ZvY3VzKCkpIHtcbiAgICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5ndGggPSBTcGxpZGUubGVuZ3RoO1xuICAgICAgdmFyIHBlclBhZ2UgPSBvcHRpb25zLnBlclBhZ2U7XG4gICAgICB2YXIgaW5kZXggPSBwYWdlICogcGVyUGFnZTtcbiAgICAgIGluZGV4ID0gaW5kZXggLSAodGhpcy5wYWdlTGVuZ3RoICogcGVyUGFnZSAtIGxlbmd0aCkgKiBmbG9vcihpbmRleCAvIGxlbmd0aCk7IC8vIEFkanVzdG1lbnQgZm9yIHRoZSBsYXN0IHBhZ2UuXG5cbiAgICAgIGlmIChsZW5ndGggLSBwZXJQYWdlIDw9IGluZGV4ICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGluZGV4ID0gbGVuZ3RoIC0gcGVyUGFnZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIENvbXB1dGUgcGFnZSBudW1iZXIgZnJvbSB0aGUgZ2l2ZW4gc2xpZGUgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gU2xpZGUgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIEEgY29tcHV0ZWQgcGFnZSBudW1iZXIuXHJcbiAgICAgKi9cbiAgICB0b1BhZ2U6IGZ1bmN0aW9uIHRvUGFnZShpbmRleCkge1xuICAgICAgaWYgKGhhc0ZvY3VzKCkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuZ3RoID0gU3BsaWRlLmxlbmd0aDtcbiAgICAgIHZhciBwZXJQYWdlID0gb3B0aW9ucy5wZXJQYWdlOyAvLyBNYWtlIHRoZSBsYXN0IFwicGVyUGFnZVwiIG51bWJlciBvZiBzbGlkZXMgYmVsb25nIHRvIHRoZSBsYXN0IHBhZ2UuXG5cbiAgICAgIGlmIChsZW5ndGggLSBwZXJQYWdlIDw9IGluZGV4ICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmbG9vcigobGVuZ3RoIC0gMSkgLyBwZXJQYWdlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZsb29yKGluZGV4IC8gcGVyUGFnZSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogVHJpbSB0aGUgZ2l2ZW4gaW5kZXggYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IG1vZGUuXHJcbiAgICAgKiBJbmRleCBiZWluZyByZXR1cm5lZCBjb3VsZCBiZSBsZXNzIHRoYW4gMCBvciBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBpbiBMb29wIG1vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gQW4gaW5kZXggYmVpbmcgdHJpbW1lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gQSB0cmltbWVkIGluZGV4LlxyXG4gICAgICovXG4gICAgdHJpbTogZnVuY3Rpb24gdHJpbShpbmRleCkge1xuICAgICAgaWYgKCFpc0xvb3ApIHtcbiAgICAgICAgaW5kZXggPSBvcHRpb25zLnJld2luZCA/IHRoaXMucmV3aW5kKGluZGV4KSA6IGJldHdlZW4oaW5kZXgsIDAsIHRoaXMuZWRnZUluZGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJld2luZCB0aGUgZ2l2ZW4gaW5kZXggaWYgaXQncyBvdXQgb2YgcmFuZ2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gQW4gaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIEEgcmV3b3VuZCBpbmRleC5cclxuICAgICAqL1xuICAgIHJld2luZDogZnVuY3Rpb24gcmV3aW5kKGluZGV4KSB7XG4gICAgICB2YXIgZWRnZSA9IHRoaXMuZWRnZUluZGV4O1xuXG4gICAgICBpZiAoaXNMb29wKSB7XG4gICAgICAgIHdoaWxlIChpbmRleCA+IGVkZ2UpIHtcbiAgICAgICAgICBpbmRleCAtPSBlZGdlICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IDApIHtcbiAgICAgICAgICBpbmRleCArPSBlZGdlICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGluZGV4ID4gZWRnZSkge1xuICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBpbmRleCA9IGVkZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIHRoZSBkaXJlY3Rpb24gaXMgXCJydGxcIiBvciBub3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIFwicnRsXCIgb3IgZmFsc2UgaWYgbm90LlxyXG4gICAgICovXG4gICAgaXNSdGw6IGZ1bmN0aW9uIGlzUnRsKCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuZGlyZWN0aW9uID09PSBSVEw7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBwYWdlIGxlbmd0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gTWF4IHBhZ2UgbnVtYmVyLlxyXG4gICAgICovXG4gICAgZ2V0IHBhZ2VMZW5ndGgoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gU3BsaWRlLmxlbmd0aDtcbiAgICAgIHJldHVybiBoYXNGb2N1cygpID8gbGVuZ3RoIDogTWF0aC5jZWlsKGxlbmd0aCAvIG9wdGlvbnMucGVyUGFnZSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBlZGdlIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBFZGdlIGluZGV4LlxyXG4gICAgICovXG4gICAgZ2V0IGVkZ2VJbmRleCgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBTcGxpZGUubGVuZ3RoO1xuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0ZvY3VzKCkgfHwgb3B0aW9ucy5pc05hdmlnYXRpb24gfHwgaXNMb29wKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGggLSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGVuZ3RoIC0gb3B0aW9ucy5wZXJQYWdlO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIHByZXZpb3VzIHNsaWRlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgaW5kZXggb2YgdGhlIHByZXZpb3VzIHNsaWRlIGlmIGF2YWlsYWJsZS4gLTEgb3RoZXJ3aXNlLlxyXG4gICAgICovXG4gICAgZ2V0IHByZXZJbmRleCgpIHtcbiAgICAgIHZhciBwcmV2ID0gU3BsaWRlLmluZGV4IC0gMTtcblxuICAgICAgaWYgKGlzTG9vcCB8fCBvcHRpb25zLnJld2luZCkge1xuICAgICAgICBwcmV2ID0gdGhpcy5yZXdpbmQocHJldik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2ID4gLTEgPyBwcmV2IDogLTE7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBzbGlkZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIGluZGV4IG9mIHRoZSBuZXh0IHNsaWRlIGlmIGF2YWlsYWJsZS4gLTEgb3RoZXJ3aXNlLlxyXG4gICAgICovXG4gICAgZ2V0IG5leHRJbmRleCgpIHtcbiAgICAgIHZhciBuZXh0ID0gU3BsaWRlLmluZGV4ICsgMTtcblxuICAgICAgaWYgKGlzTG9vcCB8fCBvcHRpb25zLnJld2luZCkge1xuICAgICAgICBuZXh0ID0gdGhpcy5yZXdpbmQobmV4dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTcGxpZGUuaW5kZXggPCBuZXh0ICYmIG5leHQgPD0gdGhpcy5lZGdlSW5kZXggfHwgbmV4dCA9PT0gMCA/IG5leHQgOiAtMTtcbiAgICB9XG5cbiAgfTtcbiAgLyoqXHJcbiAgICogTGlzdGVuIHRvIHNvbWUgZXZlbnRzLlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgU3BsaWRlLm9uKCdtb3ZlJywgZnVuY3Rpb24gKG5ld0luZGV4KSB7XG4gICAgICBTcGxpZGUuaW5kZXggPSBuZXdJbmRleDtcbiAgICB9KS5vbigndXBkYXRlZCByZWZyZXNoJywgZnVuY3Rpb24gKG5ld09wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBuZXdPcHRpb25zIHx8IG9wdGlvbnM7XG4gICAgICBTcGxpZGUuaW5kZXggPSBiZXR3ZWVuKFNwbGlkZS5pbmRleCwgMCwgQ29udHJvbGxlci5lZGdlSW5kZXgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIFZlcmlmeSBpZiB0aGUgZm9jdXMgb3B0aW9uIGlzIGF2YWlsYWJsZSBvciBub3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgYSBzbGlkZXIgaGFzIHRoZSBmb2N1cyBvcHRpb24uXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBoYXNGb2N1cygpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5mb2N1cyAhPT0gZmFsc2U7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBuZXh0IG9yIHByZXZpb3VzIHBhZ2UgaW5kZXggY29tcHV0ZWQgYnkgdGhlIHBhZ2UgbnVtYmVyIGFuZCBjdXJyZW50IGluZGV4LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBudW1iZXIgLSBTcGVjaWZ5IHRoZSBwYWdlIG51bWJlci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gIGluZGV4ICAtIEN1cnJlbnQgaW5kZXguXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBwcmV2ICAgLSBQcmV2IG9yIG5leHQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gU2xpZGUgaW5kZXguXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBwYXJzZVBhZ2UobnVtYmVyLCBpbmRleCwgcHJldikge1xuICAgIGlmIChudW1iZXIgPiAtMSkge1xuICAgICAgcmV0dXJuIENvbnRyb2xsZXIudG9JbmRleChudW1iZXIpO1xuICAgIH1cblxuICAgIHZhciBwZXJNb3ZlID0gb3B0aW9ucy5wZXJNb3ZlO1xuICAgIHZhciBzaWduID0gcHJldiA/IC0xIDogMTtcblxuICAgIGlmIChwZXJNb3ZlKSB7XG4gICAgICByZXR1cm4gaW5kZXggKyBwZXJNb3ZlICogc2lnbjtcbiAgICB9XG5cbiAgICByZXR1cm4gQ29udHJvbGxlci50b0luZGV4KENvbnRyb2xsZXIudG9QYWdlKGluZGV4KSArIHNpZ24pO1xuICB9XG5cbiAgcmV0dXJuIENvbnRyb2xsZXI7XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL3RyYWNrL2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgbW92aW5nIGxpc3QgaW4gdGhlIHRyYWNrLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuXG5cblxudmFyIGFicyA9IE1hdGguYWJzO1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIG1vdmluZyBsaXN0IGluIHRoZSB0cmFjay5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9IENvbXBvbmVudHMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHRyYWNrID0gKGZ1bmN0aW9uIChTcGxpZGUsIENvbXBvbmVudHMpIHtcbiAgLyoqXHJcbiAgICogSG9sZCB0aGUgTGF5b3V0IGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG4gIHZhciBMYXlvdXQ7XG4gIC8qKlxyXG4gICAqIEhvbGQgdGhlIExheW91dCBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBFbGVtZW50cztcbiAgLyoqXHJcbiAgICogU3RvcmUgdGhlIGxpc3QgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtFbGVtZW50fVxyXG4gICAqL1xuXG4gIHZhciBsaXN0O1xuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBjdXJyZW50IGRpcmVjdGlvbiBpcyB2ZXJ0aWNhbCBvciBub3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cblxuICB2YXIgaXNWZXJ0aWNhbCA9IFNwbGlkZS5vcHRpb25zLmRpcmVjdGlvbiA9PT0gVFRCO1xuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBzbGlkZXIgdHlwZSBpcyBGQURFIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuXG4gIHZhciBpc0ZhZGUgPSBTcGxpZGUuaXMoRkFERSk7XG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIHNsaWRlciBkaXJlY3Rpb24gaXMgUlRMIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuXG4gIHZhciBpc1JUTCA9IFNwbGlkZS5vcHRpb25zLmRpcmVjdGlvbiA9PT0gUlRMO1xuICAvKipcclxuICAgKiBUaGlzIHdpbGwgYmUgdHJ1ZSB3aGlsZSB0cmFuc2l0aW9uaW5nIGZyb20gdGhlIGxhc3QgaW5kZXggdG8gdGhlIGZpcnN0IG9uZS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuXG4gIHZhciBpc0xvb3BQZW5kaW5nID0gZmFsc2U7XG4gIC8qKlxyXG4gICAqIFNpZ24gZm9yIHRoZSBkaXJlY3Rpb24uIE9ubHkgUlRMIG1vZGUgdXNlcyB0aGUgcG9zaXRpdmUgc2lnbi5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG5cbiAgdmFyIHNpZ24gPSBpc1JUTCA/IDEgOiAtMTtcbiAgLyoqXHJcbiAgICogVHJhY2sgY29tcG9uZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIFRyYWNrID0ge1xuICAgIC8qKlxyXG4gICAgICogTWFrZSBwdWJsaWMgdGhlIHNpZ24gZGVmaW5lZCBsb2NhbGx5LlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cbiAgICBzaWduOiBzaWduLFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICBFbGVtZW50cyA9IENvbXBvbmVudHMuRWxlbWVudHM7XG4gICAgICBMYXlvdXQgPSBDb21wb25lbnRzLkxheW91dDtcbiAgICAgIGxpc3QgPSBFbGVtZW50cy5saXN0O1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIENhbGxlZCBhZnRlciB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKiBUaGUgcmVzaXplIGV2ZW50IG11c3QgYmUgcmVnaXN0ZXJlZCBhZnRlciB0aGUgTGF5b3V0J3Mgb25lIGlzIGRvbmUuXHJcbiAgICAgKi9cbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCFpc0ZhZGUpIHtcbiAgICAgICAgdGhpcy5qdW1wKDApO1xuICAgICAgICBTcGxpZGUub24oJ21vdW50ZWQgcmVzaXplIHVwZGF0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuanVtcChTcGxpZGUuaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBHbyB0byB0aGUgZ2l2ZW4gZGVzdGluYXRpb24gaW5kZXguXHJcbiAgICAgKiBBZnRlciBhcnJpdmluZyB0aGVyZSwgdGhlIHRyYWNrIGlzIGp1bXAgdG8gdGhlIG5ldyBpbmRleCB3aXRob3V0IGFuaW1hdGlvbiwgbWFpbmx5IGZvciBsb29wIG1vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICBkZXN0SW5kZXggLSBBIGRlc3RpbmF0aW9uIGluZGV4LlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIGNhbiBiZSBuZWdhdGl2ZSBvciBncmVhdGVyIHRoYW4gc2xpZGVzIGxlbmd0aCBmb3IgcmVhY2hpbmcgY2xvbmVzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICBuZXdJbmRleCAgLSBBbiBhY3R1YWwgbmV3IGluZGV4LiBUaGV5IGFyZSBhbHdheXMgc2FtZSBpbiBTbGlkZSBhbmQgUmV3aW5kIG1vZGUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudGx5ICAtIElmIHRydWUsIHN1cHByZXNzIGVtaXR0aW5nIGV2ZW50cy5cclxuICAgICAqL1xuICAgIGdvOiBmdW5jdGlvbiBnbyhkZXN0SW5kZXgsIG5ld0luZGV4LCBzaWxlbnRseSkge1xuICAgICAgdmFyIG5ld1Bvc2l0aW9uID0gZ2V0VHJpbW1lZFBvc2l0aW9uKGRlc3RJbmRleCk7XG4gICAgICB2YXIgcHJldkluZGV4ID0gU3BsaWRlLmluZGV4OyAvLyBQcmV2ZW50IGFueSBhY3Rpb25zIHdoaWxlIHRyYW5zaXRpb25pbmcgZnJvbSB0aGUgbGFzdCBpbmRleCB0byB0aGUgZmlyc3Qgb25lIGZvciBqdW1wLlxuXG4gICAgICBpZiAoU3BsaWRlLlN0YXRlLmlzKE1PVklORykgJiYgaXNMb29wUGVuZGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlzTG9vcFBlbmRpbmcgPSBkZXN0SW5kZXggIT09IG5ld0luZGV4O1xuXG4gICAgICBpZiAoIXNpbGVudGx5KSB7XG4gICAgICAgIFNwbGlkZS5lbWl0KCdtb3ZlJywgbmV3SW5kZXgsIHByZXZJbmRleCwgZGVzdEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKE1hdGguYWJzKG5ld1Bvc2l0aW9uIC0gdGhpcy5wb3NpdGlvbikgPj0gMSB8fCBpc0ZhZGUpIHtcbiAgICAgICAgQ29tcG9uZW50cy5UcmFuc2l0aW9uLnN0YXJ0KGRlc3RJbmRleCwgbmV3SW5kZXgsIHByZXZJbmRleCwgdGhpcy50b0Nvb3JkKG5ld1Bvc2l0aW9uKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG9uVHJhbnNpdGlvbkVuZChkZXN0SW5kZXgsIG5ld0luZGV4LCBwcmV2SW5kZXgsIHNpbGVudGx5KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGVzdEluZGV4ICE9PSBwcmV2SW5kZXggJiYgU3BsaWRlLm9wdGlvbnMudHJpbVNwYWNlID09PSAnbW92ZScpIHtcbiAgICAgICAgICBDb21wb25lbnRzLkNvbnRyb2xsZXIuZ28oZGVzdEluZGV4ICsgZGVzdEluZGV4IC0gcHJldkluZGV4LCBzaWxlbnRseSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25UcmFuc2l0aW9uRW5kKGRlc3RJbmRleCwgbmV3SW5kZXgsIHByZXZJbmRleCwgc2lsZW50bHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogTW92ZSB0aGUgdHJhY2sgdG8gdGhlIHNwZWNpZmllZCBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBBIGRlc3RpbmF0aW9uIGluZGV4IHdoZXJlIHRoZSB0cmFjayBqdW1wcy5cclxuICAgICAqL1xuICAgIGp1bXA6IGZ1bmN0aW9uIGp1bXAoaW5kZXgpIHtcbiAgICAgIHRoaXMudHJhbnNsYXRlKGdldFRyaW1tZWRQb3NpdGlvbihpbmRleCkpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbGlzdCBwb3NpdGlvbiBieSBDU1MgdHJhbnNsYXRlIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiAtIEEgbmV3IHBvc2l0aW9uIHZhbHVlLlxyXG4gICAgICovXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiB0cmFuc2xhdGUocG9zaXRpb24pIHtcbiAgICAgIGFwcGx5U3R5bGUobGlzdCwge1xuICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlXCIgKyAoaXNWZXJ0aWNhbCA/ICdZJyA6ICdYJykgKyBcIihcIiArIHBvc2l0aW9uICsgXCJweClcIlxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogQ2FuY2VsIHRoZSB0cmFuc2l0aW9uIGFuZCBzZXQgdGhlIGxpc3QgcG9zaXRpb24uXHJcbiAgICAgKiBBbHNvLCBsb29wIHRoZSBzbGlkZXIgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICovXG4gICAgY2FuY2VsOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICBpZiAoU3BsaWRlLmlzKExPT1ApKSB7XG4gICAgICAgIHRoaXMuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy50cmFuc2xhdGUodGhpcy5wb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGFwcGx5U3R5bGUobGlzdCwge1xuICAgICAgICB0cmFuc2l0aW9uOiAnJ1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogU2hpZnQgdGhlIHNsaWRlciBpZiBpdCBleGNlZWRzIGJvcmRlcnMgb24gdGhlIGVkZ2UuXHJcbiAgICAgKi9cbiAgICBzaGlmdDogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSBhYnModGhpcy5wb3NpdGlvbik7XG4gICAgICB2YXIgbGVmdCA9IGFicyh0aGlzLnRvUG9zaXRpb24oMCkpO1xuICAgICAgdmFyIHJpZ2h0ID0gYWJzKHRoaXMudG9Qb3NpdGlvbihTcGxpZGUubGVuZ3RoKSk7XG4gICAgICB2YXIgaW5uZXJTaXplID0gcmlnaHQgLSBsZWZ0O1xuXG4gICAgICBpZiAocG9zaXRpb24gPCBsZWZ0KSB7XG4gICAgICAgIHBvc2l0aW9uICs9IGlubmVyU2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPiByaWdodCkge1xuICAgICAgICBwb3NpdGlvbiAtPSBpbm5lclNpemU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJhbnNsYXRlKHNpZ24gKiBwb3NpdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogVHJpbSByZWR1bmRhbnQgc3BhY2VzIG9uIHRoZSBsZWZ0IG9yIHJpZ2h0IGVkZ2UgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiAtIFBvc2l0aW9uIHZhbHVlIHRvIGJlIHRyaW1tZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIFRyaW1tZWQgcG9zaXRpb24uXHJcbiAgICAgKi9cbiAgICB0cmltOiBmdW5jdGlvbiB0cmltKHBvc2l0aW9uKSB7XG4gICAgICBpZiAoIVNwbGlkZS5vcHRpb25zLnRyaW1TcGFjZSB8fCBTcGxpZGUuaXMoTE9PUCkpIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWRnZSA9IHNpZ24gKiAoTGF5b3V0LnRvdGFsU2l6ZSgpIC0gTGF5b3V0LnNpemUgLSBMYXlvdXQuZ2FwKTtcbiAgICAgIHJldHVybiBiZXR3ZWVuKHBvc2l0aW9uLCBlZGdlLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNsb3Nlc3Qgc2xpZGUgaW5kZXggZnJvbSB0aGUgZ2l2ZW4gcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIC0gQSBwb3NpdGlvbiBjb252ZXJ0ZWQgdG8gYW4gc2xpZGUgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSBjbG9zZXN0IHNsaWRlIGluZGV4LlxyXG4gICAgICovXG4gICAgdG9JbmRleDogZnVuY3Rpb24gdG9JbmRleChwb3NpdGlvbikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgIEVsZW1lbnRzLmdldFNsaWRlcyh0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChTbGlkZSkge1xuICAgICAgICB2YXIgc2xpZGVJbmRleCA9IFNsaWRlLmluZGV4O1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBhYnMoX3RoaXMyLnRvUG9zaXRpb24oc2xpZGVJbmRleCkgLSBwb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgIGluZGV4ID0gc2xpZGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGNvb3JkaW5hdGVzIG9iamVjdCBieSB0aGUgZ2l2ZW4gcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIC0gQSBwb3NpdGlvbiB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gQSBjb29yZGluYXRlcyBvYmplY3QuXHJcbiAgICAgKi9cbiAgICB0b0Nvb3JkOiBmdW5jdGlvbiB0b0Nvb3JkKHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBpc1ZlcnRpY2FsID8gMCA6IHBvc2l0aW9uLFxuICAgICAgICB5OiBpc1ZlcnRpY2FsID8gcG9zaXRpb24gOiAwXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB0aGUgdHJhY2sgcG9zaXRpb24gYnkgYSBzbGlkZSBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBTbGlkZSBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gQ2FsY3VsYXRlZCBwb3NpdGlvbi5cclxuICAgICAqL1xuICAgIHRvUG9zaXRpb246IGZ1bmN0aW9uIHRvUG9zaXRpb24oaW5kZXgpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IExheW91dC50b3RhbFNpemUoaW5kZXgpIC0gTGF5b3V0LnNsaWRlU2l6ZShpbmRleCkgLSBMYXlvdXQuZ2FwO1xuICAgICAgcmV0dXJuIHNpZ24gKiAocG9zaXRpb24gKyB0aGlzLm9mZnNldChpbmRleCkpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgY3VycmVudCBvZmZzZXQgdmFsdWUsIGNvbnNpZGVyaW5nIGRpcmVjdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gT2Zmc2V0IGFtb3VudC5cclxuICAgICAqL1xuICAgIG9mZnNldDogZnVuY3Rpb24gb2Zmc2V0KGluZGV4KSB7XG4gICAgICB2YXIgZm9jdXMgPSBTcGxpZGUub3B0aW9ucy5mb2N1cztcbiAgICAgIHZhciBzbGlkZVNpemUgPSBMYXlvdXQuc2xpZGVTaXplKGluZGV4KTtcblxuICAgICAgaWYgKGZvY3VzID09PSAnY2VudGVyJykge1xuICAgICAgICByZXR1cm4gLShMYXlvdXQuc2l6ZSAtIHNsaWRlU2l6ZSkgLyAyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLShwYXJzZUludChmb2N1cykgfHwgMCkgKiAoc2xpZGVTaXplICsgTGF5b3V0LmdhcCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxyXG4gICAgICogVGhpcyByZXR1cm5zIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGV2ZW4gd2hpbGUgdHJhbnNpdGlvbmluZyBieSBDU1MuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIEN1cnJlbnQgcG9zaXRpb24uXHJcbiAgICAgKi9cbiAgICBnZXQgcG9zaXRpb24oKSB7XG4gICAgICB2YXIgcHJvcCA9IGlzVmVydGljYWwgPyAndG9wJyA6IGlzUlRMID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgIHJldHVybiBnZXRSZWN0KGxpc3QpW3Byb3BdIC0gKGdldFJlY3QoRWxlbWVudHMudHJhY2spW3Byb3BdIC0gTGF5b3V0LnBhZGRpbmdbcHJvcF0gKiBzaWduKTtcbiAgICB9XG5cbiAgfTtcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoZW5ldmVyIHNsaWRlcyBhcnJpdmUgYXQgYSBkZXN0aW5hdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgZGVzdEluZGV4IC0gQSBkZXN0aW5hdGlvbiBpbmRleC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gIG5ld0luZGV4ICAtIEEgbmV3IGluZGV4LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgcHJldkluZGV4IC0gQSBwcmV2aW91cyBpbmRleC5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNpbGVudGx5ICAtIElmIHRydWUsIHN1cHByZXNzIGVtaXR0aW5nIGV2ZW50cy5cclxuICAgKi9cblxuICBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQoZGVzdEluZGV4LCBuZXdJbmRleCwgcHJldkluZGV4LCBzaWxlbnRseSkge1xuICAgIGFwcGx5U3R5bGUobGlzdCwge1xuICAgICAgdHJhbnNpdGlvbjogJydcbiAgICB9KTtcbiAgICBpc0xvb3BQZW5kaW5nID0gZmFsc2U7XG5cbiAgICBpZiAoIWlzRmFkZSkge1xuICAgICAgVHJhY2suanVtcChuZXdJbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKCFzaWxlbnRseSkge1xuICAgICAgU3BsaWRlLmVtaXQoJ21vdmVkJywgbmV3SW5kZXgsIHByZXZJbmRleCwgZGVzdEluZGV4KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQ29udmVydCBpbmRleCB0byB0aGUgdHJpbW1lZCBwb3NpdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUcmltbWVkIHBvc2l0aW9uLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0VHJpbW1lZFBvc2l0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIFRyYWNrLnRyaW0oVHJhY2sudG9Qb3NpdGlvbihpbmRleCkpO1xuICB9XG5cbiAgcmV0dXJuIFRyYWNrO1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9jbG9uZXMvaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBjbG9uaW5nIHNvbWUgc2xpZGVzIGZvciBcImxvb3BcIiBtb2RlIG9mIHRoZSB0cmFjay5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cblxuXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgY2xvbmluZyBzb21lIHNsaWRlcyBmb3IgXCJsb29wXCIgbW9kZSBvZiB0aGUgdHJhY2suXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBDb21wb25lbnRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tcG9uZW50cy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjbG9uZXMgPSAoZnVuY3Rpb24gKFNwbGlkZSwgQ29tcG9uZW50cykge1xuICAvKipcclxuICAgKiBTdG9yZSBpbmZvcm1hdGlvbiBvZiBhbGwgY2xvbmVzLlxyXG4gICAqXHJcbiAgICogQHR5cGUge0FycmF5fVxyXG4gICAqL1xuICB2YXIgY2xvbmVzID0gW107XG4gIC8qKlxyXG4gICAqIFN0b3JlIHRoZSBjdXJyZW50IGNsb25lIGNvdW50IG9uIG9uZSBzaWRlLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cblxuICB2YXIgY2xvbmVDb3VudCA9IDA7XG4gIC8qKlxyXG4gICAqIEtlZXAgRWxlbWVudHMgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgRWxlbWVudHMgPSBDb21wb25lbnRzLkVsZW1lbnRzO1xuICAvKipcclxuICAgKiBDbG9uZXMgY29tcG9uZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIENsb25lcyA9IHtcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmIChTcGxpZGUuaXMoTE9PUCkpIHtcbiAgICAgICAgaW5pdCgpO1xuICAgICAgICBTcGxpZGUub24oJ3JlZnJlc2g6YmVmb3JlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgfSkub24oJ3JlZnJlc2gnLCBpbml0KS5vbigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChjbG9uZUNvdW50ICE9PSBnZXRDbG9uZUNvdW50KCkpIHtcbiAgICAgICAgICAgIC8vIERlc3Ryb3kgYmVmb3JlIHJlZnJlc2ggbm90IHRvIGNvbGxlY3QgY2xvbmVzIGJ5IHRoZSBFbGVtZW50cyBjb21wb25lbnQuXG4gICAgICAgICAgICBfdGhpcy5kZXN0cm95KCk7XG5cbiAgICAgICAgICAgIFNwbGlkZS5yZWZyZXNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95LlxyXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGRvbV9yZW1vdmUoY2xvbmVzKTtcbiAgICAgIGNsb25lcyA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiBhbGwgY2xvbmVzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0VsZW1lbnRbXX0gLSBDbG9uZWQgZWxlbWVudHMuXHJcbiAgICAgKi9cbiAgICBnZXQgY2xvbmVzKCkge1xuICAgICAgcmV0dXJuIGNsb25lcztcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gY2xvbmUgbGVuZ3RoLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBBIGxlbmd0aCBvZiBjbG9uZXMuXHJcbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIGNsb25lcy5sZW5ndGg7XG4gICAgfVxuXG4gIH07XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemF0aW9uLlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgQ2xvbmVzLmRlc3Ryb3koKTtcbiAgICBjbG9uZUNvdW50ID0gZ2V0Q2xvbmVDb3VudCgpO1xuICAgIGdlbmVyYXRlQ2xvbmVzKGNsb25lQ291bnQpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlIGFuZCBhcHBlbmQvcHJlcGVuZCBjbG9uZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBUaGUgaGFsZiBudW1iZXIgb2YgY2xvbmVzLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVDbG9uZXMoY291bnQpIHtcbiAgICB2YXIgbGVuZ3RoID0gRWxlbWVudHMubGVuZ3RoLFxuICAgICAgICByZWdpc3RlciA9IEVsZW1lbnRzLnJlZ2lzdGVyO1xuXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgdmFyIHNsaWRlcyA9IEVsZW1lbnRzLnNsaWRlcztcblxuICAgICAgd2hpbGUgKHNsaWRlcy5sZW5ndGggPCBjb3VudCkge1xuICAgICAgICBzbGlkZXMgPSBzbGlkZXMuY29uY2F0KHNsaWRlcyk7XG4gICAgICB9IC8vIENsb25lcyBhZnRlciB0aGUgbGFzdCBlbGVtZW50LlxuXG5cbiAgICAgIHNsaWRlcy5zbGljZSgwLCBjb3VudCkuZm9yRWFjaChmdW5jdGlvbiAoZWxtLCBpbmRleCkge1xuICAgICAgICB2YXIgY2xvbmUgPSBjbG9uZURlZXBseShlbG0pO1xuICAgICAgICBhcHBlbmQoRWxlbWVudHMubGlzdCwgY2xvbmUpO1xuICAgICAgICBjbG9uZXMucHVzaChjbG9uZSk7XG4gICAgICAgIHJlZ2lzdGVyKGNsb25lLCBpbmRleCArIGxlbmd0aCwgaW5kZXggJSBsZW5ndGgpO1xuICAgICAgfSk7IC8vIENsb25lcyBiZWZvcmUgdGhlIGZpcnN0IGVsZW1lbnQuXG5cbiAgICAgIHNsaWRlcy5zbGljZSgtY291bnQpLmZvckVhY2goZnVuY3Rpb24gKGVsbSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNsb25lID0gY2xvbmVEZWVwbHkoZWxtKTtcbiAgICAgICAgYmVmb3JlKGNsb25lLCBzbGlkZXNbMF0pO1xuICAgICAgICBjbG9uZXMucHVzaChjbG9uZSk7XG4gICAgICAgIHJlZ2lzdGVyKGNsb25lLCBpbmRleCAtIGNvdW50LCAobGVuZ3RoICsgaW5kZXggLSBjb3VudCAlIGxlbmd0aCkgJSBsZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybiBoYWxmIGNvdW50IG9mIGNsb25lcyB0byBiZSBnZW5lcmF0ZWQuXHJcbiAgICogQ2xvbmUgY291bnQgaXMgZGV0ZXJtaW5lZCBieTpcclxuICAgKiAtIFwiY2xvbmVzXCIgdmFsdWUgaW4gdGhlIG9wdGlvbnMuXHJcbiAgICogLSBOdW1iZXIgb2Ygc2xpZGVzIHRoYXQgY2FuIGJlIHBsYWNlZCBpbiBhIHZpZXcgaW4gXCJmaXhlZFwiIG1vZGUuXHJcbiAgICogLSBNYXggcGFnZXMgYSBmbGljayBhY3Rpb24gY2FuIG1vdmUuXHJcbiAgICogLSBXaGV0aGVyIHRoZSBzbGlkZSBsZW5ndGggaXMgZW5vdWdoIGZvciBwZXJQYWdlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIENvdW50IGZvciBjbG9uZXMuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRDbG9uZUNvdW50KCkge1xuICAgIHZhciBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG5cbiAgICBpZiAob3B0aW9ucy5jbG9uZXMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmNsb25lcztcbiAgICB9IC8vIFVzZSB0aGUgc2xpZGUgbGVuZ3RoIGluIGF1dG9XaWR0aCBtb2RlIGJlY2F1c2UgdGhlIG51bWJlciBjYW5ub3QgYmUgY2FsY3VsYXRlZC5cblxuXG4gICAgdmFyIGJhc2VDb3VudCA9IG9wdGlvbnMuYXV0b1dpZHRoIHx8IG9wdGlvbnMuYXV0b0hlaWdodCA/IEVsZW1lbnRzLmxlbmd0aCA6IG9wdGlvbnMucGVyUGFnZTtcbiAgICB2YXIgZGltZW5zaW9uID0gb3B0aW9ucy5kaXJlY3Rpb24gPT09IFRUQiA/ICdIZWlnaHQnIDogJ1dpZHRoJztcbiAgICB2YXIgZml4ZWRTaXplID0gdG9QaXhlbChTcGxpZGUucm9vdCwgb3B0aW9uc1tcImZpeGVkXCIgKyBkaW1lbnNpb25dKTtcblxuICAgIGlmIChmaXhlZFNpemUpIHtcbiAgICAgIC8vIFJvdWdobHkgY2FsY3VsYXRlIHRoZSBjb3VudC4gVGhpcyBuZWVkcyBub3QgdG8gYmUgc3RyaWN0LlxuICAgICAgYmFzZUNvdW50ID0gTWF0aC5jZWlsKEVsZW1lbnRzLnRyYWNrW1wiY2xpZW50XCIgKyBkaW1lbnNpb25dIC8gZml4ZWRTaXplKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZUNvdW50ICogKG9wdGlvbnMuZHJhZyA/IG9wdGlvbnMuZmxpY2tNYXhQYWdlcyArIDEgOiAxKTtcbiAgfVxuICAvKipcclxuICAgKiBDbG9uZSBkZWVwbHkgdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsbSAtIEFuIGVsZW1lbnQgYmVpbmcgZHVwbGljYXRlZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge05vZGV9IC0gQSBjbG9uZWQgbm9kZShlbGVtZW50KS5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNsb25lRGVlcGx5KGVsbSkge1xuICAgIHZhciBjbG9uZSA9IGVsbS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgYWRkQ2xhc3MoY2xvbmUsIFNwbGlkZS5jbGFzc2VzLmNsb25lKTsgLy8gSUQgc2hvdWxkIG5vdCBiZSBkdXBsaWNhdGVkLlxuXG4gICAgcmVtb3ZlQXR0cmlidXRlKGNsb25lLCAnaWQnKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICByZXR1cm4gQ2xvbmVzO1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9sYXlvdXQvZGlyZWN0aW9ucy9ob3Jpem9udGFsLmpzXG4vKipcclxuICogVGhlIHJlc29sdmVyIGNvbXBvbmVudCBmb3IgaG9yaXpvbnRhbCBsYXlvdXQuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG5cbi8qKlxyXG4gKiBUaGUgcmVzb2x2ZXIgY29tcG9uZW50IGZvciBob3Jpem9udGFsIGxheW91dC5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9IENvbXBvbmVudHMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIHJlc29sdmVyIG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgaG9yaXpvbnRhbCA9IChmdW5jdGlvbiAoU3BsaWRlLCBDb21wb25lbnRzKSB7XG4gIC8qKlxyXG4gICAqIEtlZXAgdGhlIEVsZW1lbnRzIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICovXG4gIHZhciBFbGVtZW50cyA9IENvbXBvbmVudHMuRWxlbWVudHM7XG4gIC8qKlxyXG4gICAqIEtlZXAgdGhlIHJvb3QgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtFbGVtZW50fVxyXG4gICAqL1xuXG4gIHZhciByb290ID0gU3BsaWRlLnJvb3Q7XG4gIC8qKlxyXG4gICAqIEtlZXAgdGhlIHRyYWNrIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7RWxlbWVudH1cclxuICAgKi9cblxuICB2YXIgdHJhY2s7XG4gIC8qKlxyXG4gICAqIEtlZXAgdGhlIGxhdGVzdCBvcHRpb25zLlxyXG4gICAqXHJcbiAgICogQHR5cGUge0VsZW1lbnR9XHJcbiAgICovXG5cbiAgdmFyIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcbiAgcmV0dXJuIHtcbiAgICAvKipcclxuICAgICAqIE1hcmdpbiBwcm9wZXJ0eSBuYW1lLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKi9cbiAgICBtYXJnaW46ICdtYXJnaW4nICsgKG9wdGlvbnMuZGlyZWN0aW9uID09PSBSVEwgPyAnTGVmdCcgOiAnUmlnaHQnKSxcblxuICAgIC8qKlxyXG4gICAgICogQWx3YXlzIDAgYmVjYXVzZSB0aGUgaGVpZ2h0IHdpbGwgYmUgZGV0ZXJtaW5lZCBieSBpbm5lciBjb250ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXG4gICAgaGVpZ2h0OiAwLFxuXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXphdGlvbi5cclxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJlc2l6ZSBnYXAgYW5kIHBhZGRpbmcuXHJcbiAgICAgKiBUaGlzIG11c3QgYmUgY2FsbGVkIG9uIGluaXQuXHJcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICAgIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcbiAgICAgIHRyYWNrID0gRWxlbWVudHMudHJhY2s7XG4gICAgICB0aGlzLmdhcCA9IHRvUGl4ZWwocm9vdCwgb3B0aW9ucy5nYXApO1xuICAgICAgdmFyIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmc7XG4gICAgICB2YXIgbGVmdCA9IHRvUGl4ZWwocm9vdCwgcGFkZGluZy5sZWZ0IHx8IHBhZGRpbmcpO1xuICAgICAgdmFyIHJpZ2h0ID0gdG9QaXhlbChyb290LCBwYWRkaW5nLnJpZ2h0IHx8IHBhZGRpbmcpO1xuICAgICAgdGhpcy5wYWRkaW5nID0ge1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHRcbiAgICAgIH07XG4gICAgICBhcHBseVN0eWxlKHRyYWNrLCB7XG4gICAgICAgIHBhZGRpbmdMZWZ0OiB1bml0KGxlZnQpLFxuICAgICAgICBwYWRkaW5nUmlnaHQ6IHVuaXQocmlnaHQpXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdG90YWwgd2lkdGggZnJvbSB0aGUgbGVmdCBvZiB0aGUgbGlzdCB0byB0aGUgcmlnaHQgb2YgdGhlIHNsaWRlIHNwZWNpZmllZCBieSB0aGUgcHJvdmlkZWQgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gT3B0aW9uYWwuIEEgc2xpZGUgaW5kZXguIElmIHVuZGVmaW5lZCwgdG90YWwgd2lkdGggb2YgdGhlIHNsaWRlciB3aWxsIGJlIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBUb3RhbCB3aWR0aCB0byB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgc3BlY2lmaWVkIHNsaWRlLCBvciAwIGZvciBhbiBpbnZhbGlkIGluZGV4LlxyXG4gICAgICovXG4gICAgdG90YWxXaWR0aDogZnVuY3Rpb24gdG90YWxXaWR0aChpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5kZXggPSBTcGxpZGUubGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIFNsaWRlID0gRWxlbWVudHMuZ2V0U2xpZGUoaW5kZXgpO1xuICAgICAgdmFyIHdpZHRoID0gMDtcblxuICAgICAgaWYgKFNsaWRlKSB7XG4gICAgICAgIHZhciBzbGlkZVJlY3QgPSBnZXRSZWN0KFNsaWRlLnNsaWRlKTtcbiAgICAgICAgdmFyIGxpc3RSZWN0ID0gZ2V0UmVjdChFbGVtZW50cy5saXN0KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gPT09IFJUTCkge1xuICAgICAgICAgIHdpZHRoID0gbGlzdFJlY3QucmlnaHQgLSBzbGlkZVJlY3QubGVmdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aWR0aCA9IHNsaWRlUmVjdC5yaWdodCAtIGxpc3RSZWN0LmxlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICB3aWR0aCArPSB0aGlzLmdhcDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgc2xpZGUgd2lkdGggaW4gcHguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gU2xpZGUgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSBzbGlkZSB3aWR0aC5cclxuICAgICAqL1xuICAgIHNsaWRlV2lkdGg6IGZ1bmN0aW9uIHNsaWRlV2lkdGgoaW5kZXgpIHtcbiAgICAgIGlmIChvcHRpb25zLmF1dG9XaWR0aCkge1xuICAgICAgICB2YXIgU2xpZGUgPSBFbGVtZW50cy5nZXRTbGlkZShpbmRleCk7XG4gICAgICAgIHJldHVybiBTbGlkZSA/IFNsaWRlLnNsaWRlLm9mZnNldFdpZHRoIDogMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHdpZHRoID0gb3B0aW9ucy5maXhlZFdpZHRoIHx8ICh0aGlzLndpZHRoICsgdGhpcy5nYXApIC8gb3B0aW9ucy5wZXJQYWdlIC0gdGhpcy5nYXA7XG4gICAgICByZXR1cm4gdG9QaXhlbChyb290LCB3aWR0aCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBzbGlkZSBoZWlnaHQgaW4gcHguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSBzbGlkZSBoZWlnaHQuXHJcbiAgICAgKi9cbiAgICBzbGlkZUhlaWdodDogZnVuY3Rpb24gc2xpZGVIZWlnaHQoKSB7XG4gICAgICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgb3B0aW9ucy5maXhlZEhlaWdodCB8fCB0aGlzLndpZHRoICogb3B0aW9ucy5oZWlnaHRSYXRpbztcbiAgICAgIHJldHVybiB0b1BpeGVsKHJvb3QsIGhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHNsaWRlciB3aWR0aCB3aXRob3V0IHBhZGRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIEN1cnJlbnQgc2xpZGVyIHdpZHRoLlxyXG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgcmV0dXJuIHRyYWNrLmNsaWVudFdpZHRoIC0gdGhpcy5wYWRkaW5nLmxlZnQgLSB0aGlzLnBhZGRpbmcucmlnaHQ7XG4gICAgfVxuXG4gIH07XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2xheW91dC9kaXJlY3Rpb25zL3ZlcnRpY2FsLmpzXG4vKipcclxuICogVGhlIHJlc29sdmVyIGNvbXBvbmVudCBmb3IgdmVydGljYWwgbGF5b3V0LlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuXG4vKipcclxuICogVGhlIHJlc29sdmVyIGNvbXBvbmVudCBmb3IgdmVydGljYWwgbGF5b3V0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlICAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gQ29tcG9uZW50cyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgcmVzb2x2ZXIgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCB2ZXJ0aWNhbCA9IChmdW5jdGlvbiAoU3BsaWRlLCBDb21wb25lbnRzKSB7XG4gIC8qKlxyXG4gICAqIEtlZXAgdGhlIEVsZW1lbnRzIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICovXG4gIHZhciBFbGVtZW50cyA9IENvbXBvbmVudHMuRWxlbWVudHM7XG4gIC8qKlxyXG4gICAqIEtlZXAgdGhlIHJvb3QgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtFbGVtZW50fVxyXG4gICAqL1xuXG4gIHZhciByb290ID0gU3BsaWRlLnJvb3Q7XG4gIC8qKlxyXG4gICAqIEtlZXAgdGhlIHRyYWNrIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7RWxlbWVudH1cclxuICAgKi9cblxuICB2YXIgdHJhY2s7XG4gIC8qKlxyXG4gICAqIEtlZXAgdGhlIGxhdGVzdCBvcHRpb25zLlxyXG4gICAqXHJcbiAgICogQHR5cGUge0VsZW1lbnR9XHJcbiAgICovXG5cbiAgdmFyIG9wdGlvbnM7XG4gIHJldHVybiB7XG4gICAgLyoqXHJcbiAgICAgKiBNYXJnaW4gcHJvcGVydHkgbmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICovXG4gICAgbWFyZ2luOiAnbWFyZ2luQm90dG9tJyxcblxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6YXRpb24uXHJcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemUgZ2FwIGFuZCBwYWRkaW5nLlxyXG4gICAgICogVGhpcyBtdXN0IGJlIGNhbGxlZCBvbiBpbml0LlxyXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgICBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG4gICAgICB0cmFjayA9IEVsZW1lbnRzLnRyYWNrO1xuICAgICAgdGhpcy5nYXAgPSB0b1BpeGVsKHJvb3QsIG9wdGlvbnMuZ2FwKTtcbiAgICAgIHZhciBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nO1xuICAgICAgdmFyIHRvcCA9IHRvUGl4ZWwocm9vdCwgcGFkZGluZy50b3AgfHwgcGFkZGluZyk7XG4gICAgICB2YXIgYm90dG9tID0gdG9QaXhlbChyb290LCBwYWRkaW5nLmJvdHRvbSB8fCBwYWRkaW5nKTtcbiAgICAgIHRoaXMucGFkZGluZyA9IHtcbiAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgIGJvdHRvbTogYm90dG9tXG4gICAgICB9O1xuICAgICAgYXBwbHlTdHlsZSh0cmFjaywge1xuICAgICAgICBwYWRkaW5nVG9wOiB1bml0KHRvcCksXG4gICAgICAgIHBhZGRpbmdCb3R0b206IHVuaXQoYm90dG9tKVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRvdGFsIGhlaWdodCBmcm9tIHRoZSB0b3Agb2YgdGhlIGxpc3QgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc2xpZGUgc3BlY2lmaWVkIGJ5IHRoZSBwcm92aWRlZCBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBPcHRpb25hbC4gQSBzbGlkZSBpbmRleC4gSWYgdW5kZWZpbmVkLCB0b3RhbCBoZWlnaHQgb2YgdGhlIHNsaWRlciB3aWxsIGJlIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBUb3RhbCBoZWlnaHQgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc3BlY2lmaWVkIHNsaWRlLCBvciAwIGZvciBhbiBpbnZhbGlkIGluZGV4LlxyXG4gICAgICovXG4gICAgdG90YWxIZWlnaHQ6IGZ1bmN0aW9uIHRvdGFsSGVpZ2h0KGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICBpbmRleCA9IFNwbGlkZS5sZW5ndGggLSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgU2xpZGUgPSBFbGVtZW50cy5nZXRTbGlkZShpbmRleCk7XG5cbiAgICAgIGlmIChTbGlkZSkge1xuICAgICAgICByZXR1cm4gZ2V0UmVjdChTbGlkZS5zbGlkZSkuYm90dG9tIC0gZ2V0UmVjdChFbGVtZW50cy5saXN0KS50b3AgKyB0aGlzLmdhcDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBzbGlkZSB3aWR0aCBpbiBweC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHNsaWRlIHdpZHRoLlxyXG4gICAgICovXG4gICAgc2xpZGVXaWR0aDogZnVuY3Rpb24gc2xpZGVXaWR0aCgpIHtcbiAgICAgIHJldHVybiB0b1BpeGVsKHJvb3QsIG9wdGlvbnMuZml4ZWRXaWR0aCB8fCB0aGlzLndpZHRoKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHNsaWRlIGhlaWdodCBpbiBweC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBTbGlkZSBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHNsaWRlIGhlaWdodC5cclxuICAgICAqL1xuICAgIHNsaWRlSGVpZ2h0OiBmdW5jdGlvbiBzbGlkZUhlaWdodChpbmRleCkge1xuICAgICAgaWYgKG9wdGlvbnMuYXV0b0hlaWdodCkge1xuICAgICAgICB2YXIgU2xpZGUgPSBFbGVtZW50cy5nZXRTbGlkZShpbmRleCk7XG4gICAgICAgIHJldHVybiBTbGlkZSA/IFNsaWRlLnNsaWRlLm9mZnNldEhlaWdodCA6IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBoZWlnaHQgPSBvcHRpb25zLmZpeGVkSGVpZ2h0IHx8ICh0aGlzLmhlaWdodCArIHRoaXMuZ2FwKSAvIG9wdGlvbnMucGVyUGFnZSAtIHRoaXMuZ2FwO1xuICAgICAgcmV0dXJuIHRvUGl4ZWwocm9vdCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gc2xpZGVyIHdpZHRoIHdpdGhvdXQgcGFkZGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gQ3VycmVudCBzbGlkZXIgd2lkdGguXHJcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdHJhY2suY2xpZW50V2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHNsaWRlIGhlaWdodCB3aXRob3V0IHBhZGRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIFNsaWRlciBoZWlnaHQuXHJcbiAgICAgKi9cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgdmFyIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IHRoaXMud2lkdGggKiBvcHRpb25zLmhlaWdodFJhdGlvO1xuICAgICAgZXhpc3QoaGVpZ2h0LCAnXCJoZWlnaHRcIiBvciBcImhlaWdodFJhdGlvXCIgaXMgbWlzc2luZy4nKTtcbiAgICAgIHJldHVybiB0b1BpeGVsKHJvb3QsIGhlaWdodCkgLSB0aGlzLnBhZGRpbmcudG9wIC0gdGhpcy5wYWRkaW5nLmJvdHRvbTtcbiAgICB9XG5cbiAgfTtcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL3V0aWxzL3RpbWUuanNcbi8qKlxyXG4gKiBBIHBhY2thZ2Ugb2YgdXRpbGl0eSBmdW5jdGlvbnMgcmVsYXRlZCB3aXRoIHRpbWUuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuLyoqXHJcbiAqIFNpbXBsZSB0aHJvdHRsZSBmdW5jdGlvbiB0aGF0IGNvbnRyb2xzIGhvdyBvZnRlbiB0aGUgZ2l2ZW4gZnVuY3Rpb24gaXMgZXhlY3V0ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgLSBBIGZ1bmN0aW9uIHRvIGJlIHRocm90dGxlZC5cclxuICogQHBhcmFtIHtudW1iZXJ9ICAgd2FpdCAtIFRpbWUgaW4gbWlsbGlzZWNvbmQgZm9yIGludGVydmFsIG9mIGV4ZWN1dGlvbi5cclxuICpcclxuICogQHJldHVybiB7RnVuY3Rpb259IC0gQSBkZWJvdW5jZWQgZnVuY3Rpb24uXHJcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCkge1xuICB2YXIgdGltZW91dDsgLy8gRGVjbGFyZSBmdW5jdGlvbiBieSB0aGUgXCJmdW5jdGlvblwiIGtleXdvcmQgdG8gcHJldmVudCBcInRoaXNcIiBmcm9tIGJlaW5nIGluaGVyaXRlZC5cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGltZW91dCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jKCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgfSwgd2FpdCk7XG4gICAgfVxuICB9O1xufVxuLyoqXHJcbiAqIEN1c3RvbSBzZXRJbnRlcnZhbCBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIHByb2dyZXNzIHJhdGUgYXMgY2FsbGJhY2suXHJcbiAqXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayBmdW5jdGlvbiBmaXJlZCBldmVyeSB0aW1lIHRoZSBpbnRlcnZhbCB0aW1lIHBhc3Nlcy5cclxuICogQHBhcmFtIHtudW1iZXJ9ICAgaW50ZXJ2YWwgLSBJbnRlcnZhbCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHByb2dyZXNzIC0gQSBjYWxsYmFjayBmdW5jdGlvbiBmaXJlZCB3aGVuZXZlciB0aGUgcHJvZ3Jlc3MgZ29lcy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIEFuIG9iamVjdCBjb250YWluaW5nIHBsYXkoKSBhbmQgcGF1c2UoKSBmdW5jdGlvbnMuXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVJbnRlcnZhbChjYWxsYmFjaywgaW50ZXJ2YWwsIHByb2dyZXNzKSB7XG4gIHZhciBfd2luZG93ID0gd2luZG93LFxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gX3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gIHZhciBzdGFydCxcbiAgICAgIGVsYXBzZSxcbiAgICAgIHJhdGUsXG4gICAgICBfcGF1c2UgPSB0cnVlO1xuXG4gIHZhciBzdGVwID0gZnVuY3Rpb24gc3RlcCh0aW1lc3RhbXApIHtcbiAgICBpZiAoIV9wYXVzZSkge1xuICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICBzdGFydCA9IHRpbWVzdGFtcDtcblxuICAgICAgICBpZiAocmF0ZSAmJiByYXRlIDwgMSkge1xuICAgICAgICAgIHN0YXJ0IC09IHJhdGUgKiBpbnRlcnZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbGFwc2UgPSB0aW1lc3RhbXAgLSBzdGFydDtcbiAgICAgIHJhdGUgPSBlbGFwc2UgLyBpbnRlcnZhbDtcblxuICAgICAgaWYgKGVsYXBzZSA+PSBpbnRlcnZhbCkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIHJhdGUgPSAxO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgcHJvZ3Jlc3MocmF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICBfcGF1c2UgPSB0cnVlO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH0sXG4gICAgcGxheTogZnVuY3Rpb24gcGxheShyZXNldCkge1xuICAgICAgc3RhcnQgPSAwO1xuXG4gICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgcmF0ZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChfcGF1c2UpIHtcbiAgICAgICAgX3BhdXNlID0gZmFsc2U7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9sYXlvdXQvaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBoYW5kaW5nIHNsaWRlIGxheW91dHMgYW5kIHRoZWlyIHNpemVzLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuXG5cblxuXG5cbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBoYW5kaW5nIHNsaWRlIGxheW91dHMgYW5kIHRoZWlyIHNpemVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlICAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gQ29tcG9uZW50cyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgbGF5b3V0ID0gKGZ1bmN0aW9uIChTcGxpZGUsIENvbXBvbmVudHMpIHtcbiAgLyoqXHJcbiAgICogS2VlcCB0aGUgRWxlbWVudHMgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKi9cbiAgdmFyIEVsZW1lbnRzID0gQ29tcG9uZW50cy5FbGVtZW50cztcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgc2xpZGVyIGlzIHZlcnRpY2FsIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gU3BsaWRlLm9wdGlvbnMuZGlyZWN0aW9uID09PSBUVEI7XG4gIC8qKlxyXG4gICAqIExheW91dCBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgTGF5b3V0ID0gb2JqZWN0X2Fzc2lnbih7XG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICBiaW5kKCk7XG4gICAgICBpbml0KCk7IC8vIFRoZSB3b3JkIFwic2l6ZVwiIG1lYW5zIHdpZHRoIGZvciBhIGhvcml6b250YWwgc2xpZGVyIGFuZCBoZWlnaHQgZm9yIGEgdmVydGljYWwgc2xpZGVyLlxuXG4gICAgICB0aGlzLnRvdGFsU2l6ZSA9IGlzVmVydGljYWwgPyB0aGlzLnRvdGFsSGVpZ2h0IDogdGhpcy50b3RhbFdpZHRoO1xuICAgICAgdGhpcy5zbGlkZVNpemUgPSBpc1ZlcnRpY2FsID8gdGhpcy5zbGlkZUhlaWdodCA6IHRoaXMuc2xpZGVXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95IHRoZSBjb21wb25lbnQuXHJcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgcmVtb3ZlQXR0cmlidXRlKFtFbGVtZW50cy5saXN0LCBFbGVtZW50cy50cmFja10sICdzdHlsZScpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgc2xpZGVyIGhlaWdodCBvbiB0aGUgdmVydGljYWwgbW9kZSBvciB3aWR0aCBvbiB0aGUgaG9yaXpvbnRhbCBtb2RlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIGlzVmVydGljYWwgPyB0aGlzLmhlaWdodCA6IHRoaXMud2lkdGg7XG4gICAgfVxuXG4gIH0sIGlzVmVydGljYWwgPyB2ZXJ0aWNhbChTcGxpZGUsIENvbXBvbmVudHMpIDogaG9yaXpvbnRhbChTcGxpZGUsIENvbXBvbmVudHMpKTtcbiAgLyoqXHJcbiAgICogSW5pdCBzbGlkZXIgc3R5bGVzIGFjY29yZGluZyB0byBvcHRpb25zLlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgTGF5b3V0LmluaXQoKTtcbiAgICBhcHBseVN0eWxlKFNwbGlkZS5yb290LCB7XG4gICAgICBtYXhXaWR0aDogdW5pdChTcGxpZGUub3B0aW9ucy53aWR0aClcbiAgICB9KTtcbiAgICBFbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChTbGlkZSkge1xuICAgICAgU2xpZGUuc2xpZGUuc3R5bGVbTGF5b3V0Lm1hcmdpbl0gPSB1bml0KExheW91dC5nYXApO1xuICAgIH0pO1xuICAgIHJlc2l6ZSgpO1xuICB9XG4gIC8qKlxyXG4gICAqIExpc3RlbiB0aGUgcmVzaXplIG5hdGl2ZSBldmVudCB3aXRoIHRocm90dGxlLlxyXG4gICAqIEluaXRpYWxpemUgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgb3Igb3B0aW9ucyBhcmUgdXBkYXRlZC5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgU3BsaWRlLm9uKCdyZXNpemUgbG9hZCcsIHRocm90dGxlKGZ1bmN0aW9uICgpIHtcbiAgICAgIFNwbGlkZS5lbWl0KCdyZXNpemUnKTtcbiAgICB9LCBTcGxpZGUub3B0aW9ucy50aHJvdHRsZSksIHdpbmRvdykub24oJ3Jlc2l6ZScsIHJlc2l6ZSkub24oJ3VwZGF0ZWQgcmVmcmVzaCcsIGluaXQpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlc2l6ZSB0aGUgdHJhY2sgYW5kIHNsaWRlIGVsZW1lbnRzLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gcmVzaXplKCkge1xuICAgIHZhciBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG4gICAgTGF5b3V0LnJlc2l6ZSgpO1xuICAgIGFwcGx5U3R5bGUoRWxlbWVudHMudHJhY2ssIHtcbiAgICAgIGhlaWdodDogdW5pdChMYXlvdXQuaGVpZ2h0KVxuICAgIH0pO1xuICAgIHZhciBzbGlkZUhlaWdodCA9IG9wdGlvbnMuYXV0b0hlaWdodCA/IG51bGwgOiB1bml0KExheW91dC5zbGlkZUhlaWdodCgpKTtcbiAgICBFbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChTbGlkZSkge1xuICAgICAgYXBwbHlTdHlsZShTbGlkZS5jb250YWluZXIsIHtcbiAgICAgICAgaGVpZ2h0OiBzbGlkZUhlaWdodFxuICAgICAgfSk7XG4gICAgICBhcHBseVN0eWxlKFNsaWRlLnNsaWRlLCB7XG4gICAgICAgIHdpZHRoOiBvcHRpb25zLmF1dG9XaWR0aCA/IG51bGwgOiB1bml0KExheW91dC5zbGlkZVdpZHRoKFNsaWRlLmluZGV4KSksXG4gICAgICAgIGhlaWdodDogU2xpZGUuY29udGFpbmVyID8gbnVsbCA6IHNsaWRlSGVpZ2h0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBTcGxpZGUuZW1pdCgncmVzaXplZCcpO1xuICB9XG5cbiAgcmV0dXJuIExheW91dDtcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvZHJhZy9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIHN1cHBvcnRpbmcgbW91c2UgZHJhZyBhbmQgc3dpcGUuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG5cblxuXG52YXIgZHJhZ19hYnMgPSBNYXRoLmFicztcbi8qKlxyXG4gKiBJZiB0aGUgYWJzb2x1dGUgdmVsb2NpdHkgaXMgZ3JlYXRlciB0aGFudCB0aGlzIHZhbHVlLFxyXG4gKiBhIHNsaWRlciBhbHdheXMgZ29lcyB0byBhIGRpZmZlcmVudCBzbGlkZSBhZnRlciBkcmFnLCBub3QgYWxsb3dlZCB0byBzdGF5IG9uIGEgY3VycmVudCBzbGlkZS5cclxuICovXG5cbnZhciBNSU5fVkVMT0NJVFkgPSAwLjE7XG4vKipcclxuICogQWRqdXN0IGhvdyBtdWNoIHRoZSB0cmFjayBjYW4gYmUgcHVsbGVkIG9uIHRoZSBmaXJzdCBvciBsYXN0IHBhZ2UuXHJcbiAqIFRoZSBsYXJnZXIgbnVtYmVyIHRoaXMgaXMsIHRoZSBmYXJ0aGVyIHRoZSB0cmFjayBtb3Zlcy5cclxuICogVGhpcyBzaG91bGQgYmUgYXJvdW5kIDUgLSA5LlxyXG4gKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKi9cblxudmFyIEZSSUNUSU9OX1JFRFVDRVIgPSA3O1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgc3VwcG9ydGluZyBtb3VzZSBkcmFnIGFuZCBzd2lwZS5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9IENvbXBvbmVudHMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGRyYWcgPSAoZnVuY3Rpb24gKFNwbGlkZSwgQ29tcG9uZW50cykge1xuICAvKipcclxuICAgKiBTdG9yZSB0aGUgTW92ZSBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuICB2YXIgVHJhY2sgPSBDb21wb25lbnRzLlRyYWNrO1xuICAvKipcclxuICAgKiBTdG9yZSB0aGUgQ29udHJvbGxlciBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBDb250cm9sbGVyID0gQ29tcG9uZW50cy5Db250cm9sbGVyO1xuICAvKipcclxuICAgKiBDb29yZGluYXRlIG9mIHRoZSB0cmFjayBvbiBzdGFydGluZyBkcmFnLlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgc3RhcnRDb29yZDtcbiAgLyoqXHJcbiAgICogQW5hbHl6ZWQgaW5mbyBvbiBzdGFydGluZyBkcmFnLlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdHxudWxsfVxyXG4gICAqL1xuXG4gIHZhciBzdGFydEluZm87XG4gIC8qKlxyXG4gICAqIEFuYWx5emVkIGluZm8gYmVpbmcgdXBkYXRlZCB3aGlsZSBkcmFnZ2luZy9zd2lwaW5nLlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgY3VycmVudEluZm87XG4gIC8qKlxyXG4gICAqIERldGVybWluZSB3aGV0aGVyIHNsaWRlcyBhcmUgYmVpbmcgZHJhZ2dlZCBvciBub3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cblxuICB2YXIgaXNEcmFnZ2luZztcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgc2xpZGVyIGRpcmVjdGlvbiBpcyB2ZXJ0aWNhbCBvciBub3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cblxuICB2YXIgaXNWZXJ0aWNhbCA9IFNwbGlkZS5vcHRpb25zLmRpcmVjdGlvbiA9PT0gVFRCO1xuICAvKipcclxuICAgKiBBeGlzIGZvciB0aGUgZGlyZWN0aW9uLlxyXG4gICAqXHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKi9cblxuICB2YXIgYXhpcyA9IGlzVmVydGljYWwgPyAneScgOiAneCc7XG4gIC8qKlxyXG4gICAqIERyYWcgY29tcG9uZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIERyYWcgPSB7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIGRyYWdnaW5nIGlzIGRpc2FibGVkIG9yIG5vdC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xuICAgIGRpc2FibGVkOiBmYWxzZSxcblxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIEVsZW1lbnRzID0gQ29tcG9uZW50cy5FbGVtZW50cztcbiAgICAgIHZhciB0cmFjayA9IEVsZW1lbnRzLnRyYWNrO1xuICAgICAgU3BsaWRlLm9uKCd0b3VjaHN0YXJ0IG1vdXNlZG93bicsIHN0YXJ0LCB0cmFjaykub24oJ3RvdWNobW92ZSBtb3VzZW1vdmUnLCBtb3ZlLCB0cmFjaywge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSkub24oJ3RvdWNoZW5kIHRvdWNoY2FuY2VsIG1vdXNlbGVhdmUgbW91c2V1cCBkcmFnZW5kJywgZW5kLCB0cmFjaykub24oJ21vdW50ZWQgcmVmcmVzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUHJldmVudCBkcmFnZ2luZyBhbiBpbWFnZSBvciBhbmNob3IgaXRzZWxmLlxuICAgICAgICBlYWNoKEVsZW1lbnRzLmxpc3QucXVlcnlTZWxlY3RvckFsbCgnaW1nLCBhJyksIGZ1bmN0aW9uIChlbG0pIHtcbiAgICAgICAgICBTcGxpZGUub2ZmKCdkcmFnc3RhcnQnLCBlbG0pLm9uKCdkcmFnc3RhcnQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH0sIGVsbSwge1xuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KS5vbignbW91bnRlZCB1cGRhdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5kaXNhYmxlZCA9ICFTcGxpZGUub3B0aW9ucy5kcmFnO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBDYWxsZWQgd2hlbiB0aGUgdHJhY2sgc3RhcnRzIHRvIGJlIGRyYWdnZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR8TW91c2VFdmVudH0gZSAtIFRvdWNoRXZlbnQgb3IgTW91c2VFdmVudCBvYmplY3QuXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gc3RhcnQoZSkge1xuICAgIGlmICghRHJhZy5kaXNhYmxlZCAmJiAhaXNEcmFnZ2luZykge1xuICAgICAgLy8gVGhlc2UgcHJhbXMgYXJlIHVzZWQgdG8gZXZhbHVhdGUgd2hldGhlciB0aGUgc2xpZGVyIHNob3VsZCBzdGFydCBtb3ZpbmcuXG4gICAgICBpbml0KGUpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBJbml0aWFsaXplIHBhcmFtZXRlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR8TW91c2VFdmVudH0gZSAtIFRvdWNoRXZlbnQgb3IgTW91c2VFdmVudCBvYmplY3QuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBpbml0KGUpIHtcbiAgICBzdGFydENvb3JkID0gVHJhY2sudG9Db29yZChUcmFjay5wb3NpdGlvbik7XG4gICAgc3RhcnRJbmZvID0gYW5hbHl6ZShlLCB7fSk7XG4gICAgY3VycmVudEluZm8gPSBzdGFydEluZm87XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoaWxlIHRoZSB0cmFjayBiZWluZyBkcmFnZ2VkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fE1vdXNlRXZlbnR9IGUgLSBUb3VjaEV2ZW50IG9yIE1vdXNlRXZlbnQgb2JqZWN0LlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbW92ZShlKSB7XG4gICAgaWYgKHN0YXJ0SW5mbykge1xuICAgICAgY3VycmVudEluZm8gPSBhbmFseXplKGUsIHN0YXJ0SW5mbyk7XG5cbiAgICAgIGlmIChpc0RyYWdnaW5nKSB7XG4gICAgICAgIGlmIChlLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIVNwbGlkZS5pcyhGQURFKSkge1xuICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHN0YXJ0Q29vcmRbYXhpc10gKyBjdXJyZW50SW5mby5vZmZzZXRbYXhpc107XG4gICAgICAgICAgVHJhY2sudHJhbnNsYXRlKHJlc2lzdChwb3NpdGlvbikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2hvdWxkTW92ZShjdXJyZW50SW5mbykpIHtcbiAgICAgICAgICBTcGxpZGUuZW1pdCgnZHJhZycsIHN0YXJ0SW5mbyk7XG4gICAgICAgICAgaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgVHJhY2suY2FuY2VsKCk7IC8vIFRoZXNlIHBhcmFtcyBhcmUgYWN0dWFsIGRyYWcgZGF0YS5cblxuICAgICAgICAgIGluaXQoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdG8gc3RhcnQgbW92aW5nIHRoZSB0cmFjayBvciBub3QgYnkgZHJhZyBhbmdsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvIC0gQW4gaW5mb3JtYXRpb24gb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSB0cmFjayBzaG91bGQgYmUgbW92ZWQgb3IgZmFsc2UgaWYgbm90LlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc2hvdWxkTW92ZShfcmVmKSB7XG4gICAgdmFyIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuXG4gICAgaWYgKFNwbGlkZS5TdGF0ZS5pcyhNT1ZJTkcpICYmIFNwbGlkZS5vcHRpb25zLndhaXRGb3JUcmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuKGRyYWdfYWJzKG9mZnNldC55KSAvIGRyYWdfYWJzKG9mZnNldC54KSkgKiAxODAgLyBNYXRoLlBJO1xuXG4gICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgIGFuZ2xlID0gOTAgLSBhbmdsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5nbGUgPCBTcGxpZGUub3B0aW9ucy5kcmFnQW5nbGVUaHJlc2hvbGQ7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVzaXN0IGRyYWdnaW5nIHRoZSB0cmFjayBvbiB0aGUgZmlyc3QvbGFzdCBwYWdlIGJlY2F1c2UgdGhlcmUgaXMgbm8gbW9yZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiAtIEEgcG9zaXRpb24gYmVpbmcgYXBwbGllZCB0byB0aGUgdHJhY2suXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gQWRqdXN0ZWQgcG9zaXRpb24uXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiByZXNpc3QocG9zaXRpb24pIHtcbiAgICBpZiAoU3BsaWRlLmlzKFNMSURFKSkge1xuICAgICAgdmFyIHNpZ24gPSBUcmFjay5zaWduO1xuXG4gICAgICB2YXIgX3N0YXJ0ID0gc2lnbiAqIFRyYWNrLnRyaW0oVHJhY2sudG9Qb3NpdGlvbigwKSk7XG5cbiAgICAgIHZhciBfZW5kID0gc2lnbiAqIFRyYWNrLnRyaW0oVHJhY2sudG9Qb3NpdGlvbihDb250cm9sbGVyLmVkZ2VJbmRleCkpO1xuXG4gICAgICBwb3NpdGlvbiAqPSBzaWduO1xuXG4gICAgICBpZiAocG9zaXRpb24gPCBfc3RhcnQpIHtcbiAgICAgICAgcG9zaXRpb24gPSBfc3RhcnQgLSBGUklDVElPTl9SRURVQ0VSICogTWF0aC5sb2coX3N0YXJ0IC0gcG9zaXRpb24pO1xuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA+IF9lbmQpIHtcbiAgICAgICAgcG9zaXRpb24gPSBfZW5kICsgRlJJQ1RJT05fUkVEVUNFUiAqIE1hdGgubG9nKHBvc2l0aW9uIC0gX2VuZCk7XG4gICAgICB9XG5cbiAgICAgIHBvc2l0aW9uICo9IHNpZ247XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9XG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuIGRyYWdnaW5nIGVuZHMuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBlbmQoKSB7XG4gICAgc3RhcnRJbmZvID0gbnVsbDtcblxuICAgIGlmIChpc0RyYWdnaW5nKSB7XG4gICAgICBTcGxpZGUuZW1pdCgnZHJhZ2dlZCcsIGN1cnJlbnRJbmZvKTtcbiAgICAgIGdvKGN1cnJlbnRJbmZvKTtcbiAgICAgIGlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogR28gdG8gdGhlIHNsaWRlIGRldGVybWluZWQgYnkgdGhlIGFuYWx5emVkIGRhdGEuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5mbyAtIEFuIGluZm8gb2JqZWN0LlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ28oaW5mbykge1xuICAgIHZhciB2ZWxvY2l0eSA9IGluZm8udmVsb2NpdHlbYXhpc107XG4gICAgdmFyIGFic1YgPSBkcmFnX2Ficyh2ZWxvY2l0eSk7XG5cbiAgICBpZiAoYWJzViA+IDApIHtcbiAgICAgIHZhciBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG4gICAgICB2YXIgaW5kZXggPSBTcGxpZGUuaW5kZXg7XG4gICAgICB2YXIgc2lnbiA9IHZlbG9jaXR5IDwgMCA/IC0xIDogMTtcbiAgICAgIHZhciBkZXN0SW5kZXggPSBpbmRleDtcblxuICAgICAgaWYgKCFTcGxpZGUuaXMoRkFERSkpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gVHJhY2sucG9zaXRpb247XG5cbiAgICAgICAgaWYgKGFic1YgPiBvcHRpb25zLmZsaWNrVmVsb2NpdHlUaHJlc2hvbGQgJiYgZHJhZ19hYnMoaW5mby5vZmZzZXRbYXhpc10pIDwgb3B0aW9ucy5zd2lwZURpc3RhbmNlVGhyZXNob2xkKSB7XG4gICAgICAgICAgZGVzdGluYXRpb24gKz0gc2lnbiAqIE1hdGgubWluKGFic1YgKiBvcHRpb25zLmZsaWNrUG93ZXIsIENvbXBvbmVudHMuTGF5b3V0LnNpemUgKiAob3B0aW9ucy5mbGlja01heFBhZ2VzIHx8IDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RJbmRleCA9IFRyYWNrLnRvSW5kZXgoZGVzdGluYXRpb24pO1xuICAgICAgfVxuICAgICAgLypcclxuICAgICAgICogRG8gbm90IGFsbG93IHRoZSB0cmFjayB0byBnbyB0byBhIHByZXZpb3VzIHBvc2l0aW9uIGlmIHRoZXJlIGlzIGVub3VnaCB2ZWxvY2l0eS5cclxuICAgICAgICogQWx3YXlzIHVzZSB0aGUgYWRqYWNlbnQgaW5kZXggZm9yIHRoZSBmYWRlIG1vZGUuXHJcbiAgICAgICAqL1xuXG5cbiAgICAgIGlmIChkZXN0SW5kZXggPT09IGluZGV4ICYmIGFic1YgPiBNSU5fVkVMT0NJVFkpIHtcbiAgICAgICAgZGVzdEluZGV4ID0gaW5kZXggKyBzaWduICogVHJhY2suc2lnbjtcbiAgICAgIH1cblxuICAgICAgaWYgKFNwbGlkZS5pcyhTTElERSkpIHtcbiAgICAgICAgZGVzdEluZGV4ID0gYmV0d2VlbihkZXN0SW5kZXgsIDAsIENvbnRyb2xsZXIuZWRnZUluZGV4KTtcbiAgICAgIH1cblxuICAgICAgQ29udHJvbGxlci5nbyhkZXN0SW5kZXgsIG9wdGlvbnMuaXNOYXZpZ2F0aW9uKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQW5hbHl6ZSB0aGUgZ2l2ZW4gZXZlbnQgb2JqZWN0IGFuZCByZXR1cm4gaW1wb3J0YW50IGluZm9ybWF0aW9uIGZvciBoYW5kbGluZyBzd2lwZSBiZWhhdmlvci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnR9ICAgZSAgICAgICAgICAtIFRvdWNoIG9yIE1vdXNlIGV2ZW50IG9iamVjdC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gIHN0YXJ0SW5mbyAgLSBJbmZvcm1hdGlvbiBhbmFseXplZCBvbiBzdGFydCBmb3IgY2FsY3VsYXRpbmcgZGlmZmVyZW5jZSBmcm9tIHRoZSBjdXJyZW50IG9uZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gLSBBbiBvYmplY3QgY29udGFpbmluZyBhbmFseXplZCBpbmZvcm1hdGlvbiwgc3VjaCBhcyBvZmZzZXQsIHZlbG9jaXR5LCBldGMuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBhbmFseXplKGUsIHN0YXJ0SW5mbykge1xuICAgIHZhciB0aW1lU3RhbXAgPSBlLnRpbWVTdGFtcCxcbiAgICAgICAgdG91Y2hlcyA9IGUudG91Y2hlcztcblxuICAgIHZhciBfcmVmMiA9IHRvdWNoZXMgPyB0b3VjaGVzWzBdIDogZSxcbiAgICAgICAgY2xpZW50WCA9IF9yZWYyLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFkgPSBfcmVmMi5jbGllbnRZO1xuXG4gICAgdmFyIF9yZWYzID0gc3RhcnRJbmZvLnRvIHx8IHt9LFxuICAgICAgICBfcmVmMyR4ID0gX3JlZjMueCxcbiAgICAgICAgZnJvbVggPSBfcmVmMyR4ID09PSB2b2lkIDAgPyBjbGllbnRYIDogX3JlZjMkeCxcbiAgICAgICAgX3JlZjMkeSA9IF9yZWYzLnksXG4gICAgICAgIGZyb21ZID0gX3JlZjMkeSA9PT0gdm9pZCAwID8gY2xpZW50WSA6IF9yZWYzJHk7XG5cbiAgICB2YXIgc3RhcnRUaW1lID0gc3RhcnRJbmZvLnRpbWUgfHwgMDtcbiAgICB2YXIgb2Zmc2V0ID0ge1xuICAgICAgeDogY2xpZW50WCAtIGZyb21YLFxuICAgICAgeTogY2xpZW50WSAtIGZyb21ZXG4gICAgfTtcbiAgICB2YXIgZHVyYXRpb24gPSB0aW1lU3RhbXAgLSBzdGFydFRpbWU7XG4gICAgdmFyIHZlbG9jaXR5ID0ge1xuICAgICAgeDogb2Zmc2V0LnggLyBkdXJhdGlvbixcbiAgICAgIHk6IG9mZnNldC55IC8gZHVyYXRpb25cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICB0bzoge1xuICAgICAgICB4OiBjbGllbnRYLFxuICAgICAgICB5OiBjbGllbnRZXG4gICAgICB9LFxuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICB0aW1lOiB0aW1lU3RhbXAsXG4gICAgICB2ZWxvY2l0eTogdmVsb2NpdHlcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIERyYWc7XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2NsaWNrL2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgaGFuZGxpbmcgYSBjbGljayBldmVudC5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgaGFuZGxpbmcgYSBjbGljayBldmVudC5cclxuICogQ2xpY2sgc2hvdWxkIGJlIGRpc2FibGVkIGR1cmluZyBkcmFnL3N3aXBlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlICAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gQ29tcG9uZW50cyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNsaWNrID0gKGZ1bmN0aW9uIChTcGxpZGUsIENvbXBvbmVudHMpIHtcbiAgLyoqXHJcbiAgICogV2hldGhlciBjbGljayBpcyBkaXNhYmxlZCBvciBub3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgdmFyIGRpc2FibGVkID0gZmFsc2U7XG4gIC8qKlxyXG4gICAqIENsaWNrIGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBDbGljayA9IHtcbiAgICAvKipcclxuICAgICAqIE1vdW50IG9ubHkgd2hlbiB0aGUgZHJhZyBpcyBhY3RpdmF0ZWQgYW5kIHRoZSBzbGlkZSB0eXBlIGlzIG5vdCBcImZhZGVcIi5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xuICAgIHJlcXVpcmVkOiBTcGxpZGUub3B0aW9ucy5kcmFnLFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICBTcGxpZGUub24oJ2NsaWNrJywgb25DbGljaywgQ29tcG9uZW50cy5FbGVtZW50cy50cmFjaywge1xuICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICB9KS5vbignZHJhZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgfSkub24oJ2RyYWdnZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZmxhZyBpcyByZWxlYXNlZCBhZnRlciB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBDYWxsZWQgd2hlbiBhIHRyYWNrIGVsZW1lbnQgaXMgY2xpY2tlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgLSBBIGNsaWNrIGV2ZW50LlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIENsaWNrO1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9hdXRvcGxheS9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIHBsYXlpbmcgc2xpZGVzIGF1dG9tYXRpY2FsbHkuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG4vKipcclxuICogU2V0IG9mIHBhdXNlIGZsYWdzLlxyXG4gKi9cblxudmFyIFBBVVNFX0ZMQUdTID0ge1xuICBIT1ZFUjogMSxcbiAgRk9DVVM6IDIsXG4gIE1BTlVBTDogM1xufTtcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBwbGF5aW5nIHNsaWRlcyBhdXRvbWF0aWNhbGx5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlICAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gQ29tcG9uZW50cyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbXBvbmVudHMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgICAgIC0gQSBjb21wb25lbnQgbmFtZSBhcyBhIGxvd2VyY2FzZSBzdHJpbmcuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgYXV0b3BsYXkgPSAoZnVuY3Rpb24gKFNwbGlkZSwgQ29tcG9uZW50cywgbmFtZSkge1xuICAvKipcclxuICAgKiBTdG9yZSBwYXVzZSBmbGFncy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtBcnJheX1cclxuICAgKi9cbiAgdmFyIGZsYWdzID0gW107XG4gIC8qKlxyXG4gICAqIFN0b3JlIGFuIGludGVydmFsIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9O1xyXG4gICAqL1xuXG4gIHZhciBpbnRlcnZhbDtcbiAgLyoqXHJcbiAgICogS2VlcCB0aGUgRWxlbWVudHMgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKi9cblxuICB2YXIgRWxlbWVudHMgPSBDb21wb25lbnRzLkVsZW1lbnRzO1xuICAvKipcclxuICAgKiBBdXRvcGxheSBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgQXV0b3BsYXkgPSB7XG4gICAgLyoqXHJcbiAgICAgKiBSZXF1aXJlZCBvbmx5IHdoZW4gdGhlIGF1dG9wbGF5IG9wdGlvbiBpcyB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXG4gICAgcmVxdWlyZWQ6IFNwbGlkZS5vcHRpb25zLmF1dG9wbGF5LFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKiBOb3RlIHRoYXQgYXV0b3BsYXkgc3RhcnRzIG9ubHkgaWYgdGhlcmUgYXJlIHNsaWRlcyBvdmVyIHBlclBhZ2UgbnVtYmVyLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcblxuICAgICAgaWYgKEVsZW1lbnRzLnNsaWRlcy5sZW5ndGggPiBvcHRpb25zLnBlclBhZ2UpIHtcbiAgICAgICAgaW50ZXJ2YWwgPSBjcmVhdGVJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgU3BsaWRlLmdvKCc+Jyk7XG4gICAgICAgIH0sIG9wdGlvbnMuaW50ZXJ2YWwsIGZ1bmN0aW9uIChyYXRlKSB7XG4gICAgICAgICAgU3BsaWRlLmVtaXQobmFtZSArIFwiOnBsYXlpbmdcIiwgcmF0ZSk7XG5cbiAgICAgICAgICBpZiAoRWxlbWVudHMuYmFyKSB7XG4gICAgICAgICAgICBhcHBseVN0eWxlKEVsZW1lbnRzLmJhciwge1xuICAgICAgICAgICAgICB3aWR0aDogcmF0ZSAqIDEwMCArIFwiJVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBiaW5kKCk7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFN0YXJ0IGF1dG9wbGF5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnIC0gQSBwYXVzZSBmbGFnIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgKi9cbiAgICBwbGF5OiBmdW5jdGlvbiBwbGF5KGZsYWcpIHtcbiAgICAgIGlmIChmbGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgZmxhZyA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZsYWdzID0gZmxhZ3MuZmlsdGVyKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmICE9PSBmbGFnO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghZmxhZ3MubGVuZ3RoKSB7XG4gICAgICAgIFNwbGlkZS5lbWl0KG5hbWUgKyBcIjpwbGF5XCIpO1xuICAgICAgICBpbnRlcnZhbC5wbGF5KFNwbGlkZS5vcHRpb25zLnJlc2V0UHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFBhdXNlIGF1dG9wbGF5LlxyXG4gICAgICogTm90ZSB0aGF0IEFycmF5LmluY2x1ZGVzIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZsYWcgLSBBIHBhdXNlIGZsYWcgdG8gYmUgYWRkZWQuXHJcbiAgICAgKi9cbiAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoZmxhZykge1xuICAgICAgaWYgKGZsYWcgPT09IHZvaWQgMCkge1xuICAgICAgICBmbGFnID0gMDtcbiAgICAgIH1cblxuICAgICAgaW50ZXJ2YWwucGF1c2UoKTtcblxuICAgICAgaWYgKGZsYWdzLmluZGV4T2YoZmxhZykgPT09IC0xKSB7XG4gICAgICAgIGZsYWdzLnB1c2goZmxhZyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmbGFncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgU3BsaWRlLmVtaXQobmFtZSArIFwiOnBhdXNlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogTGlzdGVuIHNvbWUgZXZlbnRzLlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcbiAgICB2YXIgc2libGluZyA9IFNwbGlkZS5zaWJsaW5nO1xuICAgIHZhciBlbG1zID0gW1NwbGlkZS5yb290LCBzaWJsaW5nID8gc2libGluZy5yb290IDogbnVsbF07XG5cbiAgICBpZiAob3B0aW9ucy5wYXVzZU9uSG92ZXIpIHtcbiAgICAgIHN3aXRjaE9uKGVsbXMsICdtb3VzZWxlYXZlJywgUEFVU0VfRkxBR1MuSE9WRVIsIHRydWUpO1xuICAgICAgc3dpdGNoT24oZWxtcywgJ21vdXNlZW50ZXInLCBQQVVTRV9GTEFHUy5IT1ZFUiwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBhdXNlT25Gb2N1cykge1xuICAgICAgc3dpdGNoT24oZWxtcywgJ2ZvY3Vzb3V0JywgUEFVU0VfRkxBR1MuRk9DVVMsIHRydWUpO1xuICAgICAgc3dpdGNoT24oZWxtcywgJ2ZvY3VzaW4nLCBQQVVTRV9GTEFHUy5GT0NVUywgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChFbGVtZW50cy5wbGF5KSB7XG4gICAgICBTcGxpZGUub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBOZWVkIHRvIGJlIHJlbW92ZWQgYSBmb2N1cyBmbGFnIGF0IGZpcnN0LlxuICAgICAgICBBdXRvcGxheS5wbGF5KFBBVVNFX0ZMQUdTLkZPQ1VTKTtcbiAgICAgICAgQXV0b3BsYXkucGxheShQQVVTRV9GTEFHUy5NQU5VQUwpO1xuICAgICAgfSwgRWxlbWVudHMucGxheSk7XG4gICAgfVxuXG4gICAgaWYgKEVsZW1lbnRzLnBhdXNlKSB7XG4gICAgICBzd2l0Y2hPbihbRWxlbWVudHMucGF1c2VdLCAnY2xpY2snLCBQQVVTRV9GTEFHUy5NQU5VQUwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBTcGxpZGUub24oJ21vdmUgcmVmcmVzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIEF1dG9wbGF5LnBsYXkoKTtcbiAgICB9KSAvLyBSZXdpbmQgdGhlIHRpbWVyLlxuICAgIC5vbignZGVzdHJveScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIEF1dG9wbGF5LnBhdXNlKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUGxheSBvciBwYXVzZSBvbiB0aGUgZ2l2ZW4gZXZlbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnRbXX0gZWxtcyAgLSBFbGVtZW50cy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgZXZlbnQgLSBBbiBldmVudCBuYW1lIG9yIG5hbWVzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgICBmbGFnICAtIEEgcGF1c2UgZmxhZyBkZWZpbmVkIG9uIHRoZSB0b3AuXHJcbiAgICogQHBhcmFtIHtib29sZWFufSAgIHBsYXkgIC0gRGV0ZXJtaW5lIHdoZXRoZXIgdG8gcGxheSBvciBwYXVzZS5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN3aXRjaE9uKGVsbXMsIGV2ZW50LCBmbGFnLCBwbGF5KSB7XG4gICAgZWxtcy5mb3JFYWNoKGZ1bmN0aW9uIChlbG0pIHtcbiAgICAgIFNwbGlkZS5vbihldmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBBdXRvcGxheVtwbGF5ID8gJ3BsYXknIDogJ3BhdXNlJ10oZmxhZyk7XG4gICAgICB9LCBlbG0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIEF1dG9wbGF5O1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9jb3Zlci9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGNoYW5nZSBhbiBpbWcgZWxlbWVudCB0byBiYWNrZ3JvdW5kIGltYWdlIG9mIGl0cyB3cmFwcGVyLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBjaGFuZ2UgYW4gaW1nIGVsZW1lbnQgdG8gYmFja2dyb3VuZCBpbWFnZSBvZiBpdHMgd3JhcHBlci5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9IENvbXBvbmVudHMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvdmVyID0gKGZ1bmN0aW9uIChTcGxpZGUsIENvbXBvbmVudHMpIHtcbiAgLyoqXHJcbiAgICogSG9sZCBvcHRpb25zLlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cbiAgdmFyIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcbiAgLyoqXHJcbiAgICogQ292ZXIgY29tcG9uZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIENvdmVyID0ge1xuICAgIC8qKlxyXG4gICAgICogUmVxdWlyZWQgb25seSB3aGVuIFwiY292ZXJcIiBvcHRpb24gaXMgdHJ1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xuICAgIHJlcXVpcmVkOiBvcHRpb25zLmNvdmVyLFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICBTcGxpZGUub24oJ2xhenlsb2FkOmxvYWRlZCcsIGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgY292ZXIoaW1nLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICAgIFNwbGlkZS5vbignbW91bnRlZCB1cGRhdGVkIHJlZnJlc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcHBseShmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95LlxyXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGFwcGx5KHRydWUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQXBwbHkgXCJjb3ZlclwiIHRvIGFsbCBzbGlkZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVuY292ZXIgLSBJZiB0cnVlLCBcImNvdmVyXCIgd2lsbCBiZSBjbGVhci5cclxuICAgKi9cblxuICBmdW5jdGlvbiBhcHBseSh1bmNvdmVyKSB7XG4gICAgQ29tcG9uZW50cy5FbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChTbGlkZSkge1xuICAgICAgdmFyIGltZyA9IGNoaWxkKFNsaWRlLnNsaWRlLCAnSU1HJykgfHwgY2hpbGQoU2xpZGUuY29udGFpbmVyLCAnSU1HJyk7XG5cbiAgICAgIGlmIChpbWcgJiYgaW1nLnNyYykge1xuICAgICAgICBjb3ZlcihpbWcsIHVuY292ZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIFNldCBiYWNrZ3JvdW5kIGltYWdlIG9mIHRoZSBwYXJlbnQgZWxlbWVudCwgdXNpbmcgc291cmNlIG9mIHRoZSBnaXZlbiBpbWFnZSBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBpbWcgICAgIC0gQW4gaW1hZ2UgZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVuY292ZXIgLSBSZXNldCBcImNvdmVyXCIuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBjb3ZlcihpbWcsIHVuY292ZXIpIHtcbiAgICBhcHBseVN0eWxlKGltZy5wYXJlbnRFbGVtZW50LCB7XG4gICAgICBiYWNrZ3JvdW5kOiB1bmNvdmVyID8gJycgOiBcImNlbnRlci9jb3ZlciBuby1yZXBlYXQgdXJsKFxcXCJcIiArIGltZy5zcmMgKyBcIlxcXCIpXCJcbiAgICB9KTtcbiAgICBhcHBseVN0eWxlKGltZywge1xuICAgICAgZGlzcGxheTogdW5jb3ZlciA/ICcnIDogJ25vbmUnXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gQ292ZXI7XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2Fycm93cy9wYXRoLmpzXG4vKipcclxuICogRXhwb3J0IHZlY3RvciBwYXRoIGZvciBhbiBhcnJvdy5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG4vKipcclxuICogTmFtZXNwYWNlIGRlZmluaXRpb24gZm9yIFNWRyBlbGVtZW50LlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cbnZhciBYTUxfTkFNRV9TUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4vKipcclxuICogVGhlIGFycm93IHZlY3RvciBwYXRoLlxyXG4gKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKi9cblxudmFyIFBBVEggPSAnbTE1LjUgMC45MzItNC4zIDQuMzggMTQuNSAxNC42LTE0LjUgMTQuNSA0LjMgNC40IDE0LjYtMTQuNiA0LjQtNC4zLTQuNC00LjQtMTQuNi0xNC42eic7XG4vKipcclxuICogU1ZHIHdpZHRoIGFuZCBoZWlnaHQuXHJcbiAqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqL1xuXG52YXIgU0laRSA9IDQwO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvYXJyb3dzL2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgYXBwZW5kaW5nIHByZXYvbmV4dCBhcnJvd3MuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG5cbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBhcHBlbmRpbmcgcHJldi9uZXh0IGFycm93cy5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9IENvbXBvbmVudHMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb21wb25lbnRzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgICAgICAtIEEgY29tcG9uZW50IG5hbWUgYXMgYSBsb3dlcmNhc2Ugc3RyaW5nLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGFycm93cyA9IChmdW5jdGlvbiAoU3BsaWRlLCBDb21wb25lbnRzLCBuYW1lKSB7XG4gIC8qKlxyXG4gICAqIFByZXZpb3VzIGFycm93IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7RWxlbWVudHx1bmRlZmluZWR9XHJcbiAgICovXG4gIHZhciBwcmV2O1xuICAvKipcclxuICAgKiBOZXh0IGFycm93IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7RWxlbWVudHx1bmRlZmluZWR9XHJcbiAgICovXG5cbiAgdmFyIG5leHQ7XG4gIC8qKlxyXG4gICAqIFN0b3JlIHRoZSBjbGFzcyBsaXN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgY2xhc3NlcyA9IFNwbGlkZS5jbGFzc2VzO1xuICAvKipcclxuICAgKiBIb2xkIHRoZSByb290IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7RWxlbWVudH1cclxuICAgKi9cblxuICB2YXIgcm9vdCA9IFNwbGlkZS5yb290O1xuICAvKipcclxuICAgKiBXaGV0aGVyIGFycm93cyBhcmUgY3JlYXRlZCBwcm9ncmFtbWF0aWNhbGx5IG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuXG4gIHZhciBjcmVhdGVkO1xuICAvKipcclxuICAgKiBIb2xkIHRoZSBFbGVtZW50cyBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBFbGVtZW50cyA9IENvbXBvbmVudHMuRWxlbWVudHM7XG4gIC8qKlxyXG4gICAqIEFycm93cyBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgQXJyb3dzID0ge1xuICAgIC8qKlxyXG4gICAgICogUmVxdWlyZWQgd2hlbiB0aGUgYXJyb3dzIG9wdGlvbiBpcyB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXG4gICAgcmVxdWlyZWQ6IFNwbGlkZS5vcHRpb25zLmFycm93cyxcblxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgLy8gQXR0ZW1wdCB0byBnZXQgYXJyb3dzIGZyb20gSFRNTCBzb3VyY2UuXG4gICAgICBwcmV2ID0gRWxlbWVudHMuYXJyb3dzLnByZXY7XG4gICAgICBuZXh0ID0gRWxlbWVudHMuYXJyb3dzLm5leHQ7IC8vIElmIGFycm93cyB3ZXJlIG5vdCBmb3VuZCBpbiBIVE1MLCBsZXQncyBnZW5lcmF0ZSB0aGVtLlxuXG4gICAgICBpZiAoKCFwcmV2IHx8ICFuZXh0KSAmJiBTcGxpZGUub3B0aW9ucy5hcnJvd3MpIHtcbiAgICAgICAgcHJldiA9IGNyZWF0ZUFycm93KHRydWUpO1xuICAgICAgICBuZXh0ID0gY3JlYXRlQXJyb3coZmFsc2UpO1xuICAgICAgICBjcmVhdGVkID0gdHJ1ZTtcbiAgICAgICAgYXBwZW5kQXJyb3dzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2ICYmIG5leHQpIHtcbiAgICAgICAgYmluZCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFycm93cyA9IHtcbiAgICAgICAgcHJldjogcHJldixcbiAgICAgICAgbmV4dDogbmV4dFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYWZ0ZXIgYWxsIGNvbXBvbmVudHMgYXJlIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgU3BsaWRlLmVtaXQobmFtZSArIFwiOm1vdW50ZWRcIiwgcHJldiwgbmV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveS5cclxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICByZW1vdmVBdHRyaWJ1dGUoW3ByZXYsIG5leHRdLCAnZGlzYWJsZWQnKTtcblxuICAgICAgaWYgKGNyZWF0ZWQpIHtcbiAgICAgICAgZG9tX3JlbW92ZShwcmV2LnBhcmVudEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogTGlzdGVuIHRvIG5hdGl2ZSBhbmQgY3VzdG9tIGV2ZW50cy5cclxuICAgKi9cblxuICBmdW5jdGlvbiBiaW5kKCkge1xuICAgIFNwbGlkZS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBTcGxpZGUuZ28oJzwnKTtcbiAgICB9LCBwcmV2KS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBTcGxpZGUuZ28oJz4nKTtcbiAgICB9LCBuZXh0KS5vbignbW91bnRlZCBtb3ZlIHVwZGF0ZWQgcmVmcmVzaCcsIHVwZGF0ZURpc2FibGVkKTtcbiAgfVxuICAvKipcclxuICAgKiBVcGRhdGUgYSBkaXNhYmxlZCBhdHRyaWJ1dGUuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiB1cGRhdGVEaXNhYmxlZCgpIHtcbiAgICB2YXIgX0NvbXBvbmVudHMkQ29udHJvbGxlID0gQ29tcG9uZW50cy5Db250cm9sbGVyLFxuICAgICAgICBwcmV2SW5kZXggPSBfQ29tcG9uZW50cyRDb250cm9sbGUucHJldkluZGV4LFxuICAgICAgICBuZXh0SW5kZXggPSBfQ29tcG9uZW50cyRDb250cm9sbGUubmV4dEluZGV4O1xuICAgIHZhciBpc0Vub3VnaCA9IFNwbGlkZS5sZW5ndGggPiBTcGxpZGUub3B0aW9ucy5wZXJQYWdlIHx8IFNwbGlkZS5pcyhMT09QKTtcbiAgICBwcmV2LmRpc2FibGVkID0gcHJldkluZGV4IDwgMCB8fCAhaXNFbm91Z2g7XG4gICAgbmV4dC5kaXNhYmxlZCA9IG5leHRJbmRleCA8IDAgfHwgIWlzRW5vdWdoO1xuICAgIFNwbGlkZS5lbWl0KG5hbWUgKyBcIjp1cGRhdGVkXCIsIHByZXYsIG5leHQsIHByZXZJbmRleCwgbmV4dEluZGV4KTtcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgYSB3cmFwcGVyIGVsZW1lbnQgYW5kIGFwcGVuZCBhcnJvd3MuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBhcHBlbmRBcnJvd3MoKSB7XG4gICAgdmFyIHdyYXBwZXIgPSBjcmVhdGUoJ2RpdicsIHtcbiAgICAgIFwiY2xhc3NcIjogY2xhc3Nlcy5hcnJvd3NcbiAgICB9KTtcbiAgICBhcHBlbmQod3JhcHBlciwgcHJldik7XG4gICAgYXBwZW5kKHdyYXBwZXIsIG5leHQpO1xuICAgIHZhciBzbGlkZXIgPSBFbGVtZW50cy5zbGlkZXI7XG4gICAgdmFyIHBhcmVudCA9IFNwbGlkZS5vcHRpb25zLmFycm93cyA9PT0gJ3NsaWRlcicgJiYgc2xpZGVyID8gc2xpZGVyIDogcm9vdDtcbiAgICBiZWZvcmUod3JhcHBlciwgcGFyZW50LmZpcnN0RWxlbWVudENoaWxkKTtcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgYW4gYXJyb3cgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldiAtIERldGVybWluZSB0byBjcmVhdGUgYSBwcmV2IGFycm93IG9yIG5leHQgYXJyb3cuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSAtIEEgY3JlYXRlZCBhcnJvdyBlbGVtZW50LlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyb3cocHJldikge1xuICAgIHZhciBhcnJvdyA9IFwiPGJ1dHRvbiBjbGFzcz1cXFwiXCIgKyBjbGFzc2VzLmFycm93ICsgXCIgXCIgKyAocHJldiA/IGNsYXNzZXMucHJldiA6IGNsYXNzZXMubmV4dCkgKyBcIlxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIj5cIiArIChcIjxzdmcgeG1sbnM9XFxcIlwiICsgWE1MX05BTUVfU1BBQ0UgKyBcIlxcXCJcXHR2aWV3Qm94PVxcXCIwIDAgXCIgKyBTSVpFICsgXCIgXCIgKyBTSVpFICsgXCJcXFwiXFx0d2lkdGg9XFxcIlwiICsgU0laRSArIFwiXFxcIlxcdGhlaWdodD1cXFwiXCIgKyBTSVpFICsgXCJcXFwiPlwiKSArIChcIjxwYXRoIGQ9XFxcIlwiICsgKFNwbGlkZS5vcHRpb25zLmFycm93UGF0aCB8fCBQQVRIKSArIFwiXFxcIiAvPlwiKTtcbiAgICByZXR1cm4gZG9taWZ5KGFycm93KTtcbiAgfVxuXG4gIHJldHVybiBBcnJvd3M7XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL3BhZ2luYXRpb24vaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBoYW5kbGluZyBwYWdpbmF0aW9uXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG4vKipcclxuICogVGhlIGV2ZW50IG5hbWUgZm9yIHVwZGF0aW5nIHNvbWUgYXR0cmlidXRlcyBvZiBwYWdpbmF0aW9uIG5vZGVzLlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxudmFyIEFUVFJJQlVURVNfVVBEQVRFX0VWRU5UID0gJ21vdmUucGFnZSc7XG4vKipcclxuICogVGhlIGV2ZW50IG5hbWUgZm9yIHJlY3JlYXRpbmcgcGFnaW5hdGlvbi5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG5cbnZhciBVUERBVEVfRVZFTlQgPSAndXBkYXRlZC5wYWdlIHJlZnJlc2gucGFnZSc7XG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgaGFuZGxpbmcgcGFnaW5hdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlICAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gQ29tcG9uZW50cyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbXBvbmVudHMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgICAgIC0gQSBjb21wb25lbnQgbmFtZSBhcyBhIGxvd2VyY2FzZSBzdHJpbmcuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgcGFnaW5hdGlvbiA9IChmdW5jdGlvbiAoU3BsaWRlLCBDb21wb25lbnRzLCBuYW1lKSB7XG4gIC8qKlxyXG4gICAqIFN0b3JlIGFsbCBkYXRhIGZvciBwYWdpbmF0aW9uLlxyXG4gICAqIC0gbGlzdDogQSBsaXN0IGVsZW1lbnQuXHJcbiAgICogLSBpdGVtczogQW4gYXJyYXkgdGhhdCBjb250YWlucyBvYmplY3RzKGxpLCBidXR0b24sIGluZGV4LCBwYWdlKS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG4gIHZhciBkYXRhID0ge307XG4gIC8qKlxyXG4gICAqIEhvbGQgdGhlIEVsZW1lbnRzIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIEVsZW1lbnRzID0gQ29tcG9uZW50cy5FbGVtZW50cztcbiAgLyoqXHJcbiAgICogUGFnaW5hdGlvbiBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgUGFnaW5hdGlvbiA9IHtcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIHZhciBwYWdpbmF0aW9uID0gU3BsaWRlLm9wdGlvbnMucGFnaW5hdGlvbjtcblxuICAgICAgaWYgKHBhZ2luYXRpb24pIHtcbiAgICAgICAgZGF0YSA9IGNyZWF0ZVBhZ2luYXRpb24oKTtcbiAgICAgICAgdmFyIHNsaWRlciA9IEVsZW1lbnRzLnNsaWRlcjtcbiAgICAgICAgdmFyIHBhcmVudCA9IHBhZ2luYXRpb24gPT09ICdzbGlkZXInICYmIHNsaWRlciA/IHNsaWRlciA6IFNwbGlkZS5yb290O1xuICAgICAgICBhcHBlbmQocGFyZW50LCBkYXRhLmxpc3QpO1xuICAgICAgICBTcGxpZGUub24oQVRUUklCVVRFU19VUERBVEVfRVZFTlQsIHVwZGF0ZUF0dHJpYnV0ZXMpO1xuICAgICAgfVxuXG4gICAgICBTcGxpZGUub2ZmKFVQREFURV9FVkVOVCkub24oVVBEQVRFX0VWRU5ULCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFBhZ2luYXRpb24uZGVzdHJveSgpO1xuXG4gICAgICAgIGlmIChTcGxpZGUub3B0aW9ucy5wYWdpbmF0aW9uKSB7XG4gICAgICAgICAgUGFnaW5hdGlvbi5tb3VudCgpO1xuICAgICAgICAgIFBhZ2luYXRpb24ubW91bnRlZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYWZ0ZXIgYWxsIGNvbXBvbmVudHMgYXJlIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgaWYgKFNwbGlkZS5vcHRpb25zLnBhZ2luYXRpb24pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gU3BsaWRlLmluZGV4O1xuICAgICAgICBTcGxpZGUuZW1pdChuYW1lICsgXCI6bW91bnRlZFwiLCBkYXRhLCB0aGlzLmdldEl0ZW0oaW5kZXgpKTtcbiAgICAgICAgdXBkYXRlQXR0cmlidXRlcyhpbmRleCwgLTEpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kgdGhlIHBhZ2luYXRpb24uXHJcbiAgICAgKiBCZSBhd2FyZSB0aGF0IG5vZGUucmVtb3ZlKCkgaXMgbm90IHN1cHBvcnRlZCBieSBJRS5cclxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBkb21fcmVtb3ZlKGRhdGEubGlzdCk7XG5cbiAgICAgIGlmIChkYXRhLml0ZW1zKSB7XG4gICAgICAgIGRhdGEuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIFNwbGlkZS5vZmYoJ2NsaWNrJywgaXRlbS5idXR0b24pO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gRG8gbm90IHJlbW92ZSBVUERBVEVfRVZFTlQgdG8gcmVjcmVhdGUgcGFnaW5hdGlvbiBpZiBuZWVkZWQuXG5cblxuICAgICAgU3BsaWRlLm9mZihBVFRSSUJVVEVTX1VQREFURV9FVkVOVCk7XG4gICAgICBkYXRhID0ge307XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGFuIGl0ZW0gYnkgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gQSBzbGlkZSBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSAtIEFuIGl0ZW0gb2JqZWN0IG9uIHN1Y2Nlc3Mgb3IgdW5kZWZpbmVkIG9uIGZhaWx1cmUuXHJcbiAgICAgKi9cbiAgICBnZXRJdGVtOiBmdW5jdGlvbiBnZXRJdGVtKGluZGV4KSB7XG4gICAgICByZXR1cm4gZGF0YS5pdGVtc1tDb21wb25lbnRzLkNvbnRyb2xsZXIudG9QYWdlKGluZGV4KV07XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIG9iamVjdCBjb250YWluaW5nIHBhZ2luYXRpb24gZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gUGFnaW5hdGlvbiBkYXRhIGluY2x1ZGluZyBsaXN0IGFuZCBpdGVtcy5cclxuICAgICAqL1xuICAgIGdldCBkYXRhKCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBhdHRyaWJ1dGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4ICAgICAtIEFjdGl2ZSBpbmRleC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcHJldkluZGV4IC0gUHJldiBpbmRleC5cclxuICAgKi9cblxuICBmdW5jdGlvbiB1cGRhdGVBdHRyaWJ1dGVzKGluZGV4LCBwcmV2SW5kZXgpIHtcbiAgICB2YXIgcHJldiA9IFBhZ2luYXRpb24uZ2V0SXRlbShwcmV2SW5kZXgpO1xuICAgIHZhciBjdXJyID0gUGFnaW5hdGlvbi5nZXRJdGVtKGluZGV4KTtcbiAgICB2YXIgYWN0aXZlID0gU1RBVFVTX0NMQVNTRVMuYWN0aXZlO1xuXG4gICAgaWYgKHByZXYpIHtcbiAgICAgIHJlbW92ZUNsYXNzKHByZXYuYnV0dG9uLCBhY3RpdmUpO1xuICAgIH1cblxuICAgIGlmIChjdXJyKSB7XG4gICAgICBhZGRDbGFzcyhjdXJyLmJ1dHRvbiwgYWN0aXZlKTtcbiAgICB9XG5cbiAgICBTcGxpZGUuZW1pdChuYW1lICsgXCI6dXBkYXRlZFwiLCBkYXRhLCBwcmV2LCBjdXJyKTtcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgYSB3cmFwcGVyIGFuZCBidXR0b24gZWxlbWVudHMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gQW4gb2JqZWN0IGNvbnRhaW5zIGFsbCBkYXRhLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY3JlYXRlUGFnaW5hdGlvbigpIHtcbiAgICB2YXIgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuICAgIHZhciBjbGFzc2VzID0gU3BsaWRlLmNsYXNzZXM7XG4gICAgdmFyIGxpc3QgPSBjcmVhdGUoJ3VsJywge1xuICAgICAgXCJjbGFzc1wiOiBjbGFzc2VzLnBhZ2luYXRpb25cbiAgICB9KTtcbiAgICB2YXIgaXRlbXMgPSBFbGVtZW50cy5nZXRTbGlkZXMoZmFsc2UpLmZpbHRlcihmdW5jdGlvbiAoU2xpZGUpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmZvY3VzICE9PSBmYWxzZSB8fCBTbGlkZS5pbmRleCAlIG9wdGlvbnMucGVyUGFnZSA9PT0gMDtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKFNsaWRlLCBwYWdlKSB7XG4gICAgICB2YXIgbGkgPSBjcmVhdGUoJ2xpJywge30pO1xuICAgICAgdmFyIGJ1dHRvbiA9IGNyZWF0ZSgnYnV0dG9uJywge1xuICAgICAgICBcImNsYXNzXCI6IGNsYXNzZXMucGFnZSxcbiAgICAgICAgdHlwZTogJ2J1dHRvbidcbiAgICAgIH0pO1xuICAgICAgYXBwZW5kKGxpLCBidXR0b24pO1xuICAgICAgYXBwZW5kKGxpc3QsIGxpKTtcbiAgICAgIFNwbGlkZS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFNwbGlkZS5nbyhcIj5cIiArIHBhZ2UpO1xuICAgICAgfSwgYnV0dG9uKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpOiBsaSxcbiAgICAgICAgYnV0dG9uOiBidXR0b24sXG4gICAgICAgIHBhZ2U6IHBhZ2UsXG4gICAgICAgIFNsaWRlczogRWxlbWVudHMuZ2V0U2xpZGVzQnlQYWdlKHBhZ2UpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBsaXN0OiBsaXN0LFxuICAgICAgaXRlbXM6IGl0ZW1zXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBQYWdpbmF0aW9uO1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9sYXp5bG9hZC9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGxvYWRpbmcgc2xpZGVyIGltYWdlcyBsYXppbHkuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG5cbi8qKlxyXG4gKiBUaGUgbmFtZSBmb3IgYSBkYXRhIGF0dHJpYnV0ZSBvZiBzcmMuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG52YXIgU1JDX0RBVEFfTkFNRSA9ICdkYXRhLXNwbGlkZS1sYXp5Jztcbi8qKlxyXG4gKiBUaGUgbmFtZSBmb3IgYSBkYXRhIGF0dHJpYnV0ZSBvZiBzcmNzZXQuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG52YXIgU1JDU0VUX0RBVEFfTkFNRSA9ICdkYXRhLXNwbGlkZS1sYXp5LXNyY3NldCc7XG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgbG9hZGluZyBzbGlkZXIgaW1hZ2VzIGxhemlseS5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9IENvbXBvbmVudHMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb21wb25lbnRzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgICAgICAtIEEgY29tcG9uZW50IG5hbWUgYXMgYSBsb3dlcmNhc2Ugc3RyaW5nLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGxhenlsb2FkID0gKGZ1bmN0aW9uIChTcGxpZGUsIENvbXBvbmVudHMsIG5hbWUpIHtcbiAgLyoqXHJcbiAgICogTmV4dCBpbmRleCBmb3Igc2VxdWVudGlhbCBsb2FkaW5nLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgdmFyIG5leHRJbmRleDtcbiAgLyoqXHJcbiAgICogU3RvcmUgb2JqZWN0cyBjb250YWluaW5nIGFuIGltZyBlbGVtZW50IGFuZCBhIFNsaWRlIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3RbXX1cclxuICAgKi9cblxuICB2YXIgaW1hZ2VzO1xuICAvKipcclxuICAgKiBTdG9yZSB0aGUgb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBsb2FkIGltYWdlcyBzZXF1ZW50aWFsbHkgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG5cbiAgdmFyIGlzU2VxdWVudGlhbCA9IG9wdGlvbnMubGF6eUxvYWQgPT09ICdzZXF1ZW50aWFsJztcbiAgLyoqXHJcbiAgICogTGF6eWxvYWQgY29tcG9uZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIExhenlsb2FkID0ge1xuICAgIC8qKlxyXG4gICAgICogTW91bnQgb25seSB3aGVuIHRoZSBsYXp5bG9hZCBvcHRpb24gaXMgcHJvdmlkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cbiAgICByZXF1aXJlZDogb3B0aW9ucy5sYXp5TG9hZCxcblxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgU3BsaWRlLm9uKCdtb3VudGVkIHJlZnJlc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluaXQoKTtcbiAgICAgICAgQ29tcG9uZW50cy5FbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChTbGlkZSkge1xuICAgICAgICAgIGVhY2goU2xpZGUuc2xpZGUucXVlcnlTZWxlY3RvckFsbChcIltcIiArIFNSQ19EQVRBX05BTUUgKyBcIl0sIFtcIiArIFNSQ1NFVF9EQVRBX05BTUUgKyBcIl1cIiksIGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgICAgIGlmICghaW1nLnNyYyAmJiAhaW1nLnNyY3NldCkge1xuICAgICAgICAgICAgICBpbWFnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW1nOiBpbWcsXG4gICAgICAgICAgICAgICAgU2xpZGU6IFNsaWRlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhcHBseVN0eWxlKGltZywge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGlzU2VxdWVudGlhbCkge1xuICAgICAgICAgIGxvYWROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWlzU2VxdWVudGlhbCkge1xuICAgICAgICBTcGxpZGUub24oXCJtb3VudGVkIHJlZnJlc2ggbW92ZWQuXCIgKyBuYW1lLCBjaGVjayk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveS5cclxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGluaXRcbiAgfTtcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBwYXJhbWV0ZXJzLlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgaW1hZ2VzID0gW107XG4gICAgbmV4dEluZGV4ID0gMDtcbiAgfVxuICAvKipcclxuICAgKiBDaGVjayBob3cgY2xvc2UgZWFjaCBpbWFnZSBpcyBmcm9tIHRoZSBhY3RpdmUgc2xpZGUgYW5kXHJcbiAgICogZGV0ZXJtaW5lIHdoZXRoZXIgdG8gc3RhcnQgbG9hZGluZyBvciBub3QsIGFjY29yZGluZyB0byB0aGUgZGlzdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBDdXJyZW50IGluZGV4LlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY2hlY2soaW5kZXgpIHtcbiAgICBpbmRleCA9IGlzTmFOKGluZGV4KSA/IFNwbGlkZS5pbmRleCA6IGluZGV4O1xuICAgIGltYWdlcyA9IGltYWdlcy5maWx0ZXIoZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICBpZiAoaW1hZ2UuU2xpZGUuaXNXaXRoaW4oaW5kZXgsIG9wdGlvbnMucGVyUGFnZSAqIChvcHRpb25zLnByZWxvYWRQYWdlcyArIDEpKSkge1xuICAgICAgICBsb2FkKGltYWdlLmltZywgaW1hZ2UuU2xpZGUpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pOyAvLyBVbmJpbmQgaWYgYWxsIGltYWdlcyBhcmUgbG9hZGVkLlxuXG4gICAgaWYgKCFpbWFnZXNbMF0pIHtcbiAgICAgIFNwbGlkZS5vZmYoXCJtb3ZlZC5cIiArIG5hbWUpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBTdGFydCBsb2FkaW5nIGFuIGltYWdlLlxyXG4gICAqIENyZWF0aW5nIGEgY2xvbmUgb2YgdGhlIGltYWdlIGVsZW1lbnQgc2luY2Ugc2V0dGluZyBzcmMgYXR0cmlidXRlIGRpcmVjdGx5IHRvIGl0XHJcbiAgICogb2Z0ZW4gb2NjdXJzICdoaXRjaCcsIGJsb2NraW5nIHNvbWUgb3RoZXIgcHJvY2Vzc2VzIG9mIGEgYnJvd3Nlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gaW1nICAgLSBBbiBpbWFnZSBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgU2xpZGUgLSBBIFNsaWRlIG9iamVjdC5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGxvYWQoaW1nLCBTbGlkZSkge1xuICAgIGFkZENsYXNzKFNsaWRlLnNsaWRlLCBTVEFUVVNfQ0xBU1NFUy5sb2FkaW5nKTtcbiAgICB2YXIgc3Bpbm5lciA9IGNyZWF0ZSgnc3BhbicsIHtcbiAgICAgIFwiY2xhc3NcIjogU3BsaWRlLmNsYXNzZXMuc3Bpbm5lclxuICAgIH0pO1xuICAgIGFwcGVuZChpbWcucGFyZW50RWxlbWVudCwgc3Bpbm5lcik7XG5cbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgbG9hZGVkKGltZywgc3Bpbm5lciwgU2xpZGUsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBsb2FkZWQoaW1nLCBzcGlubmVyLCBTbGlkZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIHNldEF0dHJpYnV0ZShpbWcsICdzcmNzZXQnLCBnZXRBdHRyaWJ1dGUoaW1nLCBTUkNTRVRfREFUQV9OQU1FKSB8fCAnJyk7XG4gICAgc2V0QXR0cmlidXRlKGltZywgJ3NyYycsIGdldEF0dHJpYnV0ZShpbWcsIFNSQ19EQVRBX05BTUUpIHx8ICcnKTtcbiAgfVxuICAvKipcclxuICAgKiBTdGFydCBsb2FkaW5nIGEgbmV4dCBpbWFnZSBpbiBpbWFnZXMgYXJyYXkuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBsb2FkTmV4dCgpIHtcbiAgICBpZiAobmV4dEluZGV4IDwgaW1hZ2VzLmxlbmd0aCkge1xuICAgICAgdmFyIGltYWdlID0gaW1hZ2VzW25leHRJbmRleF07XG4gICAgICBsb2FkKGltYWdlLmltZywgaW1hZ2UuU2xpZGUpO1xuICAgIH1cblxuICAgIG5leHRJbmRleCsrO1xuICB9XG4gIC8qKlxyXG4gICAqIENhbGxlZCBqdXN0IGFmdGVyIHRoZSBpbWFnZSB3YXMgbG9hZGVkIG9yIGxvYWRpbmcgd2FzIGFib3J0ZWQgYnkgc29tZSBlcnJvci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gaW1nICAgICAtIEFuIGltYWdlIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBzcGlubmVyIC0gQSBzcGlubmVyIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9ICBTbGlkZSAgIC0gQSBTbGlkZSBvYmplY3QuXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBlcnJvciAgIC0gVHJ1ZSBpZiB0aGUgaW1hZ2Ugd2FzIGxvYWRlZCBzdWNjZXNzZnVsbHkgb3IgZmFsc2Ugb24gZXJyb3IuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBsb2FkZWQoaW1nLCBzcGlubmVyLCBTbGlkZSwgZXJyb3IpIHtcbiAgICByZW1vdmVDbGFzcyhTbGlkZS5zbGlkZSwgU1RBVFVTX0NMQVNTRVMubG9hZGluZyk7XG5cbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICBkb21fcmVtb3ZlKHNwaW5uZXIpO1xuICAgICAgYXBwbHlTdHlsZShpbWcsIHtcbiAgICAgICAgZGlzcGxheTogJydcbiAgICAgIH0pO1xuICAgICAgU3BsaWRlLmVtaXQobmFtZSArIFwiOmxvYWRlZFwiLCBpbWcpLmVtaXQoJ3Jlc2l6ZScpO1xuICAgIH1cblxuICAgIGlmIChpc1NlcXVlbnRpYWwpIHtcbiAgICAgIGxvYWROZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIExhenlsb2FkO1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29uc3RhbnRzL2ExMXkuanNcbi8qKlxyXG4gKiBFeHBvcnQgYXJpYSBhdHRyaWJ1dGUgbmFtZXMuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuLyoqXHJcbiAqIEF0dHJpYnV0ZSBuYW1lIGZvciBhcmlhLWN1cnJlbnQuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xudmFyIEFSSUFfQ1VSUkVOUlQgPSAnYXJpYS1jdXJyZW50Jztcbi8qKlxyXG4gKiBBdHRyaWJ1dGUgbmFtZSBmb3IgYXJpYS1jb250cm9sLlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxudmFyIEFSSUFfQ09OVFJPTFMgPSAnYXJpYS1jb250cm9scyc7XG4vKipcclxuICogQXR0cmlidXRlIG5hbWUgZm9yIGFyaWEtY29udHJvbC5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG5cbnZhciBBUklBX0xBQkVMID0gJ2FyaWEtbGFiZWwnO1xuLyoqXHJcbiAqIEF0dHJpYnV0ZSBuYW1lIGZvciBhcmlhLWxhYmVsbGVkYnkuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG52YXIgQVJJQV9MQUJFTExFREJZID0gJ2FyaWEtbGFiZWxsZWRieSc7XG4vKipcclxuICogQXR0cmlidXRlIG5hbWUgZm9yIGFyaWEtaGlkZGVuLlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxudmFyIEFSSUFfSElEREVOID0gJ2FyaWEtaGlkZGVuJztcbi8qKlxyXG4gKiBBdHRyaWJ1dGUgbmFtZSBmb3IgdGFiLWluZGV4LlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxudmFyIFRBQl9JTkRFWCA9ICd0YWJpbmRleCc7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9rZXlib2FyZC9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGNvbnRyb2xsaW5nIHNsaWRlcyB2aWEga2V5Ym9hcmQuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG4vKipcclxuICogTWFwIGEga2V5IHRvIGEgc2xpZGUgY29udHJvbC5cclxuICpcclxuICogQHR5cGUge09iamVjdH1cclxuICovXG5cbnZhciBLRVlfTUFQID0ge1xuICBsdHI6IHtcbiAgICBBcnJvd0xlZnQ6ICc8JyxcbiAgICBBcnJvd1JpZ2h0OiAnPicsXG4gICAgLy8gRm9yIElFLlxuICAgIExlZnQ6ICc8JyxcbiAgICBSaWdodDogJz4nXG4gIH0sXG4gIHJ0bDoge1xuICAgIEFycm93TGVmdDogJz4nLFxuICAgIEFycm93UmlnaHQ6ICc8JyxcbiAgICAvLyBGb3IgSUUuXG4gICAgTGVmdDogJz4nLFxuICAgIFJpZ2h0OiAnPCdcbiAgfSxcbiAgdHRiOiB7XG4gICAgQXJyb3dVcDogJzwnLFxuICAgIEFycm93RG93bjogJz4nLFxuICAgIC8vIEZvciBJRS5cbiAgICBVcDogJzwnLFxuICAgIERvd246ICc+J1xuICB9XG59O1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGNvbnRyb2xsaW5nIHNsaWRlcyB2aWEga2V5Ym9hcmQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBrZXlib2FyZCA9IChmdW5jdGlvbiAoU3BsaWRlKSB7XG4gIC8qKlxyXG4gICAqIEhvbGQgdGhlIHRhcmdldCBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge0VsZW1lbnR8RG9jdW1lbnR8dW5kZWZpbmVkfVxyXG4gICAqL1xuICB2YXIgdGFyZ2V0O1xuICByZXR1cm4ge1xuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgU3BsaWRlLm9uKCdtb3VudGVkIHVwZGF0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG4gICAgICAgIHZhciByb290ID0gU3BsaWRlLnJvb3Q7XG4gICAgICAgIHZhciBtYXAgPSBLRVlfTUFQW29wdGlvbnMuZGlyZWN0aW9uXTtcbiAgICAgICAgdmFyIGtleWJvYXJkID0gb3B0aW9ucy5rZXlib2FyZDtcblxuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgU3BsaWRlLm9mZigna2V5ZG93bicsIHRhcmdldCk7XG4gICAgICAgICAgcmVtb3ZlQXR0cmlidXRlKHJvb3QsIFRBQl9JTkRFWCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5Ym9hcmQpIHtcbiAgICAgICAgICBpZiAoa2V5Ym9hcmQgPT09ICdmb2N1c2VkJykge1xuICAgICAgICAgICAgdGFyZ2V0ID0gcm9vdDtcbiAgICAgICAgICAgIHNldEF0dHJpYnV0ZShyb290LCBUQUJfSU5ERVgsIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBkb2N1bWVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBTcGxpZGUub24oJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKG1hcFtlLmtleV0pIHtcbiAgICAgICAgICAgICAgU3BsaWRlLmdvKG1hcFtlLmtleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvYTExeS9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGVuaGFuY2luZyBhY2Nlc3NpYmlsaXR5LlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgZW5oYW5jaW5nIGFjY2Vzc2liaWxpdHkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBDb21wb25lbnRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tcG9uZW50cy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBhMTF5ID0gKGZ1bmN0aW9uIChTcGxpZGUsIENvbXBvbmVudHMpIHtcbiAgLyoqXHJcbiAgICogSG9sZCBhIGkxOG4gb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cbiAgdmFyIGkxOG4gPSBTcGxpZGUuaTE4bjtcbiAgLyoqXHJcbiAgICogSG9sZCB0aGUgRWxlbWVudHMgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgRWxlbWVudHMgPSBDb21wb25lbnRzLkVsZW1lbnRzO1xuICAvKipcclxuICAgKiBBbGwgYXR0cmlidXRlcyByZWxhdGVkIHdpdGggQTExeS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtzdHJpbmdbXX1cclxuICAgKi9cblxuICB2YXIgYWxsQXR0cmlidXRlcyA9IFtBUklBX0hJRERFTiwgVEFCX0lOREVYLCBBUklBX0NPTlRST0xTLCBBUklBX0xBQkVMLCBBUklBX0NVUlJFTlJULCAncm9sZSddO1xuICAvKipcclxuICAgKiBBMTF5IGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBBMTF5ID0ge1xuICAgIC8qKlxyXG4gICAgICogUmVxdWlyZWQgb25seSB3aGVuIHRoZSBhY2Nlc3NpYmlsaXR5IG9wdGlvbiBpcyB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXG4gICAgcmVxdWlyZWQ6IFNwbGlkZS5vcHRpb25zLmFjY2Vzc2liaWxpdHksXG5cbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIFNwbGlkZS5vbigndmlzaWJsZScsIGZ1bmN0aW9uIChTbGlkZSkge1xuICAgICAgICB1cGRhdGVTbGlkZShTbGlkZS5zbGlkZSwgdHJ1ZSk7XG4gICAgICB9KS5vbignaGlkZGVuJywgZnVuY3Rpb24gKFNsaWRlKSB7XG4gICAgICAgIHVwZGF0ZVNsaWRlKFNsaWRlLnNsaWRlLCBmYWxzZSk7XG4gICAgICB9KS5vbignYXJyb3dzOm1vdW50ZWQnLCBpbml0QXJyb3dzKS5vbignYXJyb3dzOnVwZGF0ZWQnLCB1cGRhdGVBcnJvd3MpLm9uKCdwYWdpbmF0aW9uOm1vdW50ZWQnLCBpbml0UGFnaW5hdGlvbikub24oJ3BhZ2luYXRpb246dXBkYXRlZCcsIHVwZGF0ZVBhZ2luYXRpb24pLm9uKCdyZWZyZXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVBdHRyaWJ1dGUoQ29tcG9uZW50cy5DbG9uZXMuY2xvbmVzLCBhbGxBdHRyaWJ1dGVzKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoU3BsaWRlLm9wdGlvbnMuaXNOYXZpZ2F0aW9uKSB7XG4gICAgICAgIFNwbGlkZS5vbignbmF2aWdhdGlvbjptb3VudGVkIG5hdmlnYXRpb246dXBkYXRlZCcsIGluaXROYXZpZ2F0aW9uKS5vbignYWN0aXZlJywgZnVuY3Rpb24gKFNsaWRlKSB7XG4gICAgICAgICAgdXBkYXRlTmF2aWdhdGlvbihTbGlkZSwgdHJ1ZSk7XG4gICAgICAgIH0pLm9uKCdpbmFjdGl2ZScsIGZ1bmN0aW9uIChTbGlkZSkge1xuICAgICAgICAgIHVwZGF0ZU5hdmlnYXRpb24oU2xpZGUsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGluaXRBdXRvcGxheSgpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kuXHJcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdmFyIEFycm93cyA9IENvbXBvbmVudHMuQXJyb3dzO1xuICAgICAgdmFyIGFycm93cyA9IEFycm93cyA/IEFycm93cy5hcnJvd3MgOiB7fTtcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZShFbGVtZW50cy5zbGlkZXMuY29uY2F0KFthcnJvd3MucHJldiwgYXJyb3dzLm5leHQsIEVsZW1lbnRzLnBsYXksIEVsZW1lbnRzLnBhdXNlXSksIGFsbEF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIHNsaWRlIGF0dHJpYnV0ZXMgd2hlbiBpdCBnZXRzIHZpc2libGUgb3IgaGlkZGVuLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBzbGlkZSAgIC0gQSBzbGlkZSBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSAtIFRydWUgd2hlbiB0aGUgc2xpZGUgZ2V0cyB2aXNpYmxlLCBvciBmYWxzZSB3aGVuIGhpZGRlbi5cclxuICAgKi9cblxuICBmdW5jdGlvbiB1cGRhdGVTbGlkZShzbGlkZSwgdmlzaWJsZSkge1xuICAgIHNldEF0dHJpYnV0ZShzbGlkZSwgQVJJQV9ISURERU4sICF2aXNpYmxlKTtcblxuICAgIGlmIChTcGxpZGUub3B0aW9ucy5zbGlkZUZvY3VzKSB7XG4gICAgICBzZXRBdHRyaWJ1dGUoc2xpZGUsIFRBQl9JTkRFWCwgdmlzaWJsZSA/IDAgOiAtMSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgYXJyb3dzIGlmIHRoZXkgYXJlIGF2YWlsYWJsZS5cclxuICAgKiBBcHBlbmQgc2NyZWVuIHJlYWRlciBlbGVtZW50cyBhbmQgYWRkIGFyaWEtY29udHJvbHMgYXR0cmlidXRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwcmV2IC0gUHJldmlvdXMgYXJyb3cgZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5leHQgLSBOZXh0IGFycm93IGVsZW1lbnQuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBpbml0QXJyb3dzKHByZXYsIG5leHQpIHtcbiAgICB2YXIgY29udHJvbHMgPSBFbGVtZW50cy50cmFjay5pZDtcbiAgICBzZXRBdHRyaWJ1dGUocHJldiwgQVJJQV9DT05UUk9MUywgY29udHJvbHMpO1xuICAgIHNldEF0dHJpYnV0ZShuZXh0LCBBUklBX0NPTlRST0xTLCBjb250cm9scyk7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlIGFycm93IGF0dHJpYnV0ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHByZXYgICAgICAtIFByZXZpb3VzIGFycm93IGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBuZXh0ICAgICAgLSBOZXh0IGFycm93IGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBwcmV2SW5kZXggLSBQcmV2aW91cyBzbGlkZSBpbmRleCBvciAtMSB3aGVuIHRoZXJlIGlzIG5vIHByZWNlZGUgc2xpZGUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBuZXh0SW5kZXggLSBOZXh0IHNsaWRlIGluZGV4IG9yIC0xIHdoZW4gdGhlcmUgaXMgbm8gbmV4dCBzbGlkZS5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUFycm93cyhwcmV2LCBuZXh0LCBwcmV2SW5kZXgsIG5leHRJbmRleCkge1xuICAgIHZhciBpbmRleCA9IFNwbGlkZS5pbmRleDtcbiAgICB2YXIgcHJldkxhYmVsID0gcHJldkluZGV4ID4gLTEgJiYgaW5kZXggPCBwcmV2SW5kZXggPyBpMThuLmxhc3QgOiBpMThuLnByZXY7XG4gICAgdmFyIG5leHRMYWJlbCA9IG5leHRJbmRleCA+IC0xICYmIGluZGV4ID4gbmV4dEluZGV4ID8gaTE4bi5maXJzdCA6IGkxOG4ubmV4dDtcbiAgICBzZXRBdHRyaWJ1dGUocHJldiwgQVJJQV9MQUJFTCwgcHJldkxhYmVsKTtcbiAgICBzZXRBdHRyaWJ1dGUobmV4dCwgQVJJQV9MQUJFTCwgbmV4dExhYmVsKTtcbiAgfVxuICAvKipcclxuICAgKiBJbml0aWFsaXplIHBhZ2luYXRpb24gaWYgaXQncyBhdmFpbGFibGUuXHJcbiAgICogQXBwZW5kIGEgc2NyZWVuIHJlYWRlciBlbGVtZW50IGFuZCBhZGQgYXJpYS1jb250cm9scy9sYWJlbCBhdHRyaWJ1dGUgdG8gZWFjaCBpdGVtLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgLSBEYXRhIG9iamVjdCBjb250YWluaW5nIGFsbCBpdGVtcy5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aXZlSXRlbSAtIEFuIGluaXRpYWwgYWN0aXZlIGl0ZW0uXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBpbml0UGFnaW5hdGlvbihkYXRhLCBhY3RpdmVJdGVtKSB7XG4gICAgaWYgKGFjdGl2ZUl0ZW0pIHtcbiAgICAgIHNldEF0dHJpYnV0ZShhY3RpdmVJdGVtLmJ1dHRvbiwgQVJJQV9DVVJSRU5SVCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZGF0YS5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuICAgICAgdmFyIHRleHQgPSBvcHRpb25zLmZvY3VzID09PSBmYWxzZSAmJiBvcHRpb25zLnBlclBhZ2UgPiAxID8gaTE4bi5wYWdlWCA6IGkxOG4uc2xpZGVYO1xuICAgICAgdmFyIGxhYmVsID0gc3ByaW50Zih0ZXh0LCBpdGVtLnBhZ2UgKyAxKTtcbiAgICAgIHZhciBidXR0b24gPSBpdGVtLmJ1dHRvbjtcbiAgICAgIHZhciBjb250cm9scyA9IGl0ZW0uU2xpZGVzLm1hcChmdW5jdGlvbiAoU2xpZGUpIHtcbiAgICAgICAgcmV0dXJuIFNsaWRlLnNsaWRlLmlkO1xuICAgICAgfSk7XG4gICAgICBzZXRBdHRyaWJ1dGUoYnV0dG9uLCBBUklBX0NPTlRST0xTLCBjb250cm9scy5qb2luKCcgJykpO1xuICAgICAgc2V0QXR0cmlidXRlKGJ1dHRvbiwgQVJJQV9MQUJFTCwgbGFiZWwpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBwYWdpbmF0aW9uIGF0dHJpYnV0ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gIGRhdGEgLSBEYXRhIG9iamVjdCBjb250YWluaW5nIGFsbCBpdGVtcy5cclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHByZXYgLSBBIHByZXZpb3VzIGFjdGl2ZSBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gY3VyciAtIEEgY3VycmVudCBhY3RpdmUgZWxlbWVudC5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBhZ2luYXRpb24oZGF0YSwgcHJldiwgY3Vycikge1xuICAgIGlmIChwcmV2KSB7XG4gICAgICByZW1vdmVBdHRyaWJ1dGUocHJldi5idXR0b24sIEFSSUFfQ1VSUkVOUlQpO1xuICAgIH1cblxuICAgIGlmIChjdXJyKSB7XG4gICAgICBzZXRBdHRyaWJ1dGUoY3Vyci5idXR0b24sIEFSSUFfQ1VSUkVOUlQsIHRydWUpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBJbml0aWFsaXplIGF1dG9wbGF5IGJ1dHRvbnMuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBpbml0QXV0b3BsYXkoKSB7XG4gICAgWydwbGF5JywgJ3BhdXNlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGVsbSA9IEVsZW1lbnRzW25hbWVdO1xuXG4gICAgICBpZiAoZWxtKSB7XG4gICAgICAgIGlmICghaXNCdXR0b24oZWxtKSkge1xuICAgICAgICAgIHNldEF0dHJpYnV0ZShlbG0sICdyb2xlJywgJ2J1dHRvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0QXR0cmlidXRlKGVsbSwgQVJJQV9DT05UUk9MUywgRWxlbWVudHMudHJhY2suaWQpO1xuICAgICAgICBzZXRBdHRyaWJ1dGUoZWxtLCBBUklBX0xBQkVMLCBpMThuW25hbWVdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBJbml0aWFsaXplIG5hdmlnYXRpb24gc2xpZGVyLlxyXG4gICAqIEFkZCBidXR0b24gcm9sZSwgYXJpYS1sYWJlbCwgYXJpYS1jb250cm9scyB0byBzbGlkZSBlbGVtZW50cyBhbmQgYXBwZW5kIHNjcmVlbiByZWFkZXIgdGV4dCB0byB0aGVtLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTcGxpZGV9IG1haW4gLSBBIG1haW4gU3BsaWRlIGluc3RhbmNlLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaW5pdE5hdmlnYXRpb24obWFpbikge1xuICAgIEVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKFNsaWRlKSB7XG4gICAgICB2YXIgc2xpZGUgPSBTbGlkZS5zbGlkZTtcbiAgICAgIHZhciByZWFsSW5kZXggPSBTbGlkZS5yZWFsSW5kZXg7XG5cbiAgICAgIGlmICghaXNCdXR0b24oc2xpZGUpKSB7XG4gICAgICAgIHNldEF0dHJpYnV0ZShzbGlkZSwgJ3JvbGUnLCAnYnV0dG9uJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzbGlkZUluZGV4ID0gcmVhbEluZGV4ID4gLTEgPyByZWFsSW5kZXggOiBTbGlkZS5pbmRleDtcbiAgICAgIHZhciBsYWJlbCA9IHNwcmludGYoaTE4bi5zbGlkZVgsIHNsaWRlSW5kZXggKyAxKTtcbiAgICAgIHZhciBtYWluU2xpZGUgPSBtYWluLkNvbXBvbmVudHMuRWxlbWVudHMuZ2V0U2xpZGUoc2xpZGVJbmRleCk7XG4gICAgICBzZXRBdHRyaWJ1dGUoc2xpZGUsIEFSSUFfTEFCRUwsIGxhYmVsKTtcblxuICAgICAgaWYgKG1haW5TbGlkZSkge1xuICAgICAgICBzZXRBdHRyaWJ1dGUoc2xpZGUsIEFSSUFfQ09OVFJPTFMsIG1haW5TbGlkZS5zbGlkZS5pZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlIG5hdmlnYXRpb24gYXR0cmlidXRlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgU2xpZGUgIC0gQSB0YXJnZXQgU2xpZGUgb2JqZWN0LlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWN0aXZlIC0gVHJ1ZSBpZiB0aGUgc2xpZGUgaXMgYWN0aXZlIG9yIGZhbHNlIGlmIGluYWN0aXZlLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gdXBkYXRlTmF2aWdhdGlvbihfcmVmLCBhY3RpdmUpIHtcbiAgICB2YXIgc2xpZGUgPSBfcmVmLnNsaWRlO1xuXG4gICAgaWYgKGFjdGl2ZSkge1xuICAgICAgc2V0QXR0cmlidXRlKHNsaWRlLCBBUklBX0NVUlJFTlJULCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlQXR0cmlidXRlKHNsaWRlLCBBUklBX0NVUlJFTlJUKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgYnV0dG9uIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxtIC0gQW4gZWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGJ1dHRvbi5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzQnV0dG9uKGVsbSkge1xuICAgIHJldHVybiBlbG0udGFnTmFtZSA9PT0gJ0JVVFRPTic7XG4gIH1cblxuICByZXR1cm4gQTExeTtcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvc3luYy9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIHN5bmNocm9uaXppbmcgYSBzbGlkZXIgd2l0aCBhbm90aGVyLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuLyoqXHJcbiAqIFRoZSBldmVudCBuYW1lIGZvciBzeW5jLlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxudmFyIFNZTkNfRVZFTlQgPSAnbW92ZS5zeW5jJztcbi8qKlxyXG4gKiBUaGUgZXZlbnQgbmFtZXMgZm9yIGNsaWNrIG5hdmlnYXRpb24uXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG52YXIgQ0xJQ0tfRVZFTlRTID0gJ21vdXNldXAgdG91Y2hlbmQnO1xuLyoqXHJcbiAqIFRoZSBrZXlzIGZvciB0cmlnZ2VyaW5nIHRoZSBuYXZpZ2F0aW9uIGJ1dHRvbi5cclxuICpcclxuICogQHR5cGUge1N0cmluZ1tdfVxyXG4gKi9cblxudmFyIFRSSUdHRVJfS0VZUyA9IFsnICcsICdFbnRlcicsICdTcGFjZWJhciddO1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIHN5bmNocm9uaXppbmcgYSBzbGlkZXIgd2l0aCBhbm90aGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgc3luYyA9IChmdW5jdGlvbiAoU3BsaWRlKSB7XG4gIC8qKlxyXG4gICAqIEtlZXAgdGhlIHNpYmxpbmcgU3BsaWRlIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHR5cGUge1NwbGlkZX1cclxuICAgKi9cbiAgdmFyIHNpYmxpbmcgPSBTcGxpZGUuc2libGluZztcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgc2libGluZyBzbGlkZXIgaXMgbmF2aWdhdGlvbiBvciBub3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7U3BsaWRlfGJvb2xlYW59XHJcbiAgICovXG5cbiAgdmFyIGlzTmF2aWdhdGlvbiA9IHNpYmxpbmcgJiYgc2libGluZy5vcHRpb25zLmlzTmF2aWdhdGlvbjtcbiAgLyoqXHJcbiAgICogTGF5b3V0IGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBTeW5jID0ge1xuICAgIC8qKlxyXG4gICAgICogUmVxdWlyZWQgb25seSB3aGVuIHRoZSBzdWIgc2xpZGVyIGlzIGF2YWlsYWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xuICAgIHJlcXVpcmVkOiAhIXNpYmxpbmcsXG5cbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIHN5bmNNYWluKCk7XG4gICAgICBzeW5jU2libGluZygpO1xuXG4gICAgICBpZiAoaXNOYXZpZ2F0aW9uKSB7XG4gICAgICAgIGJpbmQoKTtcbiAgICAgICAgU3BsaWRlLm9uKCdyZWZyZXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYmluZCgpO1xuICAgICAgICAgICAgc2libGluZy5lbWl0KCduYXZpZ2F0aW9uOnVwZGF0ZWQnLCBTcGxpZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYWZ0ZXIgYWxsIGNvbXBvbmVudHMgYXJlIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgaWYgKGlzTmF2aWdhdGlvbikge1xuICAgICAgICBzaWJsaW5nLmVtaXQoJ25hdmlnYXRpb246bW91bnRlZCcsIFNwbGlkZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBMaXN0ZW4gdGhlIHByaW1hcnkgc2xpZGVyIGV2ZW50IHRvIG1vdmUgc2Vjb25kYXJ5IG9uZS5cclxuICAgKiBNdXN0IHVuYmluZCBhIGhhbmRsZXIgYXQgZmlyc3QgdG8gYXZvaWQgaW5maW5pdGUgbG9vcC5cclxuICAgKi9cblxuICBmdW5jdGlvbiBzeW5jTWFpbigpIHtcbiAgICBTcGxpZGUub24oU1lOQ19FVkVOVCwgZnVuY3Rpb24gKG5ld0luZGV4LCBwcmV2SW5kZXgsIGRlc3RJbmRleCkge1xuICAgICAgc2libGluZy5vZmYoU1lOQ19FVkVOVCkuZ28oc2libGluZy5pcyhMT09QKSA/IGRlc3RJbmRleCA6IG5ld0luZGV4LCBmYWxzZSk7XG4gICAgICBzeW5jU2libGluZygpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIExpc3RlbiB0aGUgc2Vjb25kYXJ5IHNsaWRlciBldmVudCB0byBtb3ZlIHByaW1hcnkgb25lLlxyXG4gICAqIE11c3QgdW5iaW5kIGEgaGFuZGxlciBhdCBmaXJzdCB0byBhdm9pZCBpbmZpbml0ZSBsb29wLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc3luY1NpYmxpbmcoKSB7XG4gICAgc2libGluZy5vbihTWU5DX0VWRU5ULCBmdW5jdGlvbiAobmV3SW5kZXgsIHByZXZJbmRleCwgZGVzdEluZGV4KSB7XG4gICAgICBTcGxpZGUub2ZmKFNZTkNfRVZFTlQpLmdvKFNwbGlkZS5pcyhMT09QKSA/IGRlc3RJbmRleCA6IG5ld0luZGV4LCBmYWxzZSk7XG4gICAgICBzeW5jTWFpbigpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIExpc3RlbiBzb21lIGV2ZW50cyBvbiBlYWNoIHNsaWRlLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmluZCgpIHtcbiAgICBzaWJsaW5nLkNvbXBvbmVudHMuRWxlbWVudHMuZWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIHNsaWRlID0gX3JlZi5zbGlkZSxcbiAgICAgICAgICBpbmRleCA9IF9yZWYuaW5kZXg7XG5cbiAgICAgIC8qXHJcbiAgICAgICAqIExpc3RlbiBtb3VzZXVwIGFuZCB0b3VjaGVuZCBldmVudHMgdG8gaGFuZGxlIGNsaWNrLlxyXG4gICAgICAgKi9cbiAgICAgIFNwbGlkZS5vZmYoQ0xJQ0tfRVZFTlRTLCBzbGlkZSkub24oQ0xJQ0tfRVZFTlRTLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBJZ25vcmUgYSBtaWRkbGUgb3IgcmlnaHQgY2xpY2suXG4gICAgICAgIGlmICghZS5idXR0b24gfHwgZS5idXR0b24gPT09IDApIHtcbiAgICAgICAgICBtb3ZlU2libGluZyhpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHNsaWRlKTtcbiAgICAgIC8qXHJcbiAgICAgICAqIFN1YnNjcmliZSBrZXl1cCB0byBoYW5kbGUgRW50ZXIgYW5kIFNwYWNlIGtleS5cclxuICAgICAgICogTm90ZSB0aGF0IEFycmF5LmluY2x1ZGVzIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUuXHJcbiAgICAgICAqL1xuXG4gICAgICBTcGxpZGUub2ZmKCdrZXl1cCcsIHNsaWRlKS5vbigna2V5dXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoVFJJR0dFUl9LRVlTLmluZGV4T2YoZS5rZXkpID4gLTEpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgbW92ZVNpYmxpbmcoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9LCBzbGlkZSwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogTW92ZSB0aGUgc2libGluZyB0byB0aGUgZ2l2ZW4gaW5kZXguXHJcbiAgICogTmVlZCB0byBjaGVjayBcIklETEVcIiBzdGF0dXMgYmVjYXVzZSBzbGlkZXMgY2FuIGJlIG1vdmluZyBieSBEcmFnIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRhcmdldCBpbmRleC5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG1vdmVTaWJsaW5nKGluZGV4KSB7XG4gICAgaWYgKFNwbGlkZS5TdGF0ZS5pcyhJRExFKSkge1xuICAgICAgc2libGluZy5nbyhpbmRleCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFN5bmM7XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2JyZWFrcG9pbnRzL2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgdXBkYXRpbmcgb3B0aW9ucyBhY2NvcmRpbmcgdG8gYSBjdXJyZW50IHdpbmRvdyB3aWR0aC5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cbi8qKlxyXG4gKiBJbnRlcnZhbCB0aW1lIGZvciB0aHJvdHRsZS5cclxuICpcclxuICogQHR5cGUge251bWJlcn1cclxuICovXG5cbnZhciBUSFJPVFRMRSA9IDUwO1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIHVwZGF0aW5nIG9wdGlvbnMgYWNjb3JkaW5nIHRvIGEgY3VycmVudCB3aW5kb3cgd2lkdGguXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBicmVha3BvaW50cyA9IChmdW5jdGlvbiAoU3BsaWRlKSB7XG4gIC8qKlxyXG4gICAqIFN0b3JlIGJyZWFrcG9pbnRzLlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdHxib29sZWFufVxyXG4gICAqL1xuICB2YXIgYnJlYWtwb2ludHMgPSBTcGxpZGUub3B0aW9ucy5icmVha3BvaW50cztcbiAgLyoqXHJcbiAgICogVGhlIGNoZWNrIGZ1bmN0aW9uIHdob3NlIGZyZXF1ZW5jeSBvZiBjYWxsIGlzIHJlZHVjZWQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICovXG5cbiAgdmFyIHRocm90dGxlZENoZWNrID0gdGhyb3R0bGUoY2hlY2ssIFRIUk9UVExFKTtcbiAgLyoqXHJcbiAgICogS2VlcCBpbml0aWFsIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBpbml0aWFsT3B0aW9ucztcbiAgLyoqXHJcbiAgICogQW4gYXJyYXkgY29udGFpbmluZyBvYmplY3RzIG9mIHBvaW50IGFuZCBNZWRpYVF1ZXJ5TGlzdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3RbXX1cclxuICAgKi9cblxuICB2YXIgbWFwID0gW107XG4gIC8qKlxyXG4gICAqIEhvbGQgdGhlIHByZXZpb3VzIGJyZWFrcG9pbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cclxuICAgKi9cblxuICB2YXIgcHJldlBvaW50O1xuICAvKipcclxuICAgKiBCcmVha3BvaW50cyBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgQnJlYWtwb2ludHMgPSB7XG4gICAgLyoqXHJcbiAgICAgKiBSZXF1aXJlZCBvbmx5IHdoZW4gdGhlIGJyZWFrcG9pbnRzIGRlZmluaXRpb24gaXMgcHJvdmlkZWQgYW5kIGJyb3dzZXIgc3VwcG9ydHMgbWF0Y2hNZWRpYS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xuICAgIHJlcXVpcmVkOiBicmVha3BvaW50cyAmJiBtYXRjaE1lZGlhLFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICBtYXAgPSBPYmplY3Qua2V5cyhicmVha3BvaW50cykuc29ydChmdW5jdGlvbiAobiwgbSkge1xuICAgICAgICByZXR1cm4gK24gLSArbTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgbXFsOiBtYXRjaE1lZGlhKFwiKG1heC13aWR0aDpcIiArIHBvaW50ICsgXCJweClcIilcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgLypcclxuICAgICAgICogVG8ga2VlcCBtb25pdG9yaW5nIHJlc2l6ZSBldmVudCBhZnRlciBkZXN0cnVjdGlvbiB3aXRob3V0IFwiY29tcGxldGVseVwiLFxyXG4gICAgICAgKiB1c2UgbmF0aXZlIGFkZEV2ZW50TGlzdGVuZXIgaW5zdGVhZCBvZiBTcGxpZGUub24uXHJcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aHJvdHRsZWRDaGVjayk7IC8vIEtlZXAgaW5pdGlhbCBvcHRpb25zIHRvIGFwcGx5IHRoZW0gd2hlbiBubyBicmVha3BvaW50IG1hdGNoZXMuXG5cbiAgICAgIGluaXRpYWxPcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG4gICAgICBjaGVjaygpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb21wbGV0ZWx5IC0gV2hldGhlciB0byBkZXN0cm95IFNwbGlkZSBjb21wbGV0ZWx5LlxyXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveShjb21wbGV0ZWx5KSB7XG4gICAgICBpZiAoY29tcGxldGVseSkge1xuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aHJvdHRsZWRDaGVjayk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBDaGVjayB0aGUgYnJlYWtwb2ludC5cclxuICAgKi9cblxuICBmdW5jdGlvbiBjaGVjaygpIHtcbiAgICB2YXIgcG9pbnQgPSBnZXRQb2ludCgpO1xuXG4gICAgaWYgKHBvaW50ICE9PSBwcmV2UG9pbnQpIHtcbiAgICAgIHByZXZQb2ludCA9IHBvaW50O1xuICAgICAgdmFyIFN0YXRlID0gU3BsaWRlLlN0YXRlO1xuICAgICAgdmFyIG9wdGlvbnMgPSBicmVha3BvaW50c1twb2ludF0gfHwgaW5pdGlhbE9wdGlvbnM7XG4gICAgICB2YXIgZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgICAgaWYgKGRlc3Ryb3kpIHtcbiAgICAgICAgU3BsaWRlLm9wdGlvbnMgPSBpbml0aWFsT3B0aW9ucztcbiAgICAgICAgU3BsaWRlLmRlc3Ryb3koZGVzdHJveSA9PT0gJ2NvbXBsZXRlbHknKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChTdGF0ZS5pcyhERVNUUk9ZRUQpKSB7XG4gICAgICAgICAgU3BsaWRlLm1vdW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBTcGxpZGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgYnJlYWtwb2ludCBtYXRjaGluZyBjdXJyZW50IHdpbmRvdyB3aWR0aC5cclxuICAgKiBOb3RlIHRoYXQgQXJyYXkucHJvdG90eXBlLmZpbmQgaXMgbm90IHN1cHBvcnRlZCBieSBJRS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd9IC0gQSBicmVha3BvaW50IGFzIG51bWJlciBvciBzdHJpbmcuIC0xIGlmIG5vIHBvaW50IG1hdGNoZXMuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRQb2ludCgpIHtcbiAgICB2YXIgaXRlbSA9IG1hcC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLm1xbC5tYXRjaGVzO1xuICAgIH0pWzBdO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5wb2ludCA6IC0xO1xuICB9XG5cbiAgcmV0dXJuIEJyZWFrcG9pbnRzO1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9pbmRleC5qc1xuLyoqXHJcbiAqIEV4cG9ydCBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIENPTVBMRVRFID0ge1xuICBPcHRpb25zOiBvcHRpb25zLFxuICBCcmVha3BvaW50czogYnJlYWtwb2ludHMsXG4gIENvbnRyb2xsZXI6IGNvbnRyb2xsZXIsXG4gIEVsZW1lbnRzOiBjb21wb25lbnRzX2VsZW1lbnRzLFxuICBUcmFjazogdHJhY2ssXG4gIENsb25lczogY2xvbmVzLFxuICBMYXlvdXQ6IGxheW91dCxcbiAgRHJhZzogZHJhZyxcbiAgQ2xpY2s6IGNsaWNrLFxuICBBdXRvcGxheTogYXV0b3BsYXksXG4gIENvdmVyOiBjb3ZlcixcbiAgQXJyb3dzOiBhcnJvd3MsXG4gIFBhZ2luYXRpb246IHBhZ2luYXRpb24sXG4gIExhenlMb2FkOiBsYXp5bG9hZCxcbiAgS2V5Ym9hcmQ6IGtleWJvYXJkLFxuICBTeW5jOiBzeW5jLFxuICBBMTF5OiBhMTF5XG59O1xudmFyIExJR0hUID0ge1xuICBPcHRpb25zOiBvcHRpb25zLFxuICBDb250cm9sbGVyOiBjb250cm9sbGVyLFxuICBFbGVtZW50czogY29tcG9uZW50c19lbGVtZW50cyxcbiAgVHJhY2s6IHRyYWNrLFxuICBDbG9uZXM6IGNsb25lcyxcbiAgTGF5b3V0OiBsYXlvdXQsXG4gIERyYWc6IGRyYWcsXG4gIENsaWNrOiBjbGljayxcbiAgQXJyb3dzOiBhcnJvd3MsXG4gIFBhZ2luYXRpb246IHBhZ2luYXRpb24sXG4gIEExMXk6IGExMXlcbn07XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9tb2R1bGUvbW9kdWxlLmpzXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXHJcbiAqIEV4cG9ydCBTcGxpZGUgY2xhc3MgZm9yIGltcG9ydC5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cbi8qKlxyXG4gKiBFeHBvcnQgU3BsaWRlIGNsYXNzIGZvciBpbXBvcnQgZnJvbSBvdGhlciBwcm9qZWN0cy5cclxuICovXG5cbnZhciBtb2R1bGVfU3BsaWRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29yZSkge1xuICBfaW5oZXJpdHNMb29zZShTcGxpZGUsIF9Db3JlKTtcblxuICBmdW5jdGlvbiBTcGxpZGUocm9vdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfQ29yZS5jYWxsKHRoaXMsIHJvb3QsIG9wdGlvbnMsIENPTVBMRVRFKSB8fCB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIFNwbGlkZTtcbn0oU3BsaWRlKTtcblxuXG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApXG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0ICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG4vKioqKioqLyBcdFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gbW9kdWxlIGV4cG9ydHMgbXVzdCBiZSByZXR1cm5lZCBmcm9tIHJ1bnRpbWUgc28gZW50cnkgaW5saW5pbmcgaXMgZGlzYWJsZWRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMzExKTtcbi8qKioqKiovIH0pKClcbjtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@splidejs/splide/dist/js/splide.esm.js\n");

/***/ }),

/***/ "./src/js/slider.js":
/*!**************************!*\
  !*** ./src/js/slider.js ***!
  \**************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _splidejs_splide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @splidejs/splide */ \"./node_modules/@splidejs/splide/dist/js/splide.esm.js\");\n/* harmony import */ var _splidejs_splide__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_splidejs_splide__WEBPACK_IMPORTED_MODULE_0__);\n\nvar el = document.querySelectorAll('.block-header-slider .splide');\nfor (var i = 0; i < el.length; i++) {\n  new (_splidejs_splide__WEBPACK_IMPORTED_MODULE_0___default())(el[i], {\n    type: 'fade',\n    rewind: true,\n    perPage: 1,\n    autoplay: true,\n    interval: 7000,\n    arrows: false,\n    pagination: true\n  }).mount();\n}\nvar slideoverlay = document.querySelectorAll('.block-header-slider-overlay .splide');\nfor (var _i = 0; _i < slideoverlay.length; _i++) {\n  new (_splidejs_splide__WEBPACK_IMPORTED_MODULE_0___default())(slideoverlay[_i], {\n    type: 'fade',\n    rewind: true,\n    perPage: 1,\n    autoplay: true,\n    interval: 7000,\n    arrows: false,\n    pagination: false\n  }).mount();\n}\nvar element = document.querySelectorAll('.image-slider .splide');\nfor (var _i2 = 0; _i2 < element.length; _i2++) {\n  new (_splidejs_splide__WEBPACK_IMPORTED_MODULE_0___default())(element[_i2], {\n    type: 'fade',\n    rewind: true,\n    perPage: 1,\n    autoplay: true,\n    interval: 7000,\n    arrows: false,\n    pagination: true\n  }).mount();\n}\nvar textslider = document.querySelectorAll('.text-slider .splide');\nfor (var _i3 = 0; _i3 < textslider.length; _i3++) {\n  new (_splidejs_splide__WEBPACK_IMPORTED_MODULE_0___default())(textslider[_i3], {\n    type: 'loop',\n    rewind: true,\n    perPage: 1,\n    autoplay: true,\n    interval: 3500,\n    arrows: false,\n    pagination: true\n  }).mount();\n}\nvar eventslider = document.querySelectorAll('.block-events .splide');\nfor (var _i4 = 0; _i4 < eventslider.length; _i4++) {\n  new (_splidejs_splide__WEBPACK_IMPORTED_MODULE_0___default())(eventslider[_i4], {\n    type: 'fade',\n    rewind: true,\n    perPage: 1,\n    autoplay: true,\n    interval: 4000,\n    arrows: false,\n    pagination: true\n  }).mount();\n}\nvar partner_carousel = document.querySelectorAll('.partner-carousel .splide');\nfor (var _i5 = 0; _i5 < partner_carousel.length; _i5++) {\n  new (_splidejs_splide__WEBPACK_IMPORTED_MODULE_0___default())(partner_carousel[_i5], {\n    type: 'slide',\n    rewind: true,\n    autoplay: true,\n    interval: 4000,\n    arrows: false,\n    pagination: false,\n    perPage: 6,\n    breakpoints: {\n      600: {\n        perPage: 1\n      },\n      768: {\n        perPage: 2\n      },\n      992: {\n        perPage: 3\n      },\n      1200: {\n        perPage: 4\n      },\n      1600: {\n        perPage: 5\n      }\n    }\n  }).mount();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TSxFQUFFLElBQUk7SUFDWkMsT0FBTyxFQUFFLENBQUM7SUFDVkMsUUFBUSxFQUFFLElBQUk7SUFDZEMsUUFBUSxFQUFFLElBQUk7SUFDZEMsTUFBTSxFQUFFLEtBQUs7SUFDYkMsVUFBVSxFQUFFO0VBQ2hCLENBQUMsQ0FBQyxDQUFDQyxLQUFLLENBQUMsQ0FBQztBQUNkO0FBRUEsSUFBSUssZ0JBQWdCLEdBQUdoQixRQUFRLENBQUNDLGdCQUFnQixDQUFDLDJCQUEyQixDQUFDO0FBQzdFLEtBQUssSUFBSUMsR0FBQyxHQUFHLENBQUMsRUFBRUEsR0FBQyxHQUFHYyxnQkFBZ0IsQ0FBQ2IsTUFBTSxFQUFFRCxHQUFDLEVBQUUsRUFBRTtFQUM5QyxJQUFJSix5REFBTSxDQUFDa0IsZ0JBQWdCLENBQUNkLEdBQUMsQ0FBQyxFQUFFO0lBQzVCRSxJQUFJLEVBQUUsT0FBTztJQUNiQyxNQUFNLEVBQUUsSUFBSTtJQUNaRSxRQUFRLEVBQUUsSUFBSTtJQUNkQyxRQUFRLEVBQUUsSUFBSTtJQUNkQyxNQUFNLEVBQUUsS0FBSztJQUNiQyxVQUFVLEVBQUUsS0FBSztJQUNqQkosT0FBTyxFQUFFLENBQUM7SUFDVlcsV0FBVyxFQUFFO01BQ1QsR0FBRyxFQUFFO1FBQ0RYLE9BQU8sRUFBQztNQUNaLENBQUM7TUFDRCxHQUFHLEVBQUU7UUFDREEsT0FBTyxFQUFDO01BQ1osQ0FBQztNQUNELEdBQUcsRUFBRTtRQUNEQSxPQUFPLEVBQUM7TUFDWixDQUFDO01BQ0QsSUFBSSxFQUFFO1FBQ0ZBLE9BQU8sRUFBQztNQUNaLENBQUM7TUFDRCxJQUFJLEVBQUU7UUFDRkEsT0FBTyxFQUFDO01BQ1o7SUFDSjtFQUNKLENBQUMsQ0FBQyxDQUFDSyxLQUFLLENBQUMsQ0FBQztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdm9nbC8uL3NyYy9qcy9zbGlkZXIuanM/MmRkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3BsaWRlIGZyb20gJ0BzcGxpZGVqcy9zcGxpZGUnO1xuXG5sZXQgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYmxvY2staGVhZGVyLXNsaWRlciAuc3BsaWRlJyk7XG5mb3IgKGxldCBpID0gMDsgaSA8IGVsLmxlbmd0aDsgaSsrKSB7XG4gICAgbmV3IFNwbGlkZShlbFtpXSwge1xuICAgICAgICB0eXBlOiAnZmFkZScsXG4gICAgICAgIHJld2luZDogdHJ1ZSxcbiAgICAgICAgcGVyUGFnZTogMSxcbiAgICAgICAgYXV0b3BsYXk6IHRydWUsXG4gICAgICAgIGludGVydmFsOiA3MDAwLFxuICAgICAgICBhcnJvd3M6IGZhbHNlLFxuICAgICAgICBwYWdpbmF0aW9uOiB0cnVlXG4gICAgfSkubW91bnQoKTtcbn1cblxuXG5sZXQgc2xpZGVvdmVybGF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmJsb2NrLWhlYWRlci1zbGlkZXItb3ZlcmxheSAuc3BsaWRlJyk7XG5mb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlb3ZlcmxheS5sZW5ndGg7IGkrKykge1xuICAgIG5ldyBTcGxpZGUoc2xpZGVvdmVybGF5W2ldLCB7XG4gICAgICAgIHR5cGU6ICdmYWRlJyxcbiAgICAgICAgcmV3aW5kOiB0cnVlLFxuICAgICAgICBwZXJQYWdlOiAxLFxuICAgICAgICBhdXRvcGxheTogdHJ1ZSxcbiAgICAgICAgaW50ZXJ2YWw6IDcwMDAsXG4gICAgICAgIGFycm93czogZmFsc2UsXG4gICAgICAgIHBhZ2luYXRpb246IGZhbHNlXG4gICAgfSkubW91bnQoKTtcbn1cblxuXG5cbmxldCBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmltYWdlLXNsaWRlciAuc3BsaWRlJyk7XG5mb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQubGVuZ3RoOyBpKyspIHtcbiAgICBuZXcgU3BsaWRlKGVsZW1lbnRbaV0sIHtcbiAgICAgICAgdHlwZTogJ2ZhZGUnLFxuICAgICAgICByZXdpbmQ6IHRydWUsXG4gICAgICAgIHBlclBhZ2U6IDEsXG4gICAgICAgIGF1dG9wbGF5OiB0cnVlLFxuICAgICAgICBpbnRlcnZhbDogNzAwMCxcbiAgICAgICAgYXJyb3dzOiBmYWxzZSxcbiAgICAgICAgcGFnaW5hdGlvbjogdHJ1ZSxcbiAgICB9KS5tb3VudCgpO1xufVxuXG5sZXQgdGV4dHNsaWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy50ZXh0LXNsaWRlciAuc3BsaWRlJyk7XG5mb3IgKGxldCBpID0gMDsgaSA8IHRleHRzbGlkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBuZXcgU3BsaWRlKHRleHRzbGlkZXJbaV0sIHtcbiAgICAgICAgdHlwZTogJ2xvb3AnLFxuICAgICAgICByZXdpbmQ6IHRydWUsXG4gICAgICAgIHBlclBhZ2U6IDEsXG4gICAgICAgIGF1dG9wbGF5OiB0cnVlLFxuICAgICAgICBpbnRlcnZhbDogMzUwMCxcbiAgICAgICAgYXJyb3dzOiBmYWxzZSxcbiAgICAgICAgcGFnaW5hdGlvbjogdHJ1ZVxuICAgIH0pLm1vdW50KCk7XG59XG5cblxubGV0IGV2ZW50c2xpZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmJsb2NrLWV2ZW50cyAuc3BsaWRlJyk7XG5mb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50c2xpZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgbmV3IFNwbGlkZShldmVudHNsaWRlcltpXSwge1xuICAgICAgICB0eXBlOiAnZmFkZScsXG4gICAgICAgIHJld2luZDogdHJ1ZSxcbiAgICAgICAgcGVyUGFnZTogMSxcbiAgICAgICAgYXV0b3BsYXk6IHRydWUsXG4gICAgICAgIGludGVydmFsOiA0MDAwLFxuICAgICAgICBhcnJvd3M6IGZhbHNlLFxuICAgICAgICBwYWdpbmF0aW9uOiB0cnVlXG4gICAgfSkubW91bnQoKTtcbn1cblxubGV0IHBhcnRuZXJfY2Fyb3VzZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucGFydG5lci1jYXJvdXNlbCAuc3BsaWRlJyk7XG5mb3IgKGxldCBpID0gMDsgaSA8IHBhcnRuZXJfY2Fyb3VzZWwubGVuZ3RoOyBpKyspIHtcbiAgICBuZXcgU3BsaWRlKHBhcnRuZXJfY2Fyb3VzZWxbaV0sIHtcbiAgICAgICAgdHlwZTogJ3NsaWRlJyxcbiAgICAgICAgcmV3aW5kOiB0cnVlLFxuICAgICAgICBhdXRvcGxheTogdHJ1ZSxcbiAgICAgICAgaW50ZXJ2YWw6IDQwMDAsXG4gICAgICAgIGFycm93czogZmFsc2UsXG4gICAgICAgIHBhZ2luYXRpb246IGZhbHNlLFxuICAgICAgICBwZXJQYWdlOiA2LFxuICAgICAgICBicmVha3BvaW50czoge1xuICAgICAgICAgICAgNjAwOiB7XG4gICAgICAgICAgICAgICAgcGVyUGFnZToxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgNzY4OiB7XG4gICAgICAgICAgICAgICAgcGVyUGFnZToyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgOTkyOiB7XG4gICAgICAgICAgICAgICAgcGVyUGFnZTozXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMTIwMDoge1xuICAgICAgICAgICAgICAgIHBlclBhZ2U6NFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDE2MDA6IHtcbiAgICAgICAgICAgICAgICBwZXJQYWdlOjVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pLm1vdW50KCk7XG59XG4iXSwibmFtZXMiOlsiU3BsaWRlIiwiZWwiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpIiwibGVuZ3RoIiwidHlwZSIsInJld2luZCIsInBlclBhZ2UiLCJhdXRvcGxheSIsImludGVydmFsIiwiYXJyb3dzIiwicGFnaW5hdGlvbiIsIm1vdW50Iiwic2xpZGVvdmVybGF5IiwiZWxlbWVudCIsInRleHRzbGlkZXIiLCJldmVudHNsaWRlciIsInBhcnRuZXJfY2Fyb3VzZWwiLCJicmVha3BvaW50cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/slider.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/slider.js");
/******/ 	
/******/ })()
;